# -*- coding: utf-8 -*-
"""
Utilities for creating a sandbox for a service to facilitate end-to-end
testing.

This module contains many utilities for setting up a sandbox in a context
manager. If you need a standard sandbox you will probably be able to use
:func:`standard_sandbox`. If you need anything special you can use the
utilities provided by this module to create your own custom sandbox.


Using the Standard Sandbox
--------------------------

See :func:`standard_sandbox` for example usage.

If you wanted to use this sandbox with a clientlib, you might do something
like this:

.. code-block:: python

    from staticconf.testing import MockConfiguration
    from yelp_servlib.testing import sandbox


    with sandbox.standard_sandbox(SandboxConfig) as sandbox_env:
        conf = {'services.my_service.host': 'localhost',
                'services.my_service.port': sandbox_env.port}
        with MockConfiguration(conf, namespace='services'):
            # Now you can use the clientlib and it will hit the service
            ...


.. warning::

    Your service config probably includes a line to initialize :mod:`yelp_conn`
    (ex: `initialize: yelp_conn.initialize`). You will need to remove the
    `yelp_conn.initialize` line from your configuration file, and add that same
    line (`yelp_conn.initialize()`) to your `webapp.py` after
    :mod:`yelp_pyramid` is included by :mod:`pyramid`.
"""
from collections import namedtuple
import contextlib
import logging
import pkg_resources
import os
import shutil
import socket
import subprocess
import tempfile


log = logging.getLogger(__name__)


SandboxEnv = namedtuple('SandboxEnv', 'port working_dir')


def pick_unused_port():
    """ Return a port that is currently unused.

    There is a race condition here in that the returned port can be grabbed
    by any other process. This should only be used for testing.
    """
    with contextlib.closing(
        socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    ) as s:
        s.bind(('localhost', 0))
        _, port = s.getsockname()
        return port


@contextlib.contextmanager
def run_service(init_script, env_config_path, virtualenv_path, working_dir=None):
    """Run a service in a virtualenv, as a context manager. ``init_script``
    will be called with ``start and ``stop`` to start and stop the service.

    The context manager returns the ``port`` of the service as the context.
    """
    port = pick_unused_port()
    env = dict(os.environ)
    pidfile = os.path.join(working_dir or os.getcwd(), 'sandbox.pid')
    env.update({
        'PORT':                     str(port),
        'SERVICE_ENV_CONFIG_PATH':  env_config_path,
        'VIRTUALENV_PATH':          virtualenv_path,
        'BASEPATH':                 os.getcwd(),
        'PIDFILE':                  pidfile,
    })
    subprocess.check_call([init_script, 'start'], env=env)
    try:
        yield port
    finally:
        subprocess.check_call([init_script, 'stop'], env=env)


@contextlib.contextmanager
def build_working_dir():
    """Create a temporary directory which is removed when the context manager
    exits.

    .. note::

        Only recommended for testing. Should not be used in production code.
    """
    working_dir = tempfile.mkdtemp()
    try:
        yield working_dir
    finally:
        shutil.rmtree(working_dir)


def render_templated_file(target, template, **context):
    """Write a file to ``target`` from a template and context.

    :param target: the file path of the file being created
    :param template: the template source
    :param context: context used to fill in the template file
    """
    with open(template, 'r') as read_file:
        with open(target, 'w') as write_file:
            write_file.write(read_file.read().format(**context))


@contextlib.contextmanager
def db_topology(target, template, database_name, fixtures):
    """Create a mysqld sandbox and write a topology file from the template.

    The template should use `{read_socket}` and `{write_socket}` to accept
    socket filenames.

    :param target: file path to topology file to write
    :param template: file path to topology.yaml template
    :param database_name: name of the database to create
    :param fixtures: list of files to execute as database fixtures
    :returns: a context manager around the sandboxed database
    """
    import yelp_conn.testing.sandbox as db_sandbox

    with db_sandbox.start() as mysqld:
        with db_sandbox.database(mysqld, db_name=database_name):
            db_sandbox.load_fixtures(mysqld.get_conn(), database_name, fixtures)
            render_templated_file(
                    target,
                    template,
                    read_socket=mysqld.socket,
                    write_socket=mysqld.socket)
            yield


def write_env_config(working_dir, topology_filename):
    """Write an env_config with a custom topology and clog directory.

    :param working_dir: full path to a temporary directory
    :param topology_filename: full path to a topology file to use
    :returns: full path to the env_config file
    """
    env_config = os.path.join(working_dir, 'env_config.yaml')
    clog_log_dir = os.path.join(working_dir, 'logs')
    os.makedirs(clog_log_dir)
    template = pkg_resources.resource_filename('yelp_servlib.testing.templates',
                                               'env_config.yaml')

    render_templated_file(
            env_config,
            template,
            clog_log_dir=clog_log_dir,
            topology_filename=topology_filename)

    return env_config


@contextlib.contextmanager
def standard_sandbox(config):
    """Start a sandbox from a configuration.

    This sandbox will:

     * create a database sandbox
     * start the service using that database
     * send scribe logs to a local directory

    Example:

    .. code-block:: python

        from yelp_servlib.testing import sandbox

        class SandboxConfig(object):

            # A template which accepts {read_socket}, {write_socket} for
            # database connections
            topology_template = 'testing/templates/topology.yaml'

            # The database name used by your service
            database_name = 'my_service'

            # A list of files to execute into the database
            database_fixtures = ['schemas/tables/table_one.sql']

            # Serviceinit file used to start and stop your service
            serviceinit_command = 'serviceinit.d/my_service'

            # Path to a virtualenv used to run your service
            # You would have to set this in your tox.ini
            virtualenv_path = os.environ['VIRTUAL_ENV']


        with sandbox.standard_sandbox(SandboxConfig) as sandbox_env:
            ...


    :param config: configuration for the sandbox (see example)
    :returns: a context around a sandbox, which yields a :class:`SandboxEnv`
    """

    with build_working_dir() as working_dir:
        # This file will be created by write_env_config()
        topology_filename = os.path.join(working_dir, 'topology.yaml')
        env_config = write_env_config(working_dir, topology_filename)

        with db_topology(
                topology_filename,
                config.topology_template,
                config.database_name,
                config.database_fixtures):
            with run_service(
                    config.serviceinit_command,
                    env_config,
                    config.virtualenv_path,
                    working_dir) as port:
                yield SandboxEnv(port, working_dir)
