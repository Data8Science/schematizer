import cgi
import simplejson as json
from urllib import urlencode
import cStringIO

from testify import TestCase
from testify import assert_in
from testify import setup
from testify import setup_teardown
import testify
from mock import patch

import tornado.httpserver
import tornado.testing
import tornado.web

from yelp_servlib import config
from yelp_servlib.jsonschema_util import get_validator

class MockStream(object):
    """
    A mock stream object so that we don't get crashes inside of
    tornado logic.
    """

    def set_close_callback(self, _):
        pass


class MockConnection(object):
    """
    A mock connection object so that we don't get crashes inside of
    tornado logic.
    """

    xheaders = None
    stream = MockStream()
    response = ''

    def finish(self):
        pass

    def write(self, s, callback=None):
        self.response += s
        if callback is not None:
            callback()


def get_response(application, method, url, body, **kwargs):
    """A static method for calling a service, given an application.

    Returns a Tornado HTTPResponse object. Useful if you need to check status
    codes, headers, etc...

    .. warning::

        It is advisable to use TornadoTestCase instead of this static method in
        your tests. There are significant differences in what we do here compared
        to how your service actually handles requests.

        TornadoTestCase avoids those pitfalls and is just better at talking to your
        service.
    """
    mock_connection = MockConnection()

    request = tornado.httpserver.HTTPRequest(
            method,
            url,
            connection=mock_connection,
            remote_ip='127.0.0.1',
            **kwargs
    )

    # POST/PUT methods need to fake the data they send. __call__
    # on the application doesn't properly handle `body` arguments.
    if method in ('POST', 'PUT'):
        # Allow url-encoded strings or dictionaries for POST data
        if isinstance(body, dict):
            body = urlencode(body)

        request.body = body

        # Parse the arguments and set them on the request.
        # Stolen from Tornado's arg parsing.
        arguments = cgi.parse_qs(body)
        for name, values in arguments.iteritems():
            values = [v for v in values if v]
            if values:
                request.arguments[name] = values

        # Set Content-Length header for tornado.wsgi.WSGIApplication
        # If this is not set, the tornado wsgi app will not read the body
        if len(request.body) > 0:
            request.headers['Content-Length'] = len(body)

    # Handle the request and write output to our MockConnection
    application(request)

    # do some dirty parsing in order to reconstruct an HTTPResponse object
    raw_headers, body = mock_connection.response.split('\r\n\r\n')
    status, raw_headers = raw_headers.split('\r\n', 1)
    headers = tornado.httputil.HTTPHeaders.parse(raw_headers)
    code = int(status[len('HTTP/1.0 '):len('HTTP/1.0 ') + 3])

    request.url = url

    return tornado.httpclient.HTTPResponse(
            request,
            code,
            headers=headers,
            buffer=cStringIO.StringIO(body),
    )

def get_service_response(application, method, url, body='', expect_json=True, **kwargs):
    """Deprecated method that blindly returns JSON from your response.

    You probably don't want to use this. Use a real test case.
    """
    response = get_response(application, method, url, body, **kwargs)

    if expect_json:
        return json.loads(response.body)
    else:
        return response.body


class ServiceTestCase(TestCase):
    """
    A test case for end-to-end tests of services. You specify a URL,
    the HTTP method, (maybe some data in the case of POST), an
    instance of a subclass of tornado.web.Application, and the
    expected JSON response (in Python data format), and the test fails
    iff the response is not what was expected.
    """

    __test__ = False

    application = None
    method = None
    body = ''
    url_format = None
    url_params = None
    response = None
    expect_json_response = True
    log_errors = []

    @setup
    def setup(self):
        assert self.application
        assert_in(self.method, tornado.web.RequestHandler.SUPPORTED_METHODS)

    def mock_log_line(self, log_name, log_data):
        data = json.loads(log_data)
        errors = None
        if (log_name == str(config.scribe_error_log)):
            errors = [e.message for e in get_validator('error', data.get('version')).iter_errors(data)]
        elif (log_name == str(config.scribe_log)):
            errors = [e.message for e in get_validator('request', data.get('version')).iter_errors(data)]
        if errors:
            self.log_errors.append({'log_name': log_name, 'data': log_data, 'errors': errors})

    @setup_teardown
    def validate_log(self):
        with patch('yelp_servlib.request_util.clog_util', log_line=self.mock_log_line):
            yield

    def construct_url(self):
        assert self.url_format

        if self.url_params:
            return self.url_format % self.url_params
        else:
            return self.url_format

    def get_response(self, url=None, method=None, body=None, **kwargs):
        url = url or self.construct_url()
        method = method or self.method
        body = body or self.body
        return get_response(self.application, method, url, body, **kwargs)

    def get_response_body(self, **kwargs):
        response = self.get_response(**kwargs)
        if self.expect_json_response:
            return json.loads(response.body)
        else:
            return response.body

    def test_response(self):
        self.log_errors = []
        response_body = self.get_response_body()
        self.assert_response_ok(response_body)
        testify.assert_equal(0, len(self.log_errors), "Invalid log entry %r" % self.log_errors)

    def assert_response_ok(self, json):
        raise NotImplementedError


class TornadoTestCase(tornado.testing.AsyncHTTPTestCase):
    """A test case for services with tight Tornado integration."""
    __test__ = False

    # are you sure? you really should be checking your status codes...
    force_json_responses = False

    def construct_url(self, path=None):
        path = path or self.url_format % self.url_params
        return self.get_url(path)

    def fetch(self, path, *args, **kwargs):
        """Synchronously fetch the given path."""
        if '://' in path:
            url = path # we already have a fully qualified path
        else:
            url = self.construct_url(path)

        self.http_client.fetch(url, self.stop, *args, **kwargs)
        response = self.wait()

        return response

    def get_request_kwargs(self):
        """Any kwargs that should accompany your request.

        For example, if you require a secure client connection, you might
        return something like

            dict(
                valdiate_certs=True,
                ca_certs='...',
                client_cert='...',
                client_key='...',
            )
        """
        return {}

    def get_response(self, url=None, method=None, body=None, json=False):
        """Responsible for communicating with your service.

        Unlike the static `get_response` method defined in this module, this
        uses Tornado's `fetch` method, which is much closer to reality.

        Normally returns an HTTPResponse object, but can return JSON if you
        really, really want it.
        """
        url = url or self.construct_url()
        method = method or self.method
        body = body or self.body

        if method == 'GET':
            body = None

        request_kwargs = self.get_request_kwargs()
        response = self.fetch(url, method=method, body=body, **request_kwargs)

        if json or self.force_json_responses:
            return self.json(response)

        return response

    def json(self, response):
        """Helper for reading an HTTPResponse as JSON."""
        return json.loads(response.body)

    def get(self, path, *args, **kwargs):
        return self.fetch(path, method='GET', *args, **kwargs)

    def post(self, path, body, *args, **kwargs):
        return self.fetch(path, method='POST', body=body, *args, **kwargs)

    def put(self, path, body, *args, **kwargs):
        return self.fetch(path, method='PUT', body=body, *args, **kwargs)

    def delete(self, path, *args, **kwargs):
        return self.fetch(path, method='DELETE', *args, **kwargs)


class AutomaticTornadoTestCase(TornadoTestCase):
    """Similar to ServiceTestCase, but with more robust Tornado integration."""
    __test__ = False

    method = 'GET'
    # data to be POSTed, a dict or url-encoded string
    body = None
    # a format string (args optional) to hit, e.g., '/foo/%(bar)s?bar=%(baz)s'
    url_format = ''
    # stuff to fill in url_format with, e.g., {'bar': 'a', 'baz': 'b'}
    url_params = {}

    def test_response(self):
        response = self.get_response()
        self.assert_response_ok(response)

    def assert_response_ok(self, response):
        """Overload this to test the correctness of your service.

        Response is an HTTPResponse object.
        """
        raise NotImplementedError
