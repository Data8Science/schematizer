# -*- coding: utf-8 -*-
"""
Tools for working with a :mod:`tornado` stack.

.. deprecated:: 2.0.0

.. warning::

    This module is no longer being developed. It has been replaced by
    :mod:`yelp_pyramid`.

"""
import httplib
import socket
import struct
import time
import traceback
import tornado.web
import tornado.httpserver

from yelp_servlib import config
from yelp_servlib import status as status_str
from yelp_servlib import clog_util

try:
    import simplejson as json
    # Make pyflakes shut up
    json
except ImportError:
    import json

_request_handlers = []

_logger_name = __name__


def patch_tornado_http_request_repr():
    """In tornado version 2.2, HTTPRequest's repr will show both POST body
    and raw headers on stack traces. Since POST body can include PII and
    headers can include credentials (HTTP basic auth), monkeypatch
    HTTPRequest.__repr__ to remove sensitive information
    """
    # A slightly modified version of tornado.httpserver.HTTPRequest.__repr__
    # that doesn't log body at all and redacts sensitive headers
    def safer_repr(self):
        attrs = ("protocol", "host", "method", "uri", "version", "remote_ip")
        args = ", ".join(["%s=%r" % (n, getattr(self, n)) for n in attrs])
        return "%s(%s, headers=%s)" % (
            self.__class__.__name__, args, sanitize_headers(self.headers))

    tornado.httpserver.HTTPRequest.__repr__ = safer_repr


# All templated tornado services will use request_util, so it should be
# sufficient to patch HTTPRequest here on module import
patch_tornado_http_request_repr()


# TODO: this is duplicated in yelp-main ranger logging
def sanitize_headers(headers):
    """Sanitize sensitive request headers for logging"""
    results = dict(headers)
    # Redact instead of removing Authorization header so that those
    # using Basic Auth (e.g. feeds, partner_api) can debug if needed
    if results.get('Authorization'):
        results['Authorization'] = '***redacted***'
    return results


class RequestHandlerBase(tornado.web.RequestHandler):
    """
    This is the base class for both HTTP/REST and HTTP/Thrift request handlers. It creates and fills
    ``self.clog_data`` with the basic and common info. It also defines basic common behaviour like scribe
    logging on success, or an apperror like traceback on error.

    .. note::

        If you ever need to add another style of services over HTTP, you can inherit from this for
        your base class.
    """

    # Version identifier.
    version = None

    def initialize(self, *args, **kwargs):
        """
        Initialise the request and set ``self.clog_data`` to have some standard data that we want to scribe
        log.
        """
        super(RequestHandlerBase, self).initialize(*args, **kwargs)
        self.clog_data = {
            'hostname': socket.gethostname(),
            'unique_request_id': self.request.headers.get('X-Unique-Request-Id'),
            'time': self.request._start_time,
            'time_elapsed': None,
            'request': {
                'headers': sanitize_headers(self.request.headers),
                'host': self.request.headers.get('Host'),
                'method': self.request.method,
                'remote_ip': self.request.headers.get('X-Forwarded-For', self.request.remote_ip),
                'uri': self.request.uri
                },
            'response': {}
            }

    def get_error_html(self, status_code, **kwargs):
        """
        Returns a stacktrace in the body and scribe logs an apperror style message.

        :param status_code: a httplib_ status code.
        """
        # If tornado is upgraded, this should be named 'write_error', and it should actually write
        # the formatted_tb instead of returning it.
        self.set_header('Content-Type', 'text/plain')
        formatted_tb = log_tb = traceback.format_exc()
        try:
            # create an apperorr-style traceback dictionary
            tb_dict = {
                'logger': _logger_name,
                'level': 'ERROR', # same as above
                'message': 'service exception',
                'notify': {},
                'packed_time': struct.pack('<d', time.time()).encode('hex'),
                'hostname': socket.gethostname(),
                'unique_request_id': self.request.headers.get('X-Unique-Request-Id'),
                'request': {
                    'host': self.request.headers.get('Host'),
                    'ip': self.request.headers.get('X-Forwarded-For', self.request.remote_ip),
                    'method': self.request.method,
                    'referer': self.request.headers.get('Referer'),
                    'uri': self.request.uri,
                    'user_agent': self.request.headers.get('User-Agent'),
                    'version': self.version,
                    },
                'traceback': traceback.format_exc().split('\n')
                }
            log_tb = json.dumps(tb_dict)
        finally:
            # Ideally, clog_util.log_line would str() it's stream so we don't have to do this.
            clog_util.log_line(str(config.scribe_error_log), log_tb)
            return formatted_tb

    def finish(self, chunk=None):
        """
        Overrides tornado.web.RequestHandler to scribe log at the end of the request. Captures
        elapsed time and such.
        """
        # For HTTP 1.1 compliance: If the request contained a 'Connection close' header,
        # we need to return a 'Connection close' header. Some HTTP clients (including
        # Jetty) depend on this behavior.
        connection_header = self.request.headers.get("Connection")
        if connection_header is not None and connection_header.lower() == 'close':
            self.set_header('Connection', 'close')

        finish_val = super(RequestHandlerBase, self).finish(chunk=chunk)
        # TODO(26986) Once we upgrade Tornado this will happen in super.
        self.on_finish()
        try:
            self.clog_data['time_elapsed'] = self.request.request_time()
            self.clog_data['response'] = {
                'status_code': self._status_code,
                'headers': self._headers
                }
            # Ideally, clog_util.log_line would str() it's stream so we don't have to do this.
            clog_util.log_line(str(config.scribe_log), json.dumps(self.clog_data))
        finally:
            return finish_val

    def on_finish(self):
        """Called after the end of a request.

        Override this method to perform cleanup, logging, etc.
        This method is a counterpart to `prepare`.  ``on_finish`` may
        not produce any output, as it is called after the response
        has been sent to the client.
        """
        pass


class RequestHandlerMeta(type(tornado.web.RequestHandler)):
    """
    This is the ``__metaclass__`` for ``RequestHandler`` class. It gets the ``path`` attribute and
    exposes it to the webapp.
    """
    def __init__(cls, name, bases, dct):
        super(RequestHandlerMeta, cls).__init__(name, bases, dct)
        # RequestHandler subclasses *must* set path, even if set to None, to make it explicit if
        # it's a reachable handler or an unreachable superclass.
        path = dct.get('path')
        if path:
            _request_handlers.append((path, cls))


class RequestHandler(RequestHandlerBase):
    """
    This is the base class for HTTP/REST request handlers.


    Subclasses must set;

       * ``path`` the path this request handler handles, eg. ``/v1/action/([0-9]*)``.
       * ``method_name`` the name of the call to log in the scribe log, eg ``action``.
       * ``version`` the version identifier, such as <servicename>.version.VERSION.

    Set ``path`` to ``None`` to indicate this handler is not reachable, eg. if it's a superclass for
    a group of handlers.
    """

    # The metaclass ensures we capture the 'path' attribute and put it into
    # '_request_handlers'. This is what exposes the request handler to the webapp.
    __metaclass__ = RequestHandlerMeta

    def initialize(self, *args, **kwargs):
        super(RequestHandler, self).initialize(*args, **kwargs)
        self.path_params = kwargs

        self.clog_data.update({
            'method_name': self.method_name,
            })

    def render_json(self, status, data):
        """
        Builds and writes a json response via 'render_response'.

        .. warning::

            This function provides backwards compatiblity to early SOA codes that used "ok" and
            "fail" in 'status'. They are now converted to httplib_ status codes ``OK`` and
            ``BAD_REQUEST`` status codes and the status code *IS NOT* added to ``data``.

        :param status: HTTP status code to set. Use httplib_ constants like ``httplib.OK`` preferably.
        :param data: The data to json dump of the response.
        """
        # See http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
        if not isinstance(data, dict):
            raise TypeError('data must be a dict, not %r' % (type(data),))
        self.set_header('Content-Type', 'application/json')
        if status == status_str.OK:
            self.render_response(httplib.OK, data, is_json=True)
        elif status == status_str.FAIL:
            self.render_response(httplib.BAD_REQUEST, data, is_json=True)
        else:
            self.render_response(status, data, is_json=True)

    def render_response(self, status, body, is_json=False):
        """
        Builds and writes a response.

        :param status: HTTP status code to set. Use httplib_ constants like ``httplib.OK`` preferably.
        :param body: The body of the response.
        :param is_json: Set to True to make the response body by calling ``json.dumps(body)``.
        """
        if is_json:
            self.set_header('Content-Type', 'application/json')
            body = json.dumps(body)
        self.set_status(status)
        self.write(body + '\n')
