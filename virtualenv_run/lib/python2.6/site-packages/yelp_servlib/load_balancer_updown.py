# -*- coding: utf-8 -*-
"""Python wrappers for programmatically interacting with the `updown` utility.

`updown` interacts with the local healthcheck daemon, and allows a
service to intentionally remove instances of itself from the
load-balancer by causing healthchecks against those instances to always
fail.
"""

from yelp_lib.subprocesses import call_and_check


# Location of updown binaries.
UPDOWN = '/nail/sys/bin/updown'
UPDOWN_WATCH = '/nail/sys/bin/updown_watch'


def up(service, wait_time=None):
    """Enable load balancer healthchecks for a service. Also clear the
    service message.

    Args:
        service - The service's name in the load balancer
        wait_time - fail if the service is not active in the load balancer
            in this many seconds. If wait_time is None, then return immediately.
    Raises:
        CalledProcessError - if wait_time is set, and the the time limit expires
    """
    updown('up', service, wait_time=wait_time, message=None)


def down(service, wait_time=None, message="maintenance"):
    """Disable load balancer healthchecks for a service, and set a service
    message used by other monitoring tools (i.e. nagios).

    Args:
        service - The service's name in the load balancer
        wait_time - fail if the service is not removed from the load balancer
            in this many seconds. If wait_time is None, then return immediately.
        message - A service message used to signal planned outages.
    Raises:
        CalledProcessError - if wait_time is set, and the the time limit expires
    """
    updown('down', service, wait_time=wait_time, message=message)


def updown(up_or_down, service='all', wait_time=None, message=None):
    """Enable/disable load balancer healthchecks for a service, and set a
    message used by other monitoring tools (i.e. nagios). Uses the updown
    command provided by the systems team.

    Note that this doesn't interact with the load balancer state directly,
    instead it notifies the local healthcheck daemon to auto-fail healthchecks
    (down) or forward them to the service (up).

    Args:
        up_or_down - The action to take; 'up' or 'down'
        service - The service's name in the load balancer
        wait_time - fail if `service` has not been up/down-ed in this many
            seconds. If wait_time is None, then just return immediately.
        message - A service message used to signal planned outages.
    Raises:
        CalledProcessError - if wait_time is set, and the the time limit expires
    """
    if not up_or_down in ('up', 'down'):
        raise SyntaxError('updown only accepts "up" or "down" as its'
                          ' first argument')

    # Construct the command...
    cmd = ['sudo', UPDOWN, up_or_down, service]

    # (last argument is the down message)
    if message:
        cmd.append(message)

    call_and_check(cmd, error_msg='Failure when trying to %s %s' %
                   (up_or_down, service))

    # If wait_time is set, wait at most `wait_time` seconds for
    # the updown to take effect, and raise an exception if it fails
    if wait_time is not None:
        updown_watch(up_or_down, service, timeout=wait_time)


def updown_watch(up_or_down, service, hostname=None,
                 timeout=5*60, proxymonitor=None, debug=False):
    """Block for up to `timeout` seconds while waiting for `service` to come
    into/out of the load balancer.

    Args:
        up_or_down - 'up' or 'down'.  If 'up' ('down') wait for `service` to be
            added (removed) from the load balancer
        service - name of the service that we are monitoring in the
            load balancer
        hostname - the hostname of the service that we are monitoring in the
            load balancer
        timeout - maximum time to wait for the service to be up/down
        proxymonitor - the name of the load balancer that manages `service`
        debug - print debugging output
    Raises:
        CalledProcessError - if the timeout expires
    """
    # Base command
    cmd = [UPDOWN_WATCH]

    # Are we waiting for the process to go up or down?
    if up_or_down == 'up':
        cmd.append('-u')
    elif up_or_down == 'down':
        cmd.append('-d')
    else:
        raise SyntaxError('updown_watch only accepts "up" or "down" as its'
                          ' first argument')

    # What service name are we waiting on?
    if service:
        cmd.extend(['-s', service])

    # What host are we waiting on?  Defaults to host command is run on.
    if hostname is not None:
        cmd.extend(['-h', hostname])

    # Default timeout is 10 seconds, so we always override with a longer one
    cmd.extend(['-t', str(timeout)])

    # Which load balancer are we looking in (intlvs by default)
    if proxymonitor is not None:
        cmd.extend(['-p', proxymonitor])

    # Output debugging info?
    if debug:
        cmd.append('-x')

    call_and_check(cmd, error_msg='Failure when trying to %s %s' %
                  (up_or_down, service))
