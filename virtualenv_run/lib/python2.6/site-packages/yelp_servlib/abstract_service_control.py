# -*- coding: utf-8 -*-
"""
Abstract script that provides most of the common code
needed to control a service in a way that confirms to CEP45/48
(https://trac.yelpcorp.com/wiki/OverviewOfServiceDocs).

CEP45 requires that control scripts are executable, so all
non-abstract subclasses of AbstractServiceControl should
have the appropriate shebang and have their executable bit set.
"""

import errno
import fcntl
import functools
import logging
import os
import pipes
import re
import socket
import subprocess
import sys
import traceback
from optparse import OptionParser
from os import path

import yaml

from .load_balancer_updown import down
from .load_balancer_updown import up
from .service_utils import assert_user
from .service_utils import DEFAULT_CLOG_ARGS
from .service_utils import get_datacenter
from .service_utils import get_ecosystem
from .service_utils import get_runtimeenv
from .service_utils import get_topologyenv
from .service_utils import is_running
from .service_utils import pipe_to_scribe
from .service_utils import stop_pid
from .service_utils import tee_to_scribe
from yelp_lib.containers.dicts import get_deep_by_chain
from yelp_lib.containers.dicts import set_deep_by_chain
from yelp_lib.subprocesses import poll_for_a_period


YELP_ROOT = os.getenv('YELP_ROOT','/nail')
# Location where pidfiles are stored
RUNDIR = path.join(YELP_ROOT, 'run')
SRVDIR = path.join(YELP_ROOT, 'srv')
CONFIG_DIR = path.join(SRVDIR, 'configs')


class DoesntRunOnNodeException(Exception): pass


def configurable(*config_path):
    """Wrap `fcn`(self, ...) so that if self.config contains the deep key
    `config_path`, that will be returned, otherwise, `fcn`(self, ...)
    will be returned.

    Example:
        class A(namedtuple("A", "a b config")):
            @property
            @configurable("overrides", "a+b")
            def sum_ab(self):
                return self.a + self.b

        When the configuration doesn't contain the key 'sum_ab', the
        property function is executed:

            A(a=3, b=4, config={}).sum_ab   --> 7

        Otherwise, the configuration is read:

            A(a=3, b=4, config={'overrides': {'a+b': 21}}).sum_ab   --> 21
    """
    def inner(fcn):
        @functools.wraps(fcn)
        def wrapper(self, *argv, **kwargs):
            # Create a dummy token default value, which will indicate that
            # the deep key `config_path` is missing. We can't let None be
            # the default value, since `config` could contain the value
            # None. On the other hand, _do_execute is a unique object,
            # which `config` cannot contain.
            _do_execute = ('do execute',)
            config_get_val = get_deep_by_chain(self.config,
                chain=config_path,
                default=_do_execute)
            if config_get_val is _do_execute:
                return fcn(self, *argv, **kwargs)
            else:
                return config_get_val
        return wrapper
    return inner


class AbstractServiceControl(object):
    # List of valid actions the control script can take
    valid_commands = ('start', 'stop', 'restart', 'status',
        'run-as-user', 'run-on-node')

    def __init__(self):
        self.setup_logging()
        self.default_config_file = path.join(CONFIG_DIR,
                                             self.service_name + '.yaml')
        self.datacenter = get_datacenter()
        self.ecosystem = get_ecosystem()
        self.runtimeenv = get_runtimeenv()
        self.topologyenv = get_topologyenv()

    ### CUSTOMIZE THESE ###
    @property
    def service_name(self):
        """Name of your service. This should equal the dir that your service
        is installed into under /nail/srv"""
        raise NotImplementedError

    @property
    def service_cmd(self):
        """The [command, args...] to actually launch the service."""
        raise NotImplementedError

    @property
    def post_start_poll_period(self):
        """Number of seconds the service control script will poll the service
        pid after launching it, to check if it is still alive. This is to catch
        cases where the service crashes, or otherwise exits immediately after
        launch.

        The check time should be long enough for e.g. JVM startup, but not
        as long as expensive initialization (e.g. loading search indices).
        """
        return 5

    @property
    def load_balancer_name(self):
        """Name of your service in the load balancer"""
        return self.service_name.replace('_', '')

    @property
    def working_dir(self):
        """The directory the service will run from"""
        return os.path.realpath(self.config.get("working_dir",
            path.join(SRVDIR, self.service_name)))

    # Environment variables the service will run with
    env = {}

    ### Configurable properties ###
    @property
    @configurable("stop_wait_limit")
    def stop_wait_limit(self):
        """Number of seconds to wait for the service to stop before killing it"""
        return 10

    @property
    @configurable("updown_wait_limit")
    def updown_wait_limit(self):
        """Number of seconds to wait for the service to up or down in the loadbalancer"""
        return 60

    @property
    @configurable("pidfile")
    def pidfile(self):
        """Location of this service's pidfile"""
        return path.join(RUNDIR, self.service_name + '.pid')

    @property
    @configurable("pidfile_flock")
    def pidfile_flock(self):
        """True if fcntl locking support for pid files is enabled"""
        return False

    @property
    @configurable("user")
    def user(self):
        """The user this service should run as."""
        return 'batch'

    @property
    @configurable("scribe", "category")
    def scribe_category(self):
        """Scribe category to log to."""
        return self.service_name

    @property
    @configurable("scribe", "disable")
    def scribe_disable(self):
        """Set to True to turn off any scribe output. Named after the same
        variable in level.py"""
        return False

    @property
    @configurable("scribe", "clog_args")
    def scribe_clog_args(self):
        return DEFAULT_CLOG_ARGS

    ### Command line ###
    def define_command_line(self):
        usage = 'usage: %prog [options] (' + ' | '.join(self.valid_commands) + ')'
        self.option_parser = OptionParser(usage=usage)
        self.option_parser.add_option(
            '-c', '--config-file',
            metavar='CONFIG', default=self.default_config_file,
            help="Default: %default")
        self.option_parser.add_option(
            '--no-index-check', dest='check_index',
            default=True, action='store_false',
            help="Don't fail if the index is not present [default: %default]")
        self.option_parser.add_option(
            '--no-scribe', dest='output_to_scribe',
            default=True, action='store_false',
            help="Don't write service output to scribe")
        self.option_parser.add_option(
            '--config-override',
            default=[],
            action='append',
            help="Override configuration, using Yaml that's processed to "
            "turn colon-separated keys into nested keys, and '='s into "
            "': '. For example, --no-scribe is equivalent to passing "
            "--config-override 'scribe:\\n  disable: False', or "
            "--config-override 'scribe:disable: False', or "
            "--config-override scribe:disable=False.")
        self.option_parser.add_option(
            '--run-anyways',
            default=False, action='store_true',
            help="Run the service, even if it isn't set to run on this host")
        self.option_parser.add_option(
            '--disable-updown',
            default=False, action='store_true',
            help="Do not up or down the service in the load balancer")
        self.option_parser.add_option('--foreground', action='store_true',
            help="Run the process in the foreground. Omits any post-start actions.")

    def process_command_line(self, command_line_args=None):
        self.options, args = self.option_parser.parse_args(command_line_args)
        self.config = self.parse_config(self.options.config_file)

        for override in self.options.config_override:
            parsed = yaml.load(re.sub(r'^([\w:]*\w)=', r'\1: ', override))
            for k, v in parsed.iteritems():
                set_deep_by_chain(self.config,
                    chain=k.split(":"),
                    value=v)

        if len(args) < 1 or not args[0] in self.valid_commands:
            raise SyntaxError('Must specify one of %s as an action.' %
                              (self.valid_commands,))
        self.action = args[0]

        self.hostname_to_check = socket.gethostname()
        if self.action == 'run-on-node':
            if len(args) > 1:
                self.hostname_to_check = args[1]

    def parse_config(self, config_file):
        """Parse the service's config file and return it as a dict"""
        with open(config_file, 'r') as yaml_file:
            return yaml.safe_load(yaml_file) or {}

    ### Action handlers ###
    def start(self):
        self.pre_start()
        proc = self.start_service()
        self.post_start(proc)

    def stop(self):
        self.pre_stop()
        self.stop_service()
        self.post_stop()

    def restart(self):
        try:
            self.stop()
        except Exception as e:
            self.log.error('Exception while trying to stop %s: %s\n%s' % (
                self.service_name, e, traceback.format_exc()
            ))

        self.start()

    def status(self):
        return_code = self.service_status()
        print "running" if return_code == 0 else "not running"
        sys.exit(return_code)

    def run_as_user(self):
        # Ignored by run-serviceinit
        # CEP 48 has details on the new system to change the run-as user
        print self.user
        sys.exit(0) # CEP2 compliance

    def run_on_node(self):
        # Currently ignored by run-serviceinit
        if self.server_list is None or self.hostname_to_check in self.server_list:
            print self.hostname_to_check
            sys.exit(0)
        sys.exit(1) # CEP2 compliance

    ### Start ###
    def pre_start(self):
        """Hook to run actions before launching the process.
        Default actions are:
            Check we're the right user
            Check the index exists
            Check we're on an appropriate machine
            Check the service isn't already running
        """
        self.check_perms()
        # Check for the index
        if self.options.check_index:
            self.check_index()
        assert not self._is_running(self.pidfile), (
            '%s is already running!' % self.service_name)
        self.assert_run_on_node()
        # Ensure service is marked as down in loadbalancer before starting it
        if self.load_balanced:
            down(self.load_balancer_name, wait_time=self.updown_wait_limit)

    def start_service(self):
        self.log.info('Starting %s' % self.service_name)

        # Print out any environment variables, so one can run the command
        # manually if desired.
        changed_env_vars = {}
        for unset_key in set(os.environ).difference(self.env):
            changed_env_vars[unset_key] = ""
        for key, value in self.env.iteritems():
            if os.environ.get(key) != value:
                changed_env_vars[key] = value

        self.log.info('Running: ' +
            "".join("%s=%s " % (env_var, pipes.quote(env_value))
                for env_var, env_value in changed_env_vars.iteritems()) +
            " ".join(pipes.quote(arg) for arg in self.service_cmd))
        return self.launch_process(
            self.service_cmd, self.working_dir, self.env)

    def post_start(self, proc):
        """Hook to run actions after the process has started.
        Default actions are:
            Write the pidfile,
            Check that the process didn't crash as startup
            Setup a pipe to scribe (if enabled)
            Up the service in the load balancer (if enabled).
        """
        # Ensure the process stays alive for several seconds
        self._check_still_alive(proc)
        self.log.info('Started %s' % self.service_name)

        self.setup_scribe_logging(proc)

        # Warmup service
        self.warmup_service()

        # Up the service
        if self.load_balanced:
            # This assumes that your service is smart enough to fail
            # healthchecks until it is done starting and warming.
            up(self.load_balancer_name, wait_time=self.updown_wait_limit)

    def setup_scribe_logging(self, proc):
        # Pipe the process' output to scribe. This is done after
        # _check_still_alive(), because the preceding function gets first dibs
        # on proc.stdout
        if self.use_scribe:
            pipe_to_scribe(self.scribe_category,
                proc.stdout,
                clog_args=self.scribe_clog_args)


    def _check_still_alive(self, proc):
        """Poll for a period to see if server started okay"""
        returncode = poll_for_a_period(proc, self.post_start_poll_period)
        if returncode is not None:
            if self.use_scribe:
                # Normally, you would have to look in the scribe log to see WHY
                # a service crashed, but if this is being run interactively
                # then it will duplicate the output to stderr. (convenience++)
                output = tee_to_scribe(self.scribe_category,
                    proc.stdout,
                    clog_args=self.scribe_clog_args)
                if sys.stdout.isatty():
                    sys.stderr.write(output)
            raise RuntimeError('%s died with returncode %s' %
                               (self.service_name, returncode))

    ### Stop ###
    def pre_stop(self):
        """Down in the load balancer"""
        self.assert_run_on_node()
        if self.load_balanced:
            down(self.load_balancer_name, wait_time=self.updown_wait_limit)
        assert self._is_running(self.pidfile), (
            '%s is not running!' % self.service_name)

    def stop_service(self):
        self.log.info('Stopping %s' % self.service_name)
        try:
            with open(self.pidfile, 'r') as f:
                pid = int(f.read().strip())
        except IOError:
            # Since we check the pidfile in pre_start, this should only happen
            # as a race condition.
            self.log.warn("Couldn't read %s" % self.pidfile)
            return
        stop_pid(pid, self.stop_wait_limit)

    def post_stop(self):
        """Cleanup the pid file"""
        try:
            os.remove(self.pidfile)
        except OSError as e:
            # ENOENT: File does not exist
            if e.errno != errno.ENOENT:
                self.log.error(e)
        self.log.info('Stopped %s' % self.service_name)

    ### Status ###
    def service_status(self):
        if self._is_running(self.pidfile):
            return 0
        return 1

    ### Helper Functions ###
    def setup_logging(self):
        self.log = logging.getLogger('abstract_service_control')
        # Setup the everything to log to stdout with the date attached.
        root_log = logging.getLogger()
        console = logging.StreamHandler(sys.stdout)
        console.setFormatter(logging.Formatter('[%(asctime)s] %(message)s'))
        root_log.addHandler(console)
        root_log.setLevel(logging.INFO)

    @property
    def is_aws(self):
        return self.config.get('cluster', {}).get(self.datacenter, {}).get('is_aws')

    @property
    def server_list(self):
        """Return a set of hostnames that this service should run on."""
        assert not self.is_aws, "AWS doesn't have a server list."
        cluster = self.config.get('cluster')
        if cluster is None:
            return None
        for datacenter, conf in cluster.iteritems():
            if datacenter == self.datacenter:
                return conf['nodes']
        return []

    def assert_run_on_node(self):
        """Assert that we run on this node"""
        if not (self.is_aws or self.server_list is None or
                self.hostname_to_check in self.server_list or
                self.options.run_anyways):
            raise DoesntRunOnNodeException('{service_name} is not configured to '
                'run on {hostname_to_check}. Use --run-anyways, '
                'or run on one of: {server_list}'.format(
                    service_name=self.service_name,
                    hostname_to_check=self.hostname_to_check,
                    server_list=self.server_list))

    def check_index(self):
        """Raise an error if any required data files don't exist."""
        raise NotImplementedError

    def check_perms(self):
        """Enforces that only the run-as-user runs this service.

        We do not check user permissions on dev.
        """
        if self.runtimeenv == 'dev':
            return
        assert_user(self.user)

    def warmup_service(self):
        """Warmup the service"""
        pass

    def launch_process(self, cmd, cwd, env):
        """Given a command line and environment, launch the process."""
        if self.options.foreground:
            os.chdir(cwd)
            os.execvpe(cmd[0], cmd[1:], env)
            # execvpe replaces the current process, and does not return.
        elif self.options.output_to_scribe:
            if self.scribe_disable:
                stdout = open(os.devnull)
                stderr = open(os.devnull)
            else:
                stdout = subprocess.PIPE
                stderr = subprocess.STDOUT
        else:
            stdout = sys.stdout
            stderr = sys.stderr
        # Redirect std* ensures that other scripts can call this via ssh
        return subprocess.Popen(
            cmd, cwd=cwd, env=env, close_fds=True,
            preexec_fn=lambda: self._create_pid_file(self.pidfile, self.preexec_child_hook),
            stdin=open(os.devnull), stdout=stdout, stderr=stderr)

    def _create_pid_file(self, pid_path, preexec_fn=None):
        """Open and lock a PID file for the process"""

        # We need to make pid_fd global, otherwise it would get closed by the
        # Python GC before we exec the program we want to startup.
        global pid_fd

        if preexec_fn is not None:
            preexec_fn()

        # Just because we're able to open the file doesn't mean that no-one
        # else is using it. We thus need to open it in append mode and we also
        # need to grab the lock before we write any data.
        pid_fd = open(pid_path, 'a+')
        fcntl.flock(pid_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        pid_fd.seek(0)
        pid_fd.truncate()
        pid_fd.write('{0}\n'.format(os.getpid()))
        pid_fd.flush()

    def preexec_child_hook(self):
        """This runs on the child PID. You can do stuff like setting rlimits
        (e.g. virtual address size limits) here.
        """
        pass

    def _is_locked(self, pidfile):
        if not path.isfile(pidfile):
            return False

        with open(pidfile, 'a+') as fd:
            try:
                fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
            except IOError as e:
                if e.errno in (errno.EACCES, errno.EAGAIN):
                    return True
                else:
                    raise
            fcntl.flock(fd, fcntl.LOCK_UN | fcntl.LOCK_NB)

        return False

    def _is_running(self, pidfile):
        if self.pidfile_flock:
            return is_running(pidfile) and self._is_locked(pidfile)
        else:
            return is_running(pidfile)

    @property
    def load_balanced(self):
        """If true, the service will be upped and downed."""
        # Stage and dev don't have back-tier load balancers
        return (self.runtimeenv == 'prod' and
            (not self.is_aws) and
            not self.options.disable_updown)

    @property
    def use_scribe(self):
        """Convenience property to decide if the service output should
        be sent to scribe"""
        return self.options.output_to_scribe and not self.scribe_disable

    ### Main Entry Method ###
    def run(self, command_line_args=None):
        self.define_command_line()
        self.process_command_line(command_line_args=command_line_args)
        # Run the appropriate action handler
        try:
            getattr(self, self.action.replace('-','_'))()
        except DoesntRunOnNodeException as e:
            print >> sys.stderr, "ERROR: {0}".format(e)
            exit(0)
