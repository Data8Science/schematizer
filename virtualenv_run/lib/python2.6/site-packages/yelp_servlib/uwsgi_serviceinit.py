# -*- coding: utf-8 -*-
"""
Provides default actions for use with a uwsgi service. This module uses the
:mod:`yelp_servlib.serviceinitlib` system to build serviceinit scripts.


Customization
-------------

To customize one of the default actions, or add new actions, you can assign
to the mapping returned by :func:`get_default_uwsgi_actions`.

This is an example of customizing the start action by adding new arguments
to the argument builder.

.. code-block:: python

    from yelp_servlib import serviceinitlib, uwsgi_serviceinit

    def my_custom_arg_builder(config):
        # Add special args, or build different ones
        return uwsgi_serviceinit.build_start_uwsgi_args() + ['--mule']

    def my_custom_start_action(config):
        serviceinitlib.start(config, uwsgi_arg_builder=my_custom_arg_builder)


    if __name__ == "__main__":
        config = serviceinitlib.load_config(...)
        actions = uwsgi_serviceinit.get_default_uwsgi_actions()

        # Override the 'start' action with your new function
        actions['start'] = my_custom_start_action
        serviceinitlib.run(config, actions)

"""

import os
import time

from serviceinitlib import ArgListBuilder
from serviceinitlib import action_run_as_user
from serviceinitlib import action_status
from serviceinitlib import call
from serviceinitlib import get_pid_filename
from serviceinitlib import verify_port


def get_uwsgi_cmd(config):
    default = os.path.join(config.VIRTUALENV_PATH, 'bin/uwsgi')
    return config.get('UWSGI_CMD', default)


def get_num_workers(config, prod=True):
    if prod:
        return config.get('NUM_WORKERS', 4)
    return config.get('NUM_NON_PROD_WORKERS', 2)


class UWsgiArgumentFactory(object):

    def __init__(self, config, builder):
        self.config = config
        self.builder = builder

    def add_daemonize(self):
        # Daemonize
        self.builder.add('daemonize2', '/dev/null')
        self.builder.add('pidfile',    get_pid_filename(self.config))

    def add_prod_mode(self):
        # set to the sysctl value of net.core.somaxconn, see OPS-389
        with open('/proc/sys/net/core/somaxconn', 'r') as fh:
            self.builder.add('listen', fh.read().strip())

    def add_dev_mode(self):
        # Necessary for supporting ipdb.set_trace()
        self.builder.add('honour-stdin')
        self.builder.add('py-auto-reload', '1')

    def add_default_uwsgi(self, prod=True):
        config = self.config
        self.builder.add('master')
        self.builder.add('processes', get_num_workers(config, prod))
        self.builder.add('auto-procname')
        self.builder.add('procname-prefix-spaced', config.SERVICE)
        self.builder.add('virtualenv', config.VIRTUALENV_PATH)
        self.builder.add('wsgi-file', '%s.wsgi' % config.SERVICE)
        self.builder.add('callable=application')
        self.builder.add('need-app')
        self.builder.add('buffer-size', config.get('BUFFER_SIZE', '65535'))
        self.builder.add('http-manage-expect')
        # Re-resolve code and uwsgi path upon reload.  This is necessary
        # to correctly handle an altered service symlink.
        self.builder.add('chdir', config.BASEPATH)
        self.builder.add('binary-path', get_uwsgi_cmd(config))
        # Add keep-alive support. uWSGI is speaking http 1.1, so by the spec
        # we need to at least *support* keep alives even if our clients and/or
        # backends don't use it. See SI-627 for more info.
        self.builder.add('http-keepalive')
        # Used by uwsgi_metrics
        self.builder.add('mule')

    def add_ports(self):
        verify_port(self.config.PORT)
        verify_port(self.config.STATS_PORT)
        # Use "http" rather than "http-socket" to play nicer with AWS Elastic Load Balancers;
        # see INFRA-1406 for more info.
        self.builder.add('http', ':%s' % self.config.PORT)
        self.builder.add('stats', ':%s' % self.config.STATS_PORT)

    def as_list(self):
        return self.builder.as_list()


def build_start_uwsgi_args(config, daemonize=True):
    args = UWsgiArgumentFactory(config, ArgListBuilder())
    args.add_prod_mode()
    if daemonize:
        args.add_daemonize()
    args.add_default_uwsgi(prod=True)
    args.add_ports()
    return args.as_list()


def build_start_dev_uwsgi_args(config):
    args = UWsgiArgumentFactory(config, ArgListBuilder())
    args.add_dev_mode()
    args.add_default_uwsgi(prod=False)
    args.add_ports()
    return args.as_list()


def build_call_env(config, prod=True):
    def get_value(name, default):
        return name, config.get(name, default)

    def get_default_env_config_path():
        if prod:
            return '/nail/srv/configs/%s.yaml' % config.SERVICE
        return os.path.join(config.BASEPATH, 'config-env-dev.yaml')

    return dict(os.environ.items(), **dict([
        get_value('YELPCODE', config.BASEPATH),
        get_value('SERVICE_CONFIG_PATH',
                  os.path.join(config.BASEPATH, 'config.yaml')),
        get_value('SERVICE_ENV_CONFIG_PATH', get_default_env_config_path()),
    ]))


def pre_start_setup(config, basepath):
    config.set('BASEPATH', basepath)
    # Set virtualenv path relative to config.BASEPATH which might not be
    # basepath if it was already set in an environment
    config.set("VIRTUALENV_PATH",
               os.path.join(config.BASEPATH, 'virtualenv_run'))


def get_default_uwsgi_actions():
    """Returns the default set of actions for interacting with a uwsgi
    service.

    :returns: a dict of action name to function. Each function accepts a
        single argument of
        :class:`yelp_servlib.serviceinitlib.EnvironmentConfig`.
    """
    return {
        'run-as-user':      action_run_as_user,
        'status':           action_status,
        'start':            action_start,
        'start-no-daemon':  action_start_no_daemon,
        'start-dev':        action_start_dev,
        'stop':             action_stop,
        'reload':           action_reload,
        'restart':          action_restart,
    }


def action_start(config, uwsgi_arg_builder=build_start_uwsgi_args):
    """Start the service."""

    pre_start_setup(config, os.path.join("/nail/srv", config.SERVICE))

    print "Starting"
    call([
            "/sbin/start-stop-daemon", "-S",
            "-p", get_pid_filename(config),
            "-x", get_uwsgi_cmd(config),
            "--"
        ] + uwsgi_arg_builder(config),
        env=build_call_env(config))


def action_start_no_daemon(config, uwsgi_arg_builder=None):
    """Start the service without daemonzing. Use this target to run the
    service in a docker container.
    """
    def arg_builder(config):
        return build_start_uwsgi_args(config, daemonize=False)

    arg_builder = uwsgi_arg_builder or arg_builder
    return action_start(config, uwsgi_arg_builder=arg_builder)


def action_start_dev(config, uwsgi_arg_builder=build_start_dev_uwsgi_args):
    """Start the service in development mode."""

    pre_start_setup(config, os.getcwd())

    uwsgi_cmd = get_uwsgi_cmd(config)
    os.execve(uwsgi_cmd,
              [uwsgi_cmd] + uwsgi_arg_builder(config),
              build_call_env(config, prod=False))


def action_stop(config):
    """Stop the service."""
    config.set('BASEPATH', os.path.join("/nail/srv", config.SERVICE))

    print "Stopping",
    call([
            "/sbin/start-stop-daemon",
            "-p", get_pid_filename(config),
            "-K", "-R", "INT/10/KILL",
            "--oknodo"
        ])


def action_reload(config):
    """Reload the service."""
    pre_start_setup(config, os.path.join("/nail/srv", config.SERVICE))

    print "Reloading",
    call([
            get_uwsgi_cmd(config),
            "--reload",
            get_pid_filename(config),
        ])


def action_restart(config, sleep_seconds=1):
    """Restart the service."""
    try:
        config.actions['stop'](config)
    except SystemExit:
        pass
    time.sleep(sleep_seconds)
    config.actions['start'](config)
