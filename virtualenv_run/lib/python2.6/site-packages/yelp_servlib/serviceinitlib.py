# -*- coding: utf-8 -*-
"""
A module for creating a minimal serviceinit script.

Serviceinit scripts are often very similar and have the same function
(start, stop, and otherwise interact with a service daemon).  This module
provides tools to create a serviceinit script without having to reproduce
boilerplate or depend on external system files.

Serviceinit scripts are composed of `actions`. An action is a task which is
associated with a name (ex: start, stop, status, restart, etc). Each task tells
a service daemon to do something (ex: stop would stop the daemon). This module
allows you to create a serviceinit script in two stages.

Step 1 - Building a configuration
----------------------------------

A configuration is all of the values required to run an action. Common values
are port number (`PORT`), pid filename (`PID_FILENAME`), and service
name (`SERVICE`).

Defaults for configuration values can be hard-coded in your serviceinit script
but every configuration value can be overridden from the environment. To
hard-code a value, you would pass it to :func:`load_config` (see the example
below). Some built-in actions will also include default values which you
can also override from your serviceinit script or the environment.

Step 2 - Running the action
----------------------------

When you run a serviceinit script the first argument is the action name.

.. code-block:: sh

    # start is the action
    $ ./serviceinit.d/my_service start

:func:`run` handles parsing arguments and calling the function which is
associated with that action name. If your service uses a framework
or supervisor to daemonize (ex: uwsgi, supervisor) it is quite possible
that you can share implementations for most of these actions as a library.

Default Action Implementations
------------------------------

There is currently only one default action implementation for uwsgi.

See :mod:`yelp_servlib.uwsgi_serviceinit`


Examples
--------

Example serviceinit file using uwsgi_serviceinit:

.. code-block:: python

    from yelp_servlib import serviceinitlib, uwsgi_serviceinit

    if __name__ == "__main__":
        config = serviceinitlib.load_config(
            SERVICE='example_service',
            PORT=10000,
            STATS_PORT=10001,
            NUM_WORKERS=4)

        # To add or customize actions, modify the `actions` dict
        actions = uwsgi_serviceinit.get_default_uwsgi_actions()
        serviceinitlib.run(config, actions)

"""
import os
import subprocess
import sys


class PIDNotFoundError(Exception):
    """Raised when a service pid is not found, or the service process is not
    running.
    """


class EnvironmentConfig(object):
    """A container which exposes two :class:`dict` (values and defaults)
    as attributes. This container makes it easy to override values from
    different locations.

    Usage example:

    .. code-block:: python

        values = dict(PORT=14444, NAME='my_name')
        defaults = dict(BASEPATH='/nail/srv/my_name', PORT=177)
        config = EnvironmentConfig(defaults, values)

        # prints '/nail/srv/my_name'
        print config.BASEPATH
        print config.get('BASEPATH', '/new/path')

        # prints 14444 because we already set a value for it
        print config.set('PORT', 0)
        print config.PORT
    """

    def __init__(self, defaults, values):
        self.defaults = defaults
        self.values = values

    def __getattr__(self, name):
        try:
            value = self.values.get(name)
            return value if value is not None else self.defaults[name]
        except KeyError:
            raise AttributeError("Required value %s missing from config" % name)

    def get(self, name, default=None):
        return self.values.get(name, self.defaults.get(name, default))

    def set(self, name, value):
        self.defaults.setdefault(name, value)

    def items(self):
        return dict(self.defaults, **self.values).items()


def load_config(**config):
    """Return a configuration which has default values from the keyword
    arguments and overrides these defaults from environment variables
    (:class:`os.environ`).

    :param config: kwargs of configuration values
    :returns: an :class:`EnvironmentConfig` object populated from config
    """
    return EnvironmentConfig(config, os.environ)


def load_args(action_choices):
    if len(sys.argv) < 2:
        raise SystemExit("Required argument 'action' was missing")

    action = sys.argv[1]
    if action not in action_choices:
        raise SystemExit("Action must be one of %s" % ", ".join(action_choices))

    return action


def run(config, actions):
    """Run a function from the mapping of actions. The function is selected by
    matching `sys.arv[1]` with the key in the actions mapping.


    :param config: a :class:`EnvironmentConfig` object
    :param actions: a mapping of action name (string) to callable action. Each
        callable is a `func(config)` which accepts a single argument of
        :class:`EnvironmentConfig` and returns nothing.
    """
    action = load_args(actions.keys())
    config.set('actions', actions)
    actions[action](config)


def err(msg):
    print >>sys.stderr, msg
    sys.exit(-1)


def verify_port(port):
    if int(port) > 2**16:
        err("PORT %s is invalid" % port)


def print_okay(success):
    print "... [OK]" if success else "... [Failed]"


def get_run_as_user(config, default_path="/nail/etc/services/{0}/runas"):
    path = config.get('RUNAS_PATH', default_path.format(config.SERVICE))
    if os.path.exists(path):
        with open(path) as fh:
            return fh.read().strip()
    return "batch"


def get_pid_filename(config):
    return config.get('PIDFILE', "/nail/run/%s.pid" % config.SERVICE)


def get_service_pid(config):
    filename = get_pid_filename(config)
    if not os.path.exists(filename):
        raise PIDNotFoundError("PIDFILE %s not found" % filename)

    with open(filename) as fh:
        pid = int(fh.read().strip())

    try:
        os.kill(pid, 0)
    except OSError:
        raise PIDNotFoundError("Process %s not running" % pid)
    return pid


def call(*args, **kwargs):
    failure = subprocess.call(*args, **kwargs)
    print_okay(not failure)
    if failure:
        sys.exit(failure)


class ArgListBuilder(object):
    """Construct a list of arguments incrementally."""

    def __init__(self):
        self.args = []

    def add(self, arg, value=None):
        self.args.append('--%s' % arg)
        if value is not None:
            self.args.append(str(value))

    def as_list(self):
        return self.args


def action_run_as_user(config):
    """Print the user expected to run this service."""
    print config.get('RUNAS_USER', get_run_as_user(config))


def action_status(config):
    """Display current status of the service."""
    try:
        print "running (pid %s)" % get_service_pid(config)
    except PIDNotFoundError as e:
        print "not running (%s)" % str(e)
        sys.exit(1)
