# -*- coding: utf-8 -*-
"""
A collection of various functions for dealing with pids and piping their
output to scribe.
"""
import errno
import os
import pwd
import signal
import sys
import time
from subprocess import Popen
from subprocess import PIPE

from yelp_lib.platform import pid_exists


# Default number of seconds to wait between asking the service to stop and
# killing it
SIGTERM_MAX_WAIT = 15


# Commands for redirecting to scribe
CLOG = '/nail/sys/bin/stdin2scribe'
DEFAULT_CLOG_ARGS = ['--format', 'hdi']


def get_datacenter():
    """Return the current datacenter from a well-known system file"""
    with open('/nail/etc/datacenter', 'r') as f:
        return f.read().strip()


def get_runtimeenv():
    """Return the current runtime from a well-known system file"""
    with open('/nail/etc/runtimeenv', 'r') as f:
        return f.read().strip()


def get_topologyenv():
    """Return the current environment from a well-known system file"""
    with open('/nail/etc/topology_env', 'r') as f:
        return f.read().strip()


def get_ecosystem():
    """Return the current environment from a well-known system file"""
    with open('/nail/etc/ecosystem', 'r') as f:
        return f.read().strip()


def pipe_to_scribe(scribe_category, stream, clog_args=DEFAULT_CLOG_ARGS):
    """Direct a stream to write to scribe using stdin2scribe.

    You can give an arbitrary subprocess scribe logging by setting
    it's stdout to PIPE and then passing in its stdout as stream.

    Args:
        scribe_category - The name of the scribe log to write to
        stream - A file-like object or file descriptor
    Returns:
        the process handle of the stdin2scribe instance
    """
    return Popen([CLOG, scribe_category] + clog_args,
        stdin=stream,
        stdout=open(os.devnull),
        stderr=open(os.devnull),
        close_fds=True)

def grep_to_scribe(scribe_category, stream, regex, clog_args=DEFAULT_CLOG_ARGS):
    """Direct a stream to write to scribe using pipe_to_scribe(...)
    after running through 'grep <regex>'.

    Args:
        scribe_category - The name of the scribe log to write to
        stream - A file-like object or file descriptor
        regex - A string passed as the first and only argument to grep.
    Returns:
        the process handles: (grep instance, stdin2scribe instance)
    """
    grep = Popen(['grep', regex], stdin = stream, stdout = PIPE)
    stdin2scribe = pipe_to_scribe(scribe_category, grep.stdout, clog_args)
    return (grep, stdin2scribe)

def tee_to_scribe(scribe_category, stream, clog_args=DEFAULT_CLOG_ARGS):
    """Write the current contents of `stream` to scribe and also return
    the contents as a string.

    Note that this only captures the current contents; future writes to the
    stream will not be sent to scribe or reflected in the returned output.

    Args:
        scribe_category - The name of the scribe log to write to
        stream - A file-like object. It is assumed seek() is not supported.
    Returns:
        the current contents of stream as a string
    """
    # Consume to contents of the pipe (only works once)
    output = stream.read()
    # Because we consumed the input pipe, we need to make a new pipe
    # containing the output.
    read_half, write_half = os.pipe()
    with os.fdopen(write_half, 'w') as f:
        f.write(output)
    pipe_to_scribe(scribe_category, read_half, clog_args=clog_args)
    return output


def assert_user(user):
    """Assert that the current user is `user`."""
    # Don't use getpass.getuser() since it's too easy to trick
    uname, _, _, _, _, _, _ = pwd.getpwuid(os.getuid())
    assert uname == user, (
        'Execute as %(user)s (you are %(uname)s). You probably want'
        ' "sudo -u %(user)s %(prog)s"' %
        {'user': user, 'uname': uname, 'prog': sys.argv[0]})


def is_running(pidfile):
    """Check to see if the process with the given pidfile is running.

    Args:
        pidfile - A path to a file containing the pid at its head.
            Whitespace, commas, and other file contents are ignore
    """
    def parse_pid(file_contents):
        """Try to parse the PID file, and return a more semantic
        exception on failure.
        """
        try:
            return int(file_contents.split()[0].strip(','))
        except Exception as e: # In particular, IndexError
            raise ValueError("Couldn't interpret PID file contents; "
                "got exception %r" % (e,))

    try:
        with open(pidfile, 'r') as f:
            pid = parse_pid(f.read())
        return pid_exists(pid)
    except IOError:
        pass
    return False


def stop_pid(pid, timeout=SIGTERM_MAX_WAIT):
    """Stop a given pid. If the process doesn't respond to SIGTERM in a timely
    manner, then SIGKILL will be used.

    Args:
        pid - The integer id of the process
        timeout - number of seconds to wait for the service to shutdown before
            a SIGKILL will be sent.
    """
    def safe_kill(pid, signal_value):
        """Helper; signals a process,
        returns True if it doesn't exist anymore, False if it still does."""
        try:
            os.kill(pid, signal_value)
        except OSError as e:
            # "no such process", i.e., we already killed it:
            if e.errno == errno.ESRCH:
                return True
            else:
                raise
        return False

    pid = int(pid)
    for _ in xrange(timeout):
        process_gone = safe_kill(pid, signal.SIGTERM)
        if process_gone:
            return
        time.sleep(1)
    safe_kill(pid, signal.SIGKILL)
