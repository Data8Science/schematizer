"""The original Python implementation of geogrid.  Used for reference and
testing, and as a fallback when the C implementation isn't available (e.g.,
PyPy).
"""
from geogrid.geom import (LATITUDE_MAX, LATITUDE_MIN, LONGITUDE_MAX, LONGITUDE_MIN, LngLatBounds, MILES_PER_LATITUDE, great_circle_dist_miles, miles_per_longitude)


"""
Earth
  .-----.
 /#*    *\
|##^*  ***|
 \##*   */
  ^-----^

 Quad

 +---+
 |   |
 |   |
 +---+

Yelp Grid Quads (aka geoquads) are an attempt to map 2d world coordinates onto a discrete set
of locations.  The grid quads are GeoGrid.GEOGRID_STEP wide and tall in longitude and
latitude units.
"""
def interleave32(a, b):
    """Interleave two 16 bit numbers into a 32 bit number"""
    assert a & 0xffff == a
    assert b & 0xffff == b

    r = 0
    i = 0
    high = 1 << 15
    while i < 16:
        r <<= 1
        r |= (a & high) >> 15
        a <<= 1
        r <<= 1
        r |= (b & high) >> 15
        b <<= 1
        i += 1
    return r

def deinterleave32(r):
    """Deinterleave one 32 bit number into two 16 bit numbers"""
    assert r & 0xffffffff == r
    a = 0
    b = 0
    i = 0
    high = 1 << 31
    while i < 16:
        a <<= 1
        a |= (r & high) >> 31
        b <<= 1
        r <<= 1
        b |= (r & high) >> 31
        r <<= 1
        i += 1
    return a, b

class GeoGrid(object):
    """The GeoGrid is the set of all quads on the Earth.  Each geocode maps to
    one quad, and each quad maps to the extent of a set of geocodes.
    """
    # This is the quad size in longitude/latitude units
    GEOGRID_STEP = 0.05

    @classmethod
    def quad(cls, longitude, latitude):
        """Convert a point to a quad identifier"""
        try:
            longitude = float(longitude)
        except TypeError:
            raise ValueError("Invalid longitude type")
        try:
            latitude = float(latitude)
        except TypeError:
            raise ValueError("Invalid latitude type")

        if longitude < LONGITUDE_MIN or longitude > LONGITUDE_MAX:
            raise ValueError("Invalid longitude: %(longitude)r" % vars())

        if latitude < LATITUDE_MIN or latitude > LATITUDE_MAX:
            raise ValueError("Invalid latitude: %(latitude)r" % vars())

        quad_i = int((longitude - LONGITUDE_MIN) / cls.GEOGRID_STEP)
        quad_j = int((latitude - LATITUDE_MIN) / cls.GEOGRID_STEP)
        # interleave i and j
        return interleave32(quad_i, quad_j)

    @classmethod
    def _make_range(cls, lo, hi):
        """
        lo and hi are both longitudes or both latitudes.
        returns a list of values that increment in GEOGRID_STEP such that:
         - all values in the returned list are centers of our GeoGrid divisions
         - no values repeat
         - returned_list[0] may be lower than lo and returend_list[-1] may be higher than hi.
           (for example if lo is just smaller than a GeoGrid division boundary, returned_list[0] < lo)

        geoquad
        centers              v(0.025)        v(0.075)        v(0.125)        v(0.175)        v(0.225)
                   --|---------------|---------------|---------------|---------------|---------------|--
        geoquad      0.0             0.05            0.10            0.15            0.20            0.25
        boundiaries

        In the diagram above,
         - if 'lo' is 0.0001 or 0.0499, returned_list[0] is 0.025.
         - if 'hi' is 0.2001 or 0.2499, returned_list[-1] is 0.225
        """
        if lo > hi:
            raise ValueError("this case not implemented. where are you, Semisopochnol Island, or somewhere in the reka Tyngekveem?")
        imaginary_lo = int(round((lo - (lo % cls.GEOGRID_STEP)) / cls.GEOGRID_STEP))
        imaginary_hi = int(round((hi - (hi % cls.GEOGRID_STEP)) / cls.GEOGRID_STEP))
        return [(float(x) + 0.5) * cls.GEOGRID_STEP for x in range(imaginary_lo, imaginary_hi + 1)]

    @classmethod
    def quad_safe(cls, longitude, latitude):
        """Like quad() but returns None instead of a ValueError"""
        try:
            return cls.quad(longitude, latitude)
        except ValueError:
            return None

    @classmethod
    def center(cls, quad):
        """Get the center point from a quad id
        Args:
            quad: int, a quad identifier
        Returns:
            (float: longitude, float: latitude)
        """
        quad_i, quad_j = deinterleave32(quad)
        lng_sw = float(quad_i) * cls.GEOGRID_STEP + LONGITUDE_MIN
        lat_sw = float(quad_j) * cls.GEOGRID_STEP + LATITUDE_MIN
        return lng_sw + (cls.GEOGRID_STEP / 2.0), lat_sw + (cls.GEOGRID_STEP / 2.0)

    @classmethod
    def distance_to_point(cls, quad, point):
        """finds the closest distance from the given point to any point in the quad."""

        # find the center lat/long for the quad.
        quad_lng, quad_lat = cls.center(quad)
        return cls._distance_from_quad_center_to_point((quad_lng, quad_lat), point)

    @classmethod
    def _distance_from_quad_center_to_point(cls, quad_center, point):
        """finds the closest distance from a quad with the given quad center to the point.
        Take a look at the classmethod 'nearby' to see a visual description of one sample usage."""

        quad_lng, quad_lat = quad_center
        point_lng, point_lat = point

        # find the lat/long in quad that is closest to the center of the circle.
        closest_lat = None
        closest_lng = None
        if abs(point_lat - quad_lat) < cls.GEOGRID_STEP/2.0:
            # quad is on the same latitude strip (a horizontal strip) as the center
            closest_lat = point_lat
        elif point_lat < quad_lat:
            # quad is north of the center
            closest_lat = quad_lat - cls.GEOGRID_STEP/2.0
        else:
            closest_lat = quad_lat + cls.GEOGRID_STEP/2.0

        if abs(point_lng - quad_lng) < cls.GEOGRID_STEP/2.0:
            # quad is on the same longitude strip (a vertical strip) as the center
            closest_lng = point_lng
        elif point_lng < quad_lng:
            # quad is east of the center
            closest_lng = quad_lng - cls.GEOGRID_STEP/2.0
        else:
            closest_lng = quad_lng + cls.GEOGRID_STEP/2.0

        return great_circle_dist_miles(point, (closest_lng, closest_lat))

    @classmethod
    def extent(cls, quad):
        """Get an extent from a quad.
        Args:
            quad -- int, the quad #
        Returns:
            a LngLatBounds, the extent of the quad (this should be roughly GEOGRID_STEP
            big)
        """
        lng, lat = cls.center(quad)
        sw_lng = lng - cls.GEOGRID_STEP / 2.0
        sw_lat = lat - cls.GEOGRID_STEP / 2.0
        ne_lng = lng + cls.GEOGRID_STEP / 2.0
        ne_lat = lat + cls.GEOGRID_STEP / 2.0
        return LngLatBounds(sw_lng, sw_lat, ne_lng, ne_lat)

    @classmethod
    def in_extent(cls, bounds):
        """Get a set of quads which overlap the given extent."""
        # step thru and add every quad in the range.
        n, e, s, w = bounds.nesw
        lon_range = cls._make_range(w, e)
        lat_range = cls._make_range(s, n)

        quads = set()
        for lon in lon_range:
            for lat in lat_range:
                quads.add(cls.quad(lon, lat))

        return quads

    @classmethod
    def nearby(cls, point, radius, large_radius=False):
        """Get a list of nearby quads inside of a circle at longitude, latitude within
        radius.  This uses an approximation to find an extent of quads to search
        for, and then filters that set using great circle distance.

        If either longitude or latitude is None, returns []

        Args:
            point: geocode,
            large_radius: if True, allow radii > 100.0
        Returns:
            [int: quad #]


        The algorithm works as follows: First we get all the geoquads that intersect the rectangle that
        fits snug around the circle. Then, for each geoquad in that set we find the closest point in the quad's extent
        to the center point of the circle. If this distance is less than radius, it is included in the returned list.

        * marks the point in the geoquad that is closest to the circle.

          |         |         |         |
        --+---------+---------+---------+--
          |         |         |         |
          |        _|_...___  |         |
          |      / *|  *     \|*        |
        --+-----/---+---------\---------+--
          |    |    |         ||        |
          |    |   *|  *      |*        |   }- quads in the same latitude-strip as the circle center point (closest point has non-boundary latitude)
          |    |    |         ||        |
        --+-----\---+---------/---------+--
          |      \_*|__*_____/|*        |
          |         |         |         |
          |         |         |         |
        --+---------+---------+---------+--
          |         |         |         |
                       \__/
                        quads in the same longitude-strip as the circle center point (closest point has non-boundary longitude)
        """
        radius = float(radius)
        mid_lng, mid_lat = point

        if mid_lng is None or mid_lat is None:
            return []

        # We can only accurately calculate longitude radii for spans less than 100mi
        if not (0 <= radius <= 100.0 or large_radius):
            raise ValueError("The radius should be between 0 and 100.0 miles")

        # Convert the radius into longitudes/latitudes
        radius_ns = radius / MILES_PER_LATITUDE
        radius_ew = radius / miles_per_longitude(mid_lat)

        # Get range of quad center lat/longs in rectangle that circumscribes given circle.
        quad_lats = cls._make_range(mid_lat - radius_ns, mid_lat + radius_ns)
        quad_lngs = cls._make_range(mid_lng - radius_ew, mid_lng + radius_ew)

        quads = set()
        # iterate over all quad centers in circumscribing rectangle.
        for quad_lat in quad_lats:
            for quad_lng in quad_lngs:
                quad_to_point_distance = cls._distance_from_quad_center_to_point((quad_lng, quad_lat), point)
                if quad_to_point_distance <= radius:
                    quads.add(cls.quad(quad_lng, quad_lat))

        return quads

def geogrid_for_size(step_size):
    """Get a geogrid with steps of size step_size"""
    return type('GeoGrid%03d' % int(step_size * 1000), (GeoGrid, ), {'GEOGRID_STEP': step_size})

