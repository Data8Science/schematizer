import math
import hashlib

METERS_TO_MILES = 0.000621371192
MILES_TO_METERS = 1609.344

LONGITUDE_MIN = -180.0
LONGITUDE_MAX = 180.0

LATITUDE_MIN = -90.0
LATITUDE_MAX = 90.0

# inspired by the following C code, found at http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
#
# int pnpoly(int npol, float *xp, float *yp, float x, float y)
# {
#   int i, j, c = 0;
#   for (i = 0, j = npol-1; i < npol; j = i++) {
#     if ((((yp[i]<=y) && (y<yp[j])) ||
#          ((yp[j]<=y) && (y<yp[i]))) &&
#         (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))
#
#       c = !c;
#   }
#   return c;
# }
def point_in_polygon(point, poly):
    '''Determine whether or not a point is inside a polygon, in 2d.

    The polygon does not need to be convex.
    The point should be an (x,y) tuple, and the polygon should be a sequence of (x,y) points.
    '''
    inside = False

    # iterate over each consecutive pair of polygon vertices (wrapping around)
    x, y = point
    xpj, ypj = poly[-1]
    for xpi, ypi in poly:
        if ((((ypi <= y) and (y < ypj)) or ((ypj <= y) and (y < ypi))) and (x < (xpj - xpi) * (y - ypi) / (ypj - ypi) + xpi)):
            inside = not inside
        xpj = xpi
        ypj = ypi

    return inside

# shamelessly stolen from lucy which was shamelessly stolen from somewhere else.
def great_circle_dist_kms(point1, point2):
    long1, lat1 = point1
    long2, lat2 = point2

    # radius of the earth in kilometers
    R = 6371.0
    long1 = long1 * math.pi / 180.0
    lat1 = lat1 * math.pi / 180.0
    long2 = long2 * math.pi / 180.0
    lat2 = lat2 * math.pi / 180.0

    dlong = long2 - long1
    dlat = lat2 - lat1

    shlat = math.sin(dlat / 2.0)
    shlong = math.sin(dlong / 2.0)

    f1 = (shlat * shlat + math.cos(lat1) * math.cos(lat2) * shlong * shlong)
    f2 = (2.0 * math.asin(min(1.0, math.sqrt(f1))))

    km = R * f2
    return km

def _great_circle_dist_miles(point1, point2):
    return (great_circle_dist_kms(point1, point2)/1.6093)

def find_extremas(points):
    "get extrema of n arbitrary dimension points"
    maxs = {}
    mins = {}
    for p in points:
        for dim, v in enumerate(p):
            if dim not in maxs: maxs[dim] = v
            elif maxs[dim] <= v: maxs[dim] = v

            if dim not in mins: mins[dim] = v
            elif mins[dim] >= v: mins[dim] = v

    return mins, maxs



def polygon_bounding_circle(points, center):
    "return radius of the smallest circle centered at center and fully surrounding the polygon formed by points"
    radius = 0
    for point in points:
        dist = great_circle_dist_miles(point, center)
        if dist > radius: radius = dist

    return radius

def haversine(theta):
    return math.sin(theta * 0.5) ** 2

def geopoint_and_radius_to_geobox(lon, lat, radius, scale_by_lat=False):
    """ Forms a box centered on the given point (lon, lat) with a "radius" (height/2) of radius miles.

    If scale_by_lat is True we take into account the differing lengths of one degree longitude at different latitudes,
    forming a box that is (much closer to) truly square.
    """
    # Radius of the earth in miles: 3963.1676 miles
    # Radius of the earth in meters: 6378100 m
    longitude = 69.16022727272727
    latitude = 68.70795454545454
    rx = radius / longitude
    ry = radius / latitude
    if scale_by_lat:
        rx /= (math.cos(lat * math.pi / 180.0) or 0.00001)

    return {'max_longitude': lon+rx, 'min_longitude': lon-rx, 'max_latitude': lat+ry ,'min_latitude': lat-ry}

def points_to_box2d(points):
    assert len(points)>1
    mn, mx = find_extremas(points)

    return {'max_longitude': float(mx[0]),
        'max_latitude': float(mx[1]),
        'min_longitude': float(mn[0]),
        'min_latitude': float(mn[1]),}

class LngLat(object):

    def __init__(self, lng, lat):
        if lng is None or lat is None:
            raise ValueError("Lng and Lat should not be None")
        lat = float(lat)
        lng = float(lng)

        lat = clamp(lat,-90.0,90.0)
        lng = unperiodize(lng,-180.0,180.0)
        if not (-180.0 <= lng <= 180.0): raise ValueError("Longitude should be between -180.0 and 180.0 (degrees): %r" % (lng, ))
        if not (-90.0 <= lat <= 90.0): raise ValueError("Latitude should be between -90.0 and 90.0 (degrees): %r" % (lat, ))
        self.__lng = lng
        self.__lat = lat

    @classmethod
    def from_geocode(cls, geocode):
        """Create a LngLat instance from a geocode dictionary"""
        return LngLat(geocode['longitude'], geocode['latitude'])

    def lng(self): return self.__lng

    def lat(self): return self.__lat

    def lnglat(self): return self.__lng, self.__lat

    def __repr__(self):
        return "%s(%r, %r)" % (self.__class__.__name__, self.__lng, self.__lat)

    def approx_equals(self, point):
        if not isinstance(point, LngLat):
            raise ValueError("i don't know how to compare %r for equality." % (point.__class__, ))
        return abs(self.lng() - point.lng()) > 0.00001 and abs(self.lat() - point.lat()) > 0.00001

    def great_circle_dist_miles(self, p):
        return great_circle_dist_miles((self.lng(), self.lat()), (p.lng(), p.lat()))

    def gte(self, p, tolerance=.001):
        """Tests if this point is gte than another (i.e., both coords are gte).
            Args:
            p - the other long/lat point
            tolerance - distances of less than this are considered 0
        """
        xa,xb,ya,yb = self.lng(), p.lng(), self.lat(), p.lat()
        if (xa>=xb or abs(xa-xb)<=tolerance) and (ya>=yb or abs(ya-yb)<=tolerance):
            return True
        return False

    def lte(self, p, tolerance=.001):
        """Tests if this point is lte than another (i.e., both coords are lte).
            Args:
            p - the other long/lat point
            tolerance - distances of less than this are considered 0
        """
        xa,xb,ya,yb = self.lng(), p.lng(), self.lat(), p.lat()
        if (xa<=xb or abs(xa-xb)<=tolerance) and (ya<=yb or abs(ya-yb)<=tolerance):
            return True
        return False

    def bounds_by_radius(self, radius, scale_by_lat=False):
        """Returns LngLatBounds for radius (miles)."""
        longitude = 69.16022727272727
        latitude = 68.70795454545454
        radius = float(radius)
        rx = radius / longitude
        ry = radius / latitude
        if scale_by_lat:
            ry /= (math.cos(self.lat() * math.pi / 180.0) or 0.00001)

        return LngLatBounds(self.lng() - rx, self.lat() - ry,
                self.lng() + rx, self.lat() + ry)

    def __iter__(self):
        return iter((self.__lng, self.__lat))

    def __eq__(self, other):
        if hasattr(other, 'lng') and hasattr(other, 'lat'):
            return (self.lng(), self.lat()) == (other.lng(), other.lat())
        else:
            return False

def mid(geobox):
    """We have lots of different types of geoboxes at various places in the code.
    This will get you the central point for any of them.
    """
    if not isinstance(geobox, (LngLatBounds, dict)):
        raise TypeError("Don't know how to interpret a %s as a geobox: %s" % (type(geobox), geobox))
    if isinstance(geobox, LngLatBounds):
        lnglat = geobox.mid()
    else:
        if 'center' in geobox:
            lnglat = LngLat.from_geocode(geobox['center'])
        elif all(((k in geobox) for k in ('min_longitude', 'min_latitude', 'max_longitude', 'max_latitude'))):
            lnglat = LngLatBounds.from_geobox(geobox).mid()
        else:
            raise ValueError("Could not decipher a central LngLat from geobox: %s" % geobox)
    return lnglat

class LngLatBounds(object):
    """Also known as a GeoBox which is used for the maps interface.

    This class is useful for keeping track of, generating, or manipulating a geographical
    extent.

    Arguments:
        lnga: float, the west longitude
        lata: float, the south latitude
        lngb: float, the east longitude
        latb: float, the north latitude
    """
    def __init__(self, lnga, lata, lngb, latb):
        lnga = float(lnga)
        lngb = float(lngb)
        lata = float(lata)
        latb = float(latb)
        self.__a = LngLat(min(lnga, lngb), min(lata, latb))
        self.__b = LngLat(max(lnga, lngb), max(lata, latb))

    def __repr__(self):
        return "LngLatBounds(%r,%r,%r,%r)" % (self.__a.lng(), self.__a.lat(), self.__b.lng(), self.__b.lat())

    def points(self):
        x1,y1,x2,y2 = self.__a.lng(), self.__a.lat(), self.__b.lng(), self.__b.lat()
        return LngLat(x1,y1), LngLat(x1, y2), LngLat(x2, y2), LngLat(x2, y1)

    def span(self):
        """Return a tuple of width, height (in degrees)"""
        return (abs(self.__a.lng() - self.__b.lng()), abs(self.__b.lat() - self.__a.lat()))

    def span_miles(self):
        longitude_miles = 69.16022727272727
        latitude_miles = 68.70795454545454
        return abs(self.__a.lng() - self.__b.lng()) * longitude_miles, abs(self.__b.lat() - self.__a.lat()) * latitude_miles

    def radius_miles(self):
        return great_circle_dist_miles((self.__a.lng(), self.__a.lat()), (self.__b.lng(), self.__b.lat())) / 2

    def inscribed_circle_radius_miles(self):
        """Use this to calculate the radius of the inscribed circle of
        the geobox
        """
        middle_long = (self.__a.lng() + self.__b.lng()) / 2
        middle_lat = (self.__a.lat() + self.__b.lat()) / 2

        return great_circle_dist_miles((middle_long, self.__a.lat()), (middle_long, self.__b.lat())) / 4 + \
            great_circle_dist_miles((self.__a.lng(), middle_lat), (self.__b.lng(), middle_lat)) / 4


    def mid(self):
        #FIXME: make this handle wrap around
        return LngLat((self.__a.lng() + self.__b.lng()) / 2.0, (self.__b.lat() + self.__a.lat()) / 2.0)

    def scale(self, n):
        """n is the multiplier we should expand by. """
        # find the dimensions
        n = float(n)
        w = abs(self.__b.lng() - self.__a.lng()) / 2.0
        h = abs(self.__b.lat() - self.__a.lat()) / 2.0
        w *= n
        h *= n
        mid = self.mid()
        lng, lat = mid.lng(), mid.lat()
        return LngLatBounds(lng - w, lat - h, lng + w, lat + h)

    def to_oldstyle_dict(self):
        x = {}
        x['min_longitude'], x['min_latitude'] = self.__a.lnglat()
        x['max_longitude'], x['max_latitude'] = self.__b.lnglat()
        x['center'] = {}
        x['center']['longitude'], x['center']['latitude'] = self.mid().lnglat()
        return x

    def sw(self): return self.__a
    def ne(self): return self.__b

    # @self is allowed to be outside of @bounds by a distance of at most @tolerance
    def inside_or_equals(self, bounds, tolerance=None):
        if self.sw().gte(bounds.sw(), tolerance) and self.sw().lte(bounds.ne(), tolerance) and self.ne().lte(bounds.ne(), tolerance) and self.ne().gte(bounds.sw(), tolerance):
            return True
        return False

    def size_sq_miles(self):
        # The 69.1 here is the number of miles between degrees of
        # longtiude. This number is relatively stable (varies by only 0.1%
        # or so at any longitude). The miles_per_longitude function
        # computes the width of a longitude based on the average latitude
        # of the box.
        SQ_MILES_PER_LAT_LONG = 69.16022727272727 * (miles_per_longitude((self.__a.lat() + self.__b.lat()) / 2.0))
        long_span, lat_span = self.span()

        return long_span * lat_span * SQ_MILES_PER_LAT_LONG

    @classmethod
    def from_points(self, a, b):
        return self(a.lng(), a.lat(), b.lng(), b.lat())

    @classmethod
    def from_poly(self, points):
        maxx,maxy = None, None
        minx,miny = None, None

        for (x,y) in points:
            if minx == None:
                minx = x
            else:
                minx = min(x, minx)

            if miny == None:
                miny = y
            else:
                miny = min(miny, y)

            if maxx == None:
                maxx = x
            else:
                maxx = max(x, maxx)

            if maxy == None:
                maxy = y
            else:
                maxy = max(y, maxy)

        return self(minx, miny, maxx, maxy)

    @classmethod
    def from_geoms(self, geoms):
        """Given a list of LngLat, LngLatBound, and/or None
        values, return a box which contains all of these,
        or None if there are no non-None values."""
        points = []

        for geom in geoms:
            if geom is None:
                continue

            if isinstance(geom, LngLat):
                points.append(geom)
            elif isinstance(geom, LngLatBounds):
                points.append(geom.sw())
                points.append(geom.ne())
            else:
                raise TypeError("Expected None, LngLat, or LngLatBounds: %r" % (geom,))

        if not points:
            return None

        return self.from_poly(p.lnglat() for p in points)

    @classmethod
    def from_geobox(self, geobox):
        """ convenience method for getting a LngLatBounds object from a geobox dict """
        try:
            return LngLatBounds(geobox['min_longitude'], geobox['min_latitude'], geobox['max_longitude'], geobox['max_latitude'])
        except (ValueError, TypeError, KeyError):
            return None

    @classmethod
    def from_center_and_radius(cls, center, radius, scale_by_lat=False):
        """
        center: (lng, lat) tuple
        radius: miles
        returns: a LngLatBounds geobox
        """
        lng, lat = center
        return LngLat(lng, lat).bounds_by_radius(radius, scale_by_lat)

    def to_url_param(self):
        return ','.join((','.join(map(str, self.sw().lnglat())), ','.join(map(str, self.ne().lnglat()))))

    @classmethod
    def from_url_param(cls, param):
        sw_lng, sw_lat, ne_lng, ne_lat = param.split(',')
        return LngLatBounds(sw_lng, sw_lat, ne_lng, ne_lat)

    def to_json_param(self):
        sw = self.sw()
        ne = self.ne()
        return [sw.lng(), sw.lat(), ne.lng(), ne.lat()]

    def intersects(self, bounds):
        if bounds is None:
            return False
        # Handle old-style and new-style geoboxes
        if not isinstance(bounds, (LngLatBounds, dict)):
            raise TypeError("Only know how to intersect LngLatBounds and geobox dicts")
        if isinstance(bounds, dict) :
            if all(((k in bounds) for k in ('min_longitude', 'min_latitude', 'max_longitude', 'max_latitude'))):
                bounds = LngLatBounds.from_geobox(bounds)
            else:
                raise ValueError("Could not decipher the bounds from geobox: %s" % bounds)

        for p in self.points():
            if bounds.contains_point(p): return True
        for p in bounds.points():
            if self.contains_point(p): return True
        return False

    def intersects_polygon(self, points):
        """Determine if the polygon represented by `points` intersects this GeoBox.
        This is only an approximation.  It checks if any of the points in the polygon
        are contained within the box, or if any of the points in the box are within
        the polygon.

        It is possible for this function to return a False negative if the polygon
        passed through the geobox, but the polygon is narrow enough to not have any
        points in box itself. In practice this should only be used with large polygons
        which do not have any narrow corners.  It will never return False positives.
        """
        for (lng, lat) in points:
            if self.contains_point(LngLat(lng, lat)):
                return True

        for corner in self.points():
            if point_in_polygon(corner, points):
                return True
        return False

    @classmethod
    def _range_intersection(cls, x1, x2, y1, y2):
        """Compute the intersection of the ranges [x1, x2] and [y1, y2].

        That is, the pair (z1, z2) such that
        (i) z1 the minimal value that is a member of both [x1, x2] and [y1, y2], and
        (ii) z2 is the maximal value the is a member of both [x1, x2] and [y1, y2].
        If no such pair exists (because the ranges do not overlap) then we return None.

        Args:
            - x1: The lower bound of the first range
            - x2: The upper bound of the first range
            - y1: The lower bound of the second range
            - y2: The upper bound of the second range
        Returns:
            A pair denoting the intersection of the two ranges, or None if the ranges do
            not overlap.
        """
        assert(x1 <= x2)
        assert(y1 <= y2)

        # By the interval trichotomy, there are four cases to consider
        if x1 <= y1 and y1 <= x2:
            return (y1, min(x2, y2))
        elif x1 <= y2 and y2 <= x2:
            return (max(x1, y1), y2)
        elif y1 <= x1 and x2 <= y2:
            return (x1, x2)
        else:
            return None

    @classmethod
    def _range_union(cls, x1, x2, y1, y2):
        """Compute the union of the ranges [x1, x2] and [y1, y2].

        That is, the pair (z1, z2) such that
        (i) z1 is the minimal value that is a member of [x1, x2] or [y1, y2], and
        (ii) z2 is the maximal value that is a member of [x1, x2] or [y1, y2].

        Args:
            - x1: The lower bound of the first range
            - x2: The upper bound of the first range
            - y1: The lower bound of the second range
            - y2: The upper bound of the second range
        Returns:
            A pair denoting the union of the two ranges.
        """
        assert(x1 <= x2)
        assert(y1 <= y2)

        return (min(x1, y1), max(x2, y2))

    def intersection(self, other):
        """Compute the geometric intersection with another geobox.

        We return the maximal geobox that contains only area that is common to this
        geobox and the argument geobox, or None if there is no overlap.

        Args:
            - other: A LngLatBounds object to compute the intersection with.
        Returns:
            A LngLatBounds object representing the intersection of this geobox with the argument
            geobox,	or None if there is no overlap.
        """
        lng_min_max = self._range_intersection(self.__a.lng(), self.__b.lng(), other.__a.lng(), other.__b.lng())
        lat_min_max = self._range_intersection(self.__a.lat(), self.__b.lat(), other.__a.lat(), other.__b.lat())
        if lng_min_max is not None and lat_min_max is not None:
            lng_min, lng_max = lng_min_max
            lat_min, lat_max = lat_min_max
            return LngLatBounds(lng_min, lat_min, lng_max, lat_max)
        else:
            return None

    def union(self, other):
        """Compute the geometric union with another geobox.

        We return the minimal geobox that fully contains both this geobox and the argument geobox.

        Args:
            - other: A LngLatBounds object to compute the union with.
        Returns:
            A LngLatBounds object representing the union of this geobox with the argument geobox.
        """
        lng_min, lng_max = self._range_union(self.__a.lng(), self.__b.lng(), other.__a.lng(), other.__b.lng())
        lat_min, lat_max = self._range_union(self.__a.lat(), self.__b.lat(), other.__a.lat(), other.__b.lat())
        return LngLatBounds(lng_min, lat_min, lng_max, lat_max)

    def area_square_miles(self):
        """Compute the area of this geobox in square miles.

        Returns:
            The area of this geobox in square miles.
        """
        lng_miles, lat_miles = self.span_miles()
        return lng_miles * lat_miles

    def __contains__(self, other):
        """Test whether this bounds contains a point or another bounds."""
        if isinstance(other, LngLatBounds):
            return other.inside_or_equals(self)
        elif isinstance(other, (tuple, LngLat)):
            return self.contains_point(other)
        else:
            return NotImplemented

    def contains_point(self, lnglat):
        # Handle (lng, lat) tuples
        if isinstance(lnglat, tuple):
            lnglat = LngLat(lnglat[0], lnglat[1])
        ne, sw = self.ne(), self.sw()
        return (sw.lng() <= lnglat.lng() <= ne.lng()) and (sw.lat() <= lnglat.lat() <= ne.lat())

    @property
    def nesw(self):
        north = max(self.__a.lat(), self.__b.lat())
        south = min(self.__a.lat(), self.__b.lat())
        east  = max(self.__a.lng(), self.__b.lng())
        west  = min(self.__a.lng(), self.__b.lng())
        return (north, east, south, west)

    @classmethod
    def from_nesw(cls, n, e, s, w):
        return cls(w, s, e, n)

    def geopoint_and_radius_to_geobox(lon, lat, radius):
        # Radius of the earth in miles: 3963.1676 miles
        # Radius of the earth in meters: 6378100 m
        # FIXME: rx should be scaled by 1/cos(lat)
        longitude = 69.16022727272727
        latitude = 68.70795454545454
        rx = radius / longitude
        ry = radius / latitude
        return {'max_longitude': lon+rx, 'min_longitude': lon-rx, 'max_latitude': lat+ry ,'min_latitude': lat-ry}


def polyCentroid(polygon):
    n = len(polygon)
    xCentroid = yCentroid = area = 0.0

    i = 0
    while i < n:
        x0 = polygon[i][0]
        y0 = polygon[i][1]
        x1 = polygon[(i + 1) % n][0]
        y1 = polygon[(i + 1) % n][1]

        a1 = (x0 + x1) / 2
        a2 = (x0*x0 + x0*x1 + x1*x1) / 6
        a3 = (x0*y1 + y0*x1 + 2 * (x1*y1 + x0*y0)) / 6
        b = y1 - y0
        area = area + (a1 * b)
        xCentroid = xCentroid + (a2 * b)
        yCentroid = yCentroid + (a3 * b)
        i +=1

    xCentroid = xCentroid/area
    yCentroid = yCentroid/area

    return (xCentroid,yCentroid)

def round(x):
    y = int(x)
    k = x - y
    if k >= .5:
        return y+1
    else:
        return y

def clamp(a,b,c):
    if b is not None:
        a = max(a,b)
    if c is not None:
        a = min(a,c)
    return a

def to_radians(degrees):
    return float(degrees) * math.pi / 180.0

def to_degrees(radians):
    return float(radians)/(math.pi/180.0)

def meters_to_miles(meters):
    return meters * METERS_TO_MILES

def miles_to_meters(miles):
    return miles * MILES_TO_METERS


class Vector2(object):
    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)

class MercatorProjection(object):
    """Mercator projection that converts between lng/lat and pixels, I think.

    I'm reasonably sure that the magic=256 parameter corresponds to the
    fact that at zoom level 0 GoogleMaps displays the world as a *256* pixel
    square image.  Each zoomlevel is a power-of-two better resolution,
    which corresponds to all the dividing and multiplying by 2 below.

    If you, dear reader, want to actually figure out the match below and
    comment it up, that would be great.  The Wikipedia Mercator Projection page
    is reasonable and talks a little about the connection with GoogleMaps:
        http://en.wikipedia.org/wiki/Mercator_projection
    """

    def __init__(self, zoomlevels, magic = 256.0):
        self.Ze = []
        self._e = []
        self.Xe = []
        self.Ye = []
        c = float(magic)
        for i in range(zoomlevels+1):
            e = c / 2.0
            self.Ze.append(c / 360.0)
            self._e.append(c / (2.0*math.pi))
            self.Xe.append(Vector2(e, e))
            self.Ye.append(c)
            c *= 2.0

    def from_latlng_to_pixel(self, lnglat, zoom):
        size = self.Xe[zoom]

        e = round(size.x+lnglat.lng()*self.Ze[zoom])
        f = clamp(math.sin(to_radians(lnglat.lat())), -0.9999, 0.9999)
        g = round(size.y+0.5*math.log(float(1.0+f)/float(1.0-f))*-self._e[zoom])
        return Vector2(e,g)

    def from_pixel_to_latlng(self, pixel, zoom):
        e = self.Xe[zoom]
        f = float(float(pixel.x)-e.x)/self.Ze[zoom]
        g = float(float(pixel.y)-e.y)/-self._e[zoom]
        h = to_degrees(2.0*math.atan(math.exp(g))- math.pi / 2.0)
        return LngLat(f, h)

def unperiodize(a,b,c):
    while a > c:
        a -= c - b
    while a < b:
        a += c - b
    return a

MILES_PER_LATITUDE = 68.70795454545454

def miles_per_longitude(latitude, latitude_is_measured_in_radians = False):
    '''Find out how many miles there are between lines of longitude at a given latitude'''
    if not latitude_is_measured_in_radians:
        latitude = latitude * math.pi / 180.0 # convert to radians
    return abs(69.1 * math.cos(latitude))     # 69.1 is the distance (measured in miles) between lines of longitudes at the equator

# NOTE: There is a version of this function implemented much more efficiently
# in C in cgeom. This function, however, has merit serving as a sort of
# unit test for the C version, and better documents how the algorithm works.
def circle_square_intersection(circ_x, circ_y, circ_r, sq_n, sq_e, sq_s, sq_w, rho=lambda x, y: 1, divisions=10):
    '''Returns the area common to a circle centered at (circ_x, circ_y) with
    radius circ_r and a square bounded by the lines sq_{n,e,s,w} which
    represent the north/east/south/west sides of the square.

    Each differential piece of area will be multiplied by the density, rho, at
    that particular point. Rho is evaluated with a normalized x, y coordinate
    for each point. It is evaluated as rho((x - circ_x) / r, (y - circ_y) / r).
    This means that rho should accept points in the domain [-1, 1] x [-1, 1].

    Since this works by actually polling a bunch of points inside of the square
    and checking that they lie within the circle, this method is fairly slow.
    '''

    assert sq_w < sq_e and sq_s < sq_n

    r_sq = circ_r * circ_r

    # The square and the circle have mutually non-overlapping parts, so we
    # divide the square into equally spaced divisions and test how many of
    # these are common to both the circle and square, then return the
    # proportion of those points in the circle times the area of the square
    x_interval = (sq_e - sq_w) / float(divisions)
    y_interval = (sq_n - sq_s) / float(divisions)

    x_coords = tuple(sq_w + i * x_interval for i in range(divisions))
    y_coords = tuple(sq_s + i * y_interval for i in range(divisions))

    fr = float(circ_r)

    common_area = sum(rho((x - circ_x) / fr, (y - circ_y) / fr) for x in x_coords for y in y_coords if (x - circ_x)**2 + (y - circ_y)**2 < r_sq)

    # Distribute out multiplying by the differential area contribution (for speed)
    return common_area * x_interval * y_interval


def range_contains_point(one_d_range, one_d_pt):
    '''
    Given a 1-d range 'one_d_range' that wraps around
    (e.g. a range of latitudes or longitudes)
    Check if a given point 'l' is is in 'l-range'

    @param one_d__range -- 2-tuple of (start, end)
    @param one_d_pt -- 1-d point
    @return -- l in one_d_range

    examples:

    range_contains_point((50, 100), 75) -- true
    range_contains_point((-100, -50), 75) -- false
    range_contains_point((-50, -100), 75) -- true
    '''
    if one_d_range[0] < one_d_range[1]:
        # something like (-100, 100)
        return one_d_range[0] <= one_d_pt and one_d_range[1] >= one_d_pt
    else:
        # something like (50, -20)
        return one_d_range[0] <= one_d_pt or one_d_range[1] >= one_d_pt

def range_intersects_range(range_a, range_b):
    '''
    Given two one-dimensional ranges (that may wrap around some max/min-values,
    e.g. latitude or longitude), check if they intersect
    '''
    return  range_contains_point(range_a, range_b[0]) or \
            range_contains_point(range_a, range_b[1]) or \
            range_contains_point(range_b, range_a[0]) or \
            range_contains_point(range_b, range_a[1])


class GeoCircle(object):
    """Represents a geographic circle centered at lng_lat with a radius of
    radiu_mi miles."""
    def __init__(self, lng_lat, radius_mi):
        self.__geocode = lng_lat
        self.__radius = float(radius_mi)

    def contains(self, geocode, error = .001):
        """Get whether or not this geocode is contained inside of this circle."""
        dist = great_circle_dist_miles(tuple(self.__geocode), tuple(geocode))
        return dist < self.__radius or abs(dist - self.__radius) < error

class Vertices(list):
    """Helper class to represent a list of vertices forming a closed path."""

    def contains(self, point):
        """Get whether this set of vertices contains point.  Assumes vertices are
        supplied in CCW order."""
        x, y = point
        return point_in_polygon(tuple(point), self)

    def to_wkt(self):
        """Returns the WKT representation of the vertices (as a POLYGON).

        If there are no points in the list, returns None.
        """
        if len(self) < 1:
            return None
        points = ['%f %f' % (point[0],point[1]) for point in self]
        # WKT requires the first point to be repeated at the end of the sequence
        points = ','.join(points + [points[0]])
        return 'POLYGON((%s))' % points

class LinearRing(Vertices):
    pass

def path_segments_from_points(points):
    assert len(points) > 1
    segments = []
    curr = points[0]
    for p in points[1:]:
        segments.append((curr, p))
        curr = p
    segments.append((points[-1], points[0]))
    return segments

def path_segments_intersect(points):
    """If we build a path from a list of points (P) with segments like (P0, P1),
    (P1,P2), (Pi, Pi+1), ..., (PN -> P0), test if any of the segments intersect.

    O(n) => n^2
    """
    segments = path_segments_from_points(points)
    for i in segments:
        for j in segments:
            if i == j:
                continue
            p1, p2 = i
            p3, p4 = j
            # Ignore pairs with the same endpoints
            if p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4:
                continue
            if segments_intersect(i, j):
                return True
    return False

def segments_intersect(segment1, segment2):
    """Test if segments (P0 => P1), (P2 => P3) intersect
    See:
    http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/

    To see if segment1 and segment2 intersect, solve for ua and ub where

    P1 + ua ( P2 - P1 ) = P3 + ub ( P4 - P3 )

    segment1 => (P1, P2)
    segment2 => (P3, P4)

    and check if 0 <= ua <= 1 and 0 <= ub <= 1

    Algebra for solving ua, ub:

    x1 + ua (x2 - x1) = x3 + ub (x4 - x3)

    y1 + ua (y2 - y1) = y3 + ub (y4 - y3)

          (x4 - x3)(y1 - y3) - (y4 - y3)(x1 - x3)
    ua  =  ---------------------------------------
           (y4 - y3)(x2 - x1) - (x4 - x3)(y2 - y1)


            (x2 - x1)(y1 - y3) - (y2 - y1)(x1 - x3)
    ub  =  ---------------------------------------
           (y4 - y3)(x2 - x1) - (x4 - x3)(y2 - y1)

    """
    (x1, y1), (x2, y2) = segment1
    (x3, y3), (x4, y4) = segment2

    x1 = float(x1)
    x2 = float(x2)
    x3 = float(x3)
    x4 = float(x4)

    y1 = float(y1)
    y2 = float(y2)
    y3 = float(y3)
    y4 = float(y4)

    denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1))
    if denom == 0:
        return False

    ua = (((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3))) / denom

    ub = (((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3))) / denom

    if (0 <= ua <= 1) and (0 <= ub <= 1):
        return True
    return False

def centroid(polygon):
    '''The centroid of a polygon is its center of mass. The algorithm here is
    taken from http://local.wasp.uwa.edu.au/~pbourke/geometry/polyarea/

    WARNING: (JAE) i think this function doesn't work unless the points are in a certain order.
    If you're not sure, use the 'polyCentroid' method instead.'''
    poly = [(float(x), float(y)) for x, y in polygon]
    seq = zip(poly[:-1], poly[1:])
    area_frac = 1.0 / (3.0 * sum(x0 * y1 - x1 * y0 for (x0, y0), (x1, y1) in seq))
    zrhs = zip(seq, [x0 * y1 - x1 * y0 for (x0, y0), (x1, y1) in seq])
    cx = area_frac * sum((x0 + x1) * r for (((x0, y0), (x1, y1)), r) in zrhs)
    cy = area_frac * sum((y0 + y1) * r for (((x0, y0), (x1, y1)), r) in zrhs)
    return (cx, cy)

# Copied from yelp_lib.ai.bucketing since it's a one-liner and lets us keep medoid here.
def mega_hash(v):
    """
    Hash a value of any type to a float in [0, 1) by using its str
    representation.
    """
    hashed = int(hashlib.md5(str(v).encode('latin1')).hexdigest(), 16)
    return float(hashed) / (2**128)

def medoid(points, distance_func=None, max=20):
    """The medoid of a list of points is the point with
    the smallest cumulative distance to the other points.

    We use this to find a representative point for
    Favorites Lists, for example.

    points -- a list of tuples of (long, lat)
    distance_func -- a function to compute the distance between two
        points. (If you want to do 3-D points, use an appropriate
        distance function.)
    max -- only compare against this many points ("randomly" chosen
        using mega_hash()). This prevents the algorithm from being
        O(n^2) for large numbers of point.
    """
    if distance_func is None:
        distance_func = great_circle_dist_miles
    # cached distances between 2 points. Keys are a
    # tuple of (pointA, pointB)
    distances = {}

    def dist(a, b):
        if a == b:
            return 0

        key = tuple(sorted((a, b)))
        if not key in distances:
            distances[key] = distance_func(*key)

        return distances[key]

    # return the point with the min cumulative distance
    points = tuple(points) # so we can re-use the same points
    if len(points) > max:
        ref_points = sorted(points, key=lambda p: mega_hash(p))[:max]
    else:
        ref_points = points

    min_dist, pick = min((sum(dist(p,q) for q in ref_points), p)
                         for p in points)
    return pick

def item_inside_lng_lat_radius(longitude, latitude, radius):
    """Get a function suitable for passing to filter() that will test whether an
    item is inside of great circle distance miles of the point at longitude,
    latitude and radius.

    The "item" dictionary is expected to have the keys
    'longitude' and 'latitude'

    Arguments:
    longitude -- float, the longitude of the point to test
    latitude -- float, the latitude of the point to test
    radius -- float, the radius in miles

    Returns:
        a function like:
            Arguments:
            item -- dict, a dictionary with the keys longitude and latitude
            Returns:
            True or False if the item is within great-circle-distance miles radius of
            longitude, latitude.
    """
    def is_item_inside(item):
        item_lng = item['longitude']
        item_lat = item['latitude']
        if item_lng == None or item_lat == None:
            return False
        dist = great_circle_dist_miles((longitude, latitude),
            (item_lng, item_lat))
        return dist < radius or abs(dist - radius) < .001
    return is_item_inside

great_circle_dist_miles = _great_circle_dist_miles
try:
    import cgeom
    def great_circle_dist_miles(point_a, point_b):
        point_a_lng, point_a_lat = point_a
        point_b_lng, point_b_lat = point_b
        return cgeom.great_circle_dist_miles(point_a_lng, point_a_lat, point_b_lng, point_b_lat)
except ImportError as e:
    pass

# the following 3 functions are python translation of C++ functions from
# http://marknelson.us/2007/08/22/convex/

def direction(p0, p1, p2):
    """
    Returns if p2 is to the right (+ve), left (-ve) or on the same line (0) as p0 - p1
    Keyword arguments:
     p0, p1, p2 - points
    Returns
         > 0 if p2 is right
         < 0 if p2 is left
         0 if p2 is on the same line as p0, p1

    This method works by transforming the points so that p1 is the origin and then taking a
    cross-product of p0 and p2.
    """
    return (p0['longitude'] - p1['longitude'])*(p2['latitude'] - p1['latitude']) - \
                (p2['longitude'] - p1['longitude'])*(p0['latitude'] - p1['latitude'])

def build_half_hull(partition_points, factor, right, left):
    """
    Builds the convex hull for the points passed in as partition_points.
    The factor is 1 for the lower hull and -1 for the upper hull

    partition_points - partition of points to find a hull for
            these points are sorted left to right
    right - right most point of the partition
    left -  left most point of the partition

    Returns
     a list of points that are a convex hull for the points passed as input
    """
    result_hull = []
    partition_points.append(right)
    result_hull.append(left)

    while partition_points:
        result_hull.append(partition_points.pop(0))
        while len(result_hull) >= 3:
            # the most recently appended point is the rightmost point we have seen so far
            # it is definitely part of the hull. Consider the two points (-3,-2) just behind the
            # most recently added point. If the point just behind the recently added point would be inside
            # the hull formed by connecting the recently added point then this point is no longer
            # part of the hull so delete it from the result set
            if factor * direction(result_hull[-3], result_hull[-1], result_hull[-2]) <= 0 :
                result_hull.pop(-2)
            else:
                break

    return result_hull


def convex_hull(points):
    """
        Returns a list of points which form a convex_hull for the points supplied to this function

        Arguments
            points: a list of points each with 'latitude' and 'longitude' attributes
        Returns
            list of points which form convex_hull

        This function implements Graham's scan algorithm found here
        http://marknelson.us/2007/08/22/convex/

    """

    if len(points) <= 2:
        return None

    sorted_points = sorted(points, key=lambda point: (point['longitude'], point['latitude']))

    # get the leftmost and rightmost points
    left = sorted_points[0]
    right = sorted_points[-1]

    upper_partition_points = []
    lower_partition_points = []

    # consider the line joining left and right
    # partition the points into the upper and lower sets
    for i in range(1, len(sorted_points) - 1):
        if direction(left, right, sorted_points[i]) < 0:
            upper_partition_points.append(sorted_points[i])
        else:
            lower_partition_points.append(sorted_points[i])

    lower_hull = build_half_hull(lower_partition_points, 1, right, left)
    upper_hull = build_half_hull(upper_partition_points, -1, right, left)

    # the begin and end points are repeated in the both the hulls
    # drop the end point of the upper hull and reverse it so that
    # it forms the convex hull with combined with the lower hull
    upper_hull = upper_hull[len(upper_hull) - 2 :: -1]
    convex_hull = lower_hull + upper_hull

    return convex_hull


def move_lnglat(lnglat, distance_meters, bearing_radians):
    """Move distance (meters) with bearing (radians) from a longitude, latitude start point.
    Returns longitude, latitude for destination point.

    A bearing is a clockwise direction starting from a reference direction of 0 (north) and increasing up to 2 PI radians.

    Calculate an endpoint given a startpoint, bearing and distance
    Vincenty 'Direct' formula based on the formula as described at http://www.movable-type.co.uk/scripts/latlong-vincenty-direct.html
    Original JavaScript implementation 2002-2006 Chris Veness
    Code derived from http://www.thismuchiknow.co.uk/?p=120
    """
    longitude, latitude = lnglat
    lat1 = to_radians(latitude);
    lon1 = to_radians(longitude);

    a = 6378137
    b = 6356752.3142
    f = 1.0 / 298.257223563  # WGS-84 ellipsiod
    s = distance_meters
    alpha1 = bearing_radians
    sinAlpha1 = math.sin(alpha1)
    cosAlpha1 = math.cos(alpha1)

    tanU1 = (1 - f) * math.tan(lat1)
    cosU1 = 1 / math.sqrt((1 + tanU1 * tanU1))
    sinU1 = tanU1 * cosU1
    sigma1 = math.atan2(tanU1, cosAlpha1)
    sinAlpha = cosU1 * sinAlpha1
    cosSqAlpha = 1 - sinAlpha * sinAlpha
    uSq = cosSqAlpha * (a * a - b * b) / (b * b)
    A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)))
    B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)))

    sigma = s / (b * A)
    sigmaP = 2 * math.pi

    cos2SigmaM = 0
    sinSigma = 0
    cosSigma = 0

    while(math.fabs(sigma - sigmaP) > 1e-12):
        cos2SigmaM = math.cos(2 * sigma1 + sigma)
        sinSigma = math.sin(sigma)
        cosSigma = math.cos(sigma)
        deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)))
        sigmaP = sigma
        sigma = s / (b * A) + deltaSigma

    tmp = (sinU1 * sinSigma) - (cosU1 * cosSigma * cosAlpha1)
    lat2 = math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1, (1 - f) * math.sqrt(sinAlpha * sinAlpha + tmp * tmp))
    lam = math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1)
    C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha))
    L = lam - (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)))

    lon2 = lon1 + L
    longitude = to_degrees(lon2)
    latitude = to_degrees(lat2)
    return longitude, latitude


def sort_by_distance(lnglat, objs, key=None):
    """Sort objects by distance from lnglat.
    Returns a sorted copy.
    The *lnglat* is a LngLat instance of where to sort from.
    The *objs* is a list of objects to sort.
    The *key* can be a lambda or function that returns a LngLat instance for the object.
    If None, the identity function is used, and the objs are assumed to be LngLat instances.
    For example::

        lnglat = LngLat(122.123, -34.123)
        businesses = [{'latitude': 122.222, 'longitude': -34.222, 'name': 'Levchins Thirst', ... }, ...]
        businesses_sorted = sort_by_distance(lnglat, businesses, lambda b: LngLat(b['longitude'], b['latitude']))
    """
    if key is None:
        key = lambda a: a

    distances = []
    for obj in objs:
        obj_lnglat = key(obj)
        if not obj_lnglat:
            distance = float('inf')
        else:
            distance = lnglat.great_circle_dist_miles(obj_lnglat)
        distances.append({'d': distance, 'obj': obj})

    distances.sort(key=lambda d: d['d'])
    return [distance_['obj'] for distance_ in distances]

def globe_distance(p, q):
    """The globe distance between `p` and `q` if they exist. Otherwise None"""
    if not p or not q:
        return None
    return great_circle_dist_miles((p['longitude'], p['latitude']), (q['longitude'], q['latitude']))
