"""
Holds the class definition for the Cython version of geogrid
"""
from __future__ import absolute_import

from geogrid import cgeogrid
from geogrid.cgeogrid import deinterleave32
from geogrid.cgeogrid import interleave32
from geogrid.geom import LngLatBounds

_pyflakes_ignore = [deinterleave32, interleave32]

class GeoGrid(object):
    """The GeoGrid is the set of all quads on the Earth.  Each geocode maps to
    one quad, and each quad maps to the extent of a set of geocodes.
    """
    # This is the quad size in longitude/latitude degrees
    GEOGRID_STEP = 0.05

    @classmethod
    def quad(cls, longitude, latitude):
        """Convert a point to a quad identifier"""
        try:
            longitude = float(longitude)
        except TypeError:
            raise ValueError("Invalid longitude type: longitude was %s" % (longitude,))
        try:
            latitude = float(latitude)
        except TypeError:
            raise ValueError("Invalid latitude type: latitude was %s" % (latitude,))

        return cgeogrid._quad(longitude, latitude, cls.GEOGRID_STEP)

    @classmethod
    def quad_safe(cls, longitude, latitude):
        """Like quad() but returns None instead of a ValueError"""
        try:
            return cls.quad(longitude, latitude)
        except ValueError:
            return None

    @classmethod
    def center(cls, quad):
        """Get the center point from a quad id
        Args:
            quad: int, a quad identifier
        Returns:
            (float: longitude, float: latitude)
        """
        return cgeogrid._center(quad, cls.GEOGRID_STEP)

    @classmethod
    def distance_to_point(cls, quad, point):
        """finds the closest distance from the given point to any point in the quad."""

        # find the center lat/long for the quad.
        quad_lng, quad_lat = cls.center(quad)
        point_lng, point_lat = point
        return cgeogrid._distance_from_quad_center_to_point(quad_lng, quad_lat, point_lng, point_lat, cls.GEOGRID_STEP)

    @classmethod
    def extent(cls, quad):
        """Get an extent from a quad.
        Args:
            quad -- int, the quad #
        Returns:
            a LngLatBounds, the extent of the quad (this should be roughly GEOGRID_STEP
            big)
        """
        lng, lat = cls.center(quad)
        sw_lng = lng - cls.GEOGRID_STEP / 2.0
        sw_lat = lat - cls.GEOGRID_STEP / 2.0
        ne_lng = lng + cls.GEOGRID_STEP / 2.0
        ne_lat = lat + cls.GEOGRID_STEP / 2.0
        return LngLatBounds(sw_lng, sw_lat, ne_lng, ne_lat)

    @classmethod
    def in_extent(cls, bounds):
        """Get a set of quads which overlap the given extent."""
        # step thru and add every quad in the range.
        n, e, s, w = bounds.nesw

        return cgeogrid._in_extent(n, e, s, w, cls.GEOGRID_STEP)

    @classmethod
    def nearby(cls, point, radius, large_radius=False):
        """Get a list of nearby quads inside of a circle at longitude, latitude within
        radius.  This uses an approximation to find an extent of quads to search
        for, and then filters that set using great circle distance.

        If either longitude or latitude is None, returns []

        Args:
            point: geocode,
            large_radius: if True, allow radii > 100.0
        Returns:
            [int: quad #]


        The algorithm works as follows: First we get all the geoquads that intersect the rectangle that
        fits snug around the circle. Then, for each geoquad in that set we find the closest point in the quad's extent
        to the center point of the circle. If this distance is less than radius, it is included in the returned list.

        * marks the point in the geoquad that is closest to the circle.

          |         |         |         |
        --+---------+---------+---------+--
          |         |         |         |
          |        _|_...___  |         |
          |      / *|  *     \|*        |
        --+-----/---+---------\---------+--
          |    |    |         ||        |
          |    |   *|  *      |*        |   }- quads in the same latitude-strip as the circle center point (closest point has non-boundary latitude)
          |    |    |         ||        |
        --+-----\---+---------/---------+--
          |      \_*|__*_____/|*        |
          |         |         |         |
          |         |         |         |
        --+---------+---------+---------+--
          |         |         |         |
                       \__/
                        quads in the same longitude-strip as the circle center point (closest point has non-boundary longitude)
        """
        radius = float(radius)
        mid_lng, mid_lat = point

        if mid_lng is None or mid_lat is None:
            return []

        # We can only accurately calculate longitude radii for spans less than 100mi
        if not (0 <= radius <= 100.0 or large_radius):
            raise ValueError("The radius should be between 0 and 100.0 miles")

        return cgeogrid._nearby(mid_lng, mid_lat, radius, cls.GEOGRID_STEP)

def geogrid_for_size(step_size):
    """Get a geogrid with steps of size step_size"""
    return type('GeoGrid%03d' % int(step_size * 1000), (GeoGrid, ), {'GEOGRID_STEP': step_size})

