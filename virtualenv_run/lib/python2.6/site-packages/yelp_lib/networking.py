"""
Utility methods that make network-related stuff easier.
"""
import exceptions
import socket
import time

from .cidr_utils import inet_aton
from .cidr_utils import inet_ntoa


def normalize_ip(ip):
    """Convert ip from string form (e.g. "64.147.162.160") to numeric form if neccessary.
    Return numeric IPs unchanged.
    """
    if isinstance(ip, (int, long)): return ip
    if isinstance(ip, (basestring)): return inet_aton(ip)
    raise exceptions.TypeError, "ip must be number or string"


def reverse_dns(ip_s):
    try:
        return socket.gethostbyaddr(ip_s)[0]
    except socket.herror:
        # If the PTR field is present but doesn't hold any data then Python
        # will throw this exception.
        return ''


def mass_rdns_lookup(ip_addresses, sleep_time=0.5):
    """Takes an argument ip_addresses that is an iterable object (list, set,
    etc.) of string IP addresses (e.g. ['169.229.74.19', ...]) and then returns
    a dictionary of ip_address -> hostname.

    This uses the adns library and it is very, very fast. On a sample run on
    all of the unique IP addresses in an access_log, I timed it at 4m57.587s
    for 261483 unique IPs.
    """

    # Have the import statement here in case this code is put on boxes that
    # don't have adns but won't call this routine (e.g. SuSE boxes)
    import adns

    # Convert an IP address to a PTR hostname
    def ptr(ip):
        if isinstance(ip, (int, long)):
            ip = inet_ntoa(ip)
        return '.'.join(reversed(ip.split('.'))) + '.in-addr.arpa'

    resolver = adns.init()
    requests = dict((resolver.submit(ptr(ip), adns.rr.PTR), ip) for ip in ip_addresses)
    results = {}
    while len(resolver.allqueries()) > 0:
        completed = resolver.completed()
        if completed:
            for r in completed:
                rw = r.wait()
                names = rw[3]
                if names:
                    results[requests[r]] = names[0]
                else:
                    results[requests[r]] = None
        else:
            time.sleep(sleep_time)
    return results


def pick_unused_port():
    """
    Grabs a port that is currently unused.

    There is a race condition here in that the returned
    port can be grabbed by any other process.
    """
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind(('localhost', 0))
    _, port = s.getsockname()
    s.close()
    return port
