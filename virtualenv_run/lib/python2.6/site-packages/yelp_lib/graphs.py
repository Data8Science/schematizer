"""Utility methods for graphs and graph traversal."""
import copy


def breadth_first_traversal(adjacency_dict, start_key):
    """Return all elements in a breadth-first traversal of
    adjacency_dict starting at start_key.

    Args:
        adjacency_dict - A dictionary representing the adjacency list
            of a graph to traverse.  Key K represents a node with
            adjacent nodes V, where V is any iterable type.
        start_key - A key in adjacency_dict, start the breadth-first
            traversal at this node.
    Generates:
        A list of nodes visited during a breadth-first
        traversal of adjacency_dict.

    Notes: Visits any node at most once.  Does not require for start_key or
        any child node to actually be a key in adjacency_dict.
    """
    visited = set()
    q = [start_key]
    while q:
        current = q.pop(0)

        # Track visited elements by id, because id is
        # hash-able for any object
        visited.add(id(current))

        children = adjacency_dict.get(current, [])
        unvisited_children = [child for child in children if id(child) not in visited]
        q.extend(unvisited_children)

        yield current


class GraphTypeError(Exception):
    """Raised when a graph is invalid for the requested operation. For example,
    cyclic graphs don't have a topological ordering, so attempting to get one
    would result in this exception.
    """
    pass


class DirectedGraph(object):
    """Represents a directed (cyclic/acyclic) graph.

    Note that nodes must be hashable and unique.
    """

    def __init__(self):
        """Set up a new empty graph."""
        self.adjacency_list = {}
        self.reverse_list = {}

    def __eq__(self, other):
        """Check for graph equality. Graphs are considered equal if they have
        the same nodes and edges. Note that we don't need to compare the reverse
        list here, only the adjacency list. The two contain identical
        information that is simply indexed differently.
        """
        if not isinstance(other, DirectedGraph):
            return False
        return (self.adjacency_list == other.adjacency_list)

    def __ne__(self, other):
        """Check for graph inequality. This is implemented simply as the
        negation of graph equality.
        """
        return not self.__eq__(other)

    @property
    def nodes(self):
        """The nodes currently in the graph. Note that there is no guarantee
        that this list will be returned in insertion order or that order will be
        maintained after insertions/deletions.
        """
        return self.adjacency_list.keys()

    def add_node(self, node):
        """Add a node to the graph. Nodes must be unique. If a node already
        exits, this does nothing.
        """
        if node in self.adjacency_list:
            return
        self.adjacency_list[node] = set()
        self.reverse_list[node] = set()

    def add_edge(self, x, y):
        """Add an edge between nodes `x` and `y`. Both of these must have
        already been added as nodes to the graph. If either don't exist, a
        ``ValueError`` exception is thrown. If an edge already exists between
        the two nodes, this does nothing.
        """
        if not self.has_node(x):
            raise ValueError('Node %r is not in the graph' % x)
        if not self.has_node(y):
            raise ValueError('Node %r is not in the graph' % y)
        self.adjacency_list[x].add(y)
        self.reverse_list[y].add(x)

    def get_adjacent_nodes(self, node, deep=True):
        """Get all nodes adjacent to the given node. If `deep` is true, this
        will perform a search down the entire subgraph for the given node to
        collect all adjacent nodes.
        """

        # Optimize the shallow case
        if not deep:
            return self.adjacency_list[node]

        # Iteratively collect all adjacent nodes
        nodes = self.adjacency_list[node].copy()
        adjacent_nodes= set()
        while nodes:
            current_node = nodes.pop()
            if current_node == node:
                continue
            adjacent_nodes.add(current_node)
            for other in self.adjacency_list[current_node]:
                if other in adjacent_nodes:
                    continue
                nodes.add(other)
        return adjacent_nodes

    def get_node_representation(self, node):
        """Get the string representation for a subgraph with the given node."""
        stack = [(0, node)]
        enqueued = set()
        output = []
        while stack:
            level, node = stack.pop()
            output.append('\t' * level + str(node))
            if node not in enqueued:
                nodes = sorted(self.adjacency_list[node], reverse=True)
                stack.extend((level + 1, adjacent_node) for adjacent_node in nodes)
            enqueued.add(node)
        return '\n'.join(output)

    def has_node(self, node):
        """Determine if the given node exists in the graph."""
        return (node in self.adjacency_list)

    def sort_topologically(self):
        """Sort a graph topologically. The topological ordering of a directed
        acyclic graph is a linear ordering of its vertices such that, for every
        edge uv, u comes before v in the ordering.

        If this graph is not acyclic, this method raises an exception.
        """

        # Make a copy of the adjacency list to avoid modifying the graph. We
        # need a deep copy here since we'll be modifying the list values.
        adjacency_list = copy.deepcopy(self.adjacency_list)

        # Get all of the nodes with no incoming edges
        nodes = sorted((node for node, adjs in adjacency_list.iteritems()
            if not adjs), reverse=True)

        # Sort the graph topologically
        sorted_nodes = []
        while nodes:
            node = nodes.pop()
            sorted_nodes.append(node)
            for other in sorted(self.reverse_list[node]):
                adjacency_list[other].remove(node)
                if not adjacency_list[other]:
                    nodes.append(other)

        # If we have any edges leftover at this point, we have a cycle
        if any(adjacency_list.values()):
            raise GraphTypeError('Cyclic graphs have no topological ordering')

        # Return the topological ordering
        return sorted_nodes

    def __repr__(self):
        """Return a string representation of the graph."""
        output = []
        for node in sorted(self.adjacency_list.iterkeys()):
            output.append(self.get_node_representation(node))
        return '\n'.join(output)
