# -*- coding: utf-8 -*-
import cPickle
import functools
import inspect
import itertools

from yelp_lib.retry import retry_deco
from yelp_lib.retry import delay_policy


def retry(tries, exceptions=(Exception, ), delay=0):
    return retry_deco(lambda: delay_policy(tries, sleep_seconds=delay), retry_exceptions=exceptions)


def total_ordering(cls):
    """Class decorator that fills in missing ordering methods

    This is ported from upstream python.
    See: http://hg.python.org/cpython/file/2.7/Lib/functools.py
    """
    convert = {
        '__lt__': [('__gt__', lambda self, other: not (self < other or self == other)),
                   ('__le__', lambda self, other: self < other or self == other),
                   ('__ge__', lambda self, other: not self < other)],
        '__le__': [('__ge__', lambda self, other: not self <= other or self == other),
                   ('__lt__', lambda self, other: self <= other and not self == other),
                   ('__gt__', lambda self, other: not self <= other)],
        '__gt__': [('__lt__', lambda self, other: not (self > other or self == other)),
                   ('__ge__', lambda self, other: self > other or self == other),
                   ('__le__', lambda self, other: not self > other)],
        '__ge__': [('__le__', lambda self, other: (not self >= other) or self == other),
                   ('__gt__', lambda self, other: self >= other and not self == other),
                   ('__lt__', lambda self, other: not self >= other)]
    }
    roots = set(dir(cls)) & set(convert)
    if not roots:
        raise ValueError('must define at least one ordering operation: < > <= >=')
    root = max(roots)  # prefer __lt__ to __le__ to __gt__ to __ge__
    for opname, opfunc in convert[root]:
        if opname not in roots:
            opfunc.__name__ = opname
            opfunc.__doc__ = getattr(int, opname).__doc__
            setattr(cls, opname, opfunc)
    return cls


def getinfo(func):
    """Return an info dictionary containing:
    - name (the name of the function : str)
    - argnames (the names of the arguments : list)
    - defarg (the values of the default arguments : list)
    - fullsign (the full signature : str)
    - shortsign (the short signature : str)
    - arg0 ... argn (shortcuts for the names of the arguments)

    >>> def f(self, x=1, y=2, *args, **kw): pass

    >>> info = getinfo(f)

    >>> info["name"]
    'f'
    >>> info["argnames"]
    ['self', 'x', 'y', 'args', 'kw']

    >>> info["defarg"]
    (1, 2)

    >>> info["shortsign"]
    'self, x, y, *args, **kw'

    >>> info["fullsign"]
    'self, x=defarg[0], y=defarg[1], *args, **kw'

    >>> info["arg0"], info["arg1"], info["arg2"], info["arg3"], info["arg4"]
    ('self', 'x', 'y', 'args', 'kw')
    """
    assert inspect.ismethod(func) or inspect.isfunction(func)
    regargs, varargs, varkwargs, defaults = inspect.getargspec(func)
    argnames = list(regargs)
    if varargs: argnames.append(varargs)
    if varkwargs: argnames.append(varkwargs)
    counter = itertools.count()
    fullsign = inspect.formatargspec(
        regargs, varargs, varkwargs, defaults,
        formatvalue=lambda value: "=defarg[%i]" % counter.next())[1:-1]
    shortsign = inspect.formatargspec(
        regargs, varargs, varkwargs, defaults,
        formatvalue=lambda value: "")[1:-1]
    dic = dict(("arg%s" % n, name) for n, name in enumerate(argnames))
    dic.update(name=func.__name__, argnames=argnames, shortsign=shortsign,
        fullsign = fullsign, defarg = func.func_defaults or ())
    return dic


def _contains_reserved_names(dic): # helper
    return "_call_" in dic or "_func_" in dic


def _decorate(func, caller):
    """Takes a function and a caller and returns the function
    decorated with that caller. The decorated function is obtained
    by evaluating a lambda function with the correct signature.
    """
    infodict = getinfo(func)
    assert not _contains_reserved_names(infodict["argnames"]), \
           "You cannot use _call_ or _func_ as argument names!"
    execdict = dict(_func_=func, _call_=caller, defarg=func.func_defaults or ())
    if func.__name__ == "<lambda>":
        lambda_src = "lambda %(fullsign)s: _call_(_func_, %(shortsign)s)" \
                     % infodict
        dec_func = eval(lambda_src, execdict)
    else:
        func_src = """def %(name)s(%(fullsign)s):
        return _call_(_func_, %(shortsign)s)""" % infodict
        exec func_src in execdict
        dec_func = execdict[func.__name__]
    #import sys; print >> sys.stderr, func_src # for debugging
    dec_func.__doc__ = func.__doc__
    dec_func.__dict__ = func.__dict__
    # propagating the innermost function out
    # https://trac.yelpcorp.com/wiki/LogicEncapsulation
    if hasattr(func, 'orig_func'):
        dec_func.orig_func = func.orig_func
    else:
        dec_func.orig_func = func
    return dec_func


class decorator(object):
    """General purpose decorator factory: takes a caller function as
input and returns a decorator. A caller function is any function like this::

    def caller(func, *args, **kw):
        # do something
        return func(*args, **kw)

Here is an example of usage:

    >>> @decorator
    ... def chatty(f, *args, **kw):
    ...	 print "Calling %r" % f.__name__
    ...	 return f(*args, **kw)

    >>> @chatty
    ... def f(): pass
    ...
    >>> f()
    Calling 'f'
    """
    ## The basic trick is to generate the source code for a lambda function
    ## with the right signature and to evaluate it.
    ## Uncomment the 'print lambda_src' statement in _decorate
    ## to understand what is going on.

    def __init__(self, caller):
        self.caller = caller
        self.__name__ = caller.__name__

    def __call__(self, func):
        return _decorate(func, self.caller)


def get_orig_func(func):
    """Get the 'original function' before any decorators were applied"""

    if hasattr(func, 'orig_func'):
        return func.orig_func
    else:
        return func


class memoized(object):
    """Decorator that caches a function's return value each time it is called.
    If called later with the same arguments, the cached value is returned, and
    the function is not re-evaluated.

    Based upon from http://wiki.python.org/moin/PythonDecoratorLibrary#Memoize
    Nota bene: this decorator memoizes /all/ calls to the function.  For a memoization
    decorator with limited cache size, consider:
    http://code.activestate.com/recipes/496879-memoize-decorator-function-with-cache-size-limit/
    """
    def __init__(self, func):
        self.func = func
        self.cache = {}

    def __call__(self, *args, **kwargs):
        # If the function args cannot be used as a cache hash key, fail fast
        key = cPickle.dumps((args, kwargs))
        try:
            return self.cache[key]
        except KeyError:
            value = self.func(*args, **kwargs)
            self.cache[key] = value
            return value

    def __repr__(self):
        """Return the function's docstring."""
        return self.func.__doc__

    def __get__(self, obj, objtype):
        """Support instance methods."""
        return functools.partial(self.__call__, obj)


def classmethodwrapper(classmethod_obj):
    """ Makes it possible to further decorate a classmethod in-line, e.g.
        @classmethod
        def my_classmethod(cls):
            pass
        some_other_func = some_other_decorator(...)(classmethodwrapper(my_classmethod))
    """
    def wrapper(identity, *args, **kwargs):
        return classmethod_obj.__get__(identity)(*args, **kwargs)
    return wrapper


def LRUCache(max_size, make_key=hash):
    """A simple dict-based LRU cache

    The cached function must:
     - Have no kwargs
     - Have only hashable args
       - If the decorated function is passed an unhashable arg, a TypeError
         will be raised
     - Be idempotent (be without side effects)
       - Otherwise the cache could become invalid

    Usage:
        @LRUCache(max_size=50)
        def to_be_cached(foo, bar):
            ... some computation ...
            return retval

    The default `make_key` value is the build-in hash() function, which is
    fast, but can't handle all types.  To allow this decorator to be used with
    functions with kwargs or unhashable args, pass in a non-default `make_key`
    function.
    """
    if max_size < 1:
        raise ValueError('max_size must be >= 1')

    cache = {}
    cache_get = cache.get

    # Constants:
    PREV, NEXT, KEY, RESULT = 0, 1, 2, 3   # names for the link fields

    # We use this dummy class to simulate the python3 nonlocal keyword
    class nonlocal:
        __slots__ = ('currsize', 'full', 'root')
        currsize = 0
        full = False
        root = []             	# root of the circular doubly linked list
        root[:] = [root, root, None, None]   	# initialize by pointing to self

    def lrucache_decorator(user_function):
        def lrucached_fn(*args, **kwds):
            root = nonlocal.root
            # size limited caching that tracks accesses by recency
            if kwds:
                key = make_key(args, kwds)
            else:
                key = make_key(args)
            link = cache_get(key)
            if link is not None:
                # move the link to the front of the circular queue
                link_prev, link_next, key, result = link
                link_prev[NEXT] = link_next
                link_next[PREV] = link_prev
                last = root[PREV]
                last[NEXT] = root[PREV] = link
                link[PREV] = last
                link[NEXT] = root
                return result
            result = user_function(*args, **kwds)
            if nonlocal.full:
                # use root to store the new key and result
                root[KEY] = key
                root[RESULT] = result
                cache[key] = root
                # empty the oldest link and make it the new root
                root = nonlocal.root = root[NEXT]
                del cache[root[KEY]]
                root[KEY] = root[RESULT] = None
            else:
                # put result in a new link at the front of the queue
                last = root[PREV]
                link = [last, root, key, result]
                cache[key] = last[NEXT] = root[PREV] = link
                nonlocal.currsize += 1
                nonlocal.full = (nonlocal.currsize == max_size)
            return result
        return lrucached_fn
    return lrucache_decorator


def partialable(func, num_args_needed=1):
    """Given function that needs at least one positional argument,
    return a function that automatically partials itself if called with
    fewer args than necessary

    This is useful for creating a decorator that can be optionally passed params.

    Args:
        num_args_needed - number of positional arguments your function needs (defaults to 1)
        [kwargs_needed - could take a set of kwargs needed also...]

    Example:
        @partialable
        def log_it(func, log_name=DEFAULT_LOG_NAME):
            '''Simple logging decorator where you can OPTIONALLY specify a log name'''
            log = logger.getLogger(log_name)
            def logged_func(*args, **kwargs):
                log.info("CALLING %r with args:%r kwargs:%r", func, args, kwargs)
                return func(*args, **kwargs)

            return logged_func

    You can then use this decorator with or without calling in two ways:

        @log_it
        def my_func(x):
            return x+2

    OR

        @log_it(log_name='special_log')
        def special_func(x):
            return x+4

    Without this decorator your decorator would always have be called:

        @log_it()
        def my_func(x):
            return x+2

    And it would be less readable:

        def log_it(log_name=DEFAULT_LOG_NAME):
            '''Simple logging decorator where you MUST specify a log name'''
            log = logger.getLogger(log_name)

            def real_log_it_decorator(func):
                def logged_func(*args, **kwargs):
                    log.info("CALLING %r with args:%r kwargs:%r", func, args, kwargs)
                    return func(*args, **kwargs)

                return logged_func

            return real_log_it_decorator
    """
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        if len(args) < num_args_needed:
            # Not enough args specified, so just save the args using partial
            # The returned function should be called with args to invoke the real function
            return functools.partial(func, *args, **kwargs)
        else:
            return func(*args, **kwargs)

    return wrapper


# Oh snap. Things are about to get real.
partialable = partialable(partialable)
"""This makes the num_args_needed argument to partialable optional so you can do both:

    @partialable
    def func(arg, my_kwarg=4)
        return arg + my_kwarg

and

    @partialable(num_args_needed=2)
    def func(arg1, arg2, my_kwarg=4)
        return arg1 + arg2 + my_kwarg
"""


if __name__ == "__main__":
    import doctest; doctest.testmod()
