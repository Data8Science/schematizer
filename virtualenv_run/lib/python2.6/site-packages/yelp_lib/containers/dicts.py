# -*- coding: utf-8 -*-
"""
Utility functions for manipulating dictionaries.
"""

import collections
import operator
import sys
from collections import defaultdict

from yelp_lib.arguments import NULL_ARG
from .common import _val_subtract
from .lists import makelist
from .ordered_dict import OrderedDict


def dict_merge(*dictionaries, **kwargs):
    """Merges a list of dictionaries. By default, right most dictionary takes
    precedence.

    :param output_dict: container to accumulate result into. Defaults to dict().
    :param overwrite: Boolean indicating whether merging should allow values to be
                      overwritten (right most dictionary takes precedence). Defaults to True.

    :returns: the merged dictionary
    """
    output_dict = kwargs.get('output_dict', dict())
    overwrite = kwargs.get('overwrite', True)

    for current_dict in dictionaries:
        if current_dict:
            assert overwrite or not any((key in output_dict) for key in current_dict)
            output_dict.update(current_dict)

    return output_dict


def invert_dict(input_dict):
    """
    Inverts input_dict s.t. keys become values, and vice-versa.

    Example:

    .. code-block:: python

        {'a': 1, 'b': 2} => {1: 'a', 2: 'b'}

    If mutiple keys map to the same value, you're screwed;  you'll only get
    one of the value/key pairs back in the inverted dictionary.  Be careful!
    """
    return dict((value, key) for key, value in input_dict.items())


def link_path_to_chain(path):
    """
    Turn a dot-separated string of links to follow into
    a list. e.g. 'reviews.user' -> ['reviews', 'user']
    (we can't simply use split because it converts '' to [''])

    The inverse of link_path_to_chain is simply '.'.join(chain)
    """
    if path == '':
        return []
    elif type(path) in (list, tuple, set):
        return path
    else:
        return path.split('.')


def get_deep(x, path='', default=None):
    """The equivalent of x.get() for multiple levels,
    so we can do something like
    business['selected_review']['review'] without
    getting a crash if business['selected_review'] is
    None.

    :param path: a dot-separated list of fields to walk
                 ('selected_review.review' in the above example). These can
                 be numbers as well (for instance, to index into lists)
    :param default: return this if the chain is broken at any point
    """
    chain = link_path_to_chain(path)
    return get_deep_by_chain(x, chain, default=default)


def get_deep_by_chain(x, chain, default=None):
    """See get_deep; this provides an interface without needing
    to construct a period-separated path string.

    :param x: source dictionary to retrieve from
    :param chain: sequence (e.g., list or tuple) of fields to walk
    :param default: default value to return if any lookup fails
    """
    try:
        for link in chain:
            try:
                x = x[link]
            except (KeyError, TypeError):
                x = x[int(link)]
    except (KeyError, TypeError, ValueError):
        x = default
    return x


def set_deep(x, path='', value=None, missing_links=dict):
    """Like get_deep, but sets the value at the given path to value.

    Any links that do not exist in the path will be initialized using the
    provided constructor (default dict).
    """
    chain = link_path_to_chain(path)
    set_deep_by_chain(x, chain, value=value, missing_links=missing_links)


def set_deep_by_chain(x, chain, value=None, missing_links=dict):
    """set_deep()'s evil step-brother that takes a list of keys
    instead of a period-delimited path string.

    :param chain: sequence of fields to walk
    :param value: value to set
    :param missing_links: initializer function to create any nesting
                          levels that do not exist (defaults to dict())
    """
    for link in chain[:-1]:
        try:
            x = x[link]
        except KeyError:
            x[link] = missing_links()
            x = x[link]
    x[chain[-1]] = value


def filter_by_keys(dictionary, keys):
    """Create a new dictionary with only the specified keys"""
    result = {}
    for k in keys:
        if k in dictionary:
            result[k] = dictionary[k]
    return result


def filter_out_by_keys(dictionary, keys):
    """Create a new dictionary without the specified keys"""
    result = dict(dictionary)
    for k in keys:
        result.pop(k, None)
    return result


def cmp_by_keys(dicta, dictb, keys):
    """Compare two dictionaries by their key/value pairs, and only by the
    specified keys.
    """
    return filter_by_keys(dicta, keys) == filter_by_keys(dictb, keys)


def winnow_by_keys(dictionary, keys):
    """Return a tuple of two new dictionaries, one with and one without the specified keys"""
    keys_dict = {}
    not_keys_dict = dict(dictionary)
    for k in keys:
        if k in not_keys_dict:
            keys_dict[k] = not_keys_dict.pop(k)

    return keys_dict, not_keys_dict


def filter_dict_by_dict(d, filter_dict,
        init_fcn=dict, not_present_fcn=None):
    """Filter `d` by `filter_dict`, transparently handling lists in `d`.

    This filtering can apply to sub-structures in `d`. It is somewhat akin
    to making a series of get_deep(d, ...) / set_deep(result, ...) calls,
    but handles list structures better.

    Quick example:

    .. code-block:: python

        filter_dict_by_dict({'a': {'x': 0, 'y': 1}}, {'a': {'y': True}})
        #	--> {'a': {'y': 1}}


    :param d: The dictionary to be filtered.
    :param filter_dict: A (possibly multi-level) dictionary specifying
            how to filter `d`. Terminal True values indicate that the
            corresponding sub-dictionary from `d` should be selected.

    :param init_fcn: Constructor used for the returned dict and its sub-dicts.
            If `filter_dict` is an OrderedDict, and `init_fcn` is [the
            function] OrderedDict, then the result will be ordered the
            same as `filter_dict`. Default is the dict() function.
    :param not_present_fcn: Function to call when a key specified by
            `filter_dict` is missing from `d`. Takes two arguments,
            the partial result dictionary, and the key that is missing.
            Defaults to doing nothing.

    :returns: A sub-dict of `d` containing only keys specified by `filter_dict`.

    Example:

    .. code-block:: python

        d = {
            'a': {
                'x': 1},
            'b': [
                {'y': 2,
                 'z': 3},
                {'y': 4,
                 'z': 5,
                 'w': 6}],
            'c': 1}

    Basic example

    .. code-block:: python

        filter_dict_by_dict(d, {'a': True}) --> {'a': {'x': 1}}

    Example showing how it handles lists

    .. code-block:: python

        filter_dict_by_dict(d, { 'b': { 'y': True, 'z': True }, 'a': True })
        #	--> {
        #		'b': [
        #			{'y': 2,
        #			 'z': 3},
        #			{'y': 4,
        #			 'z': 5}],
        #		'a': {'x': 1}}

    Note that the 'w' field was not selected. Also, for the list entries of
    'b', we kept 'y' and 'z' together in the same [dictionary] object.
    """
    if filter_dict is True:
        return d
    elif isinstance(d, (tuple, list)):
        return [filter_dict_by_dict(e, filter_dict, init_fcn=init_fcn,
                                    not_present_fcn=not_present_fcn)
                for e in d]
    elif isinstance(d, dict):
        res = init_fcn()
        for key, sub_filter_dict in filter_dict.iteritems():
            if key not in d:
                if not_present_fcn is not None:
                    not_present_fcn(res, key)
            else:
                res[key] = filter_dict_by_dict(
                    d[key],
                    sub_filter_dict,
                    init_fcn=init_fcn,
                    not_present_fcn=not_present_fcn)
        return res
    else:
        print >> sys.stderr, ("WARNING -- recursive_filter_by_keys() given "
            "a value which is not a dictionary or list.")


def sort_by_key(dictionarysequence, key, **kwargs):
    """Sort a sequence of dictionaries by a key in the dictionary"""
    return sorted(dictionarysequence, key=lambda item: item[key], **kwargs)


def mapdict(function, dictionary, deep=False):
    """Maps `function` against each value of `dictionary`."""
    result_dictionary = {}
    for key in dictionary:
        if deep and isinstance(dictionary[key], dict):
            result_dictionary[key] = mapdict(function, dictionary[key], True)
        else:
            result_dictionary[key] = function(dictionary[key])
    return result_dictionary


def get_deep_subdict_by_dict(dicta, dictb, not_present_fcn=None):
    """Given a dict (dicta), return a subdict of that dict based on the structure of
    another dict (dictb). Recursive and list-aware, because it uses filter_dict_by_dict.

    Example:

    .. code-block:: python

        dicta = {
            'a': {
                'aa': 'AA',
                'ab': 'AB'
            },
            'b': {
                'ba': 'BA',
                'bb': 'BB',
                'bc': 'BC'
            },
            'c': [
                'ca',
                'cb'
            ]
        }
        dictb = {
            'a': {
                'aa': '123'
            },
            'b': {
                'ba': '234'
            },
            'c': '345'
        }

        get_deep_subdict_by_dict(dicta, dictb)
        #  {
        #    'a': {
        #        'aa': 'AA'
        #    },
        #    'b': {
        #        'ba': 'BA'
        #    },
        #    'c': [
        #        'ca',
        #        'cb'
        #    ]
        # }
    """
    return filter_dict_by_dict(dicta, mapdict(lambda v: True, dictb, deep=True), not_present_fcn=not_present_fcn)

def setdefaults(dictionary, default_dictionary):
    """
    For all keys present in default_dictionary but not in dictionary,
    set the values in dictionary to the value in default_dictionary
    """
    for key, default_value in default_dictionary.iteritems():
        dictionary.setdefault(key, default_value)


def recursive_dict_add(dict_a, dict_b, default_value=None, inherit_structure=False):
    """
    Merges two dictionaries recursively.  In other words, it does a key-wise
    addition on the two dictionaries, including the keys of any subdictionaries.

    Modifies 'dict_a' instead of using a return value.

    If you want to automatically default the value for keys present in 'dict_b'
    missing from 'dict_a' to be some value (like 0), you can pass a non-None value
    to 'default_value'. If you want 'dict_a' to automatically inherit any structure
    from 'dict_b', you can set 'inherit_structure' = True.

    Example:
    In [2]: a = {'counts': { 'first_count': 2, 'secound_count': 3 }, 'total_count': 5 }
    In [3]: recursive_dict_add(a, a)
    In [4]: a
    Out[4]: {'counts': {'first_count': 4, 'secound_count': 6}, 'total_count': 10}
    """
    for key, value in dict_b.iteritems():
        if isinstance(value, dict):
            if inherit_structure and key not in dict_a:
                dict_a[key] = dict_b[key].copy()
            else:
                recursive_dict_add(dict_a[key], dict_b[key], default_value=default_value, inherit_structure=inherit_structure)
        else:
            if default_value != None and not isinstance(value, defaultdict):
                dict_a.setdefault(key, default_value)
            dict_a[key] += value
    return dict_a


def dict_subtract(dict1, dict2):
    """
    Return key,value pairs from dict1 that are not in dict2

    Returns:
    A new dict 'res_dict' with the following properties:

    For all (key, val) pairs where key appears in dict2:

    if dict1[val] == dict2[val] then res_dict[val] is not defined
    else res_dict[val] == dict1[val]

    If vals are themselves dictionaries the algorim is applied recursively.

    Example:

    .. code-block:: python

        dict_subtract({
                       1: 'one',
                       2: 'two',
                       3: {'a': 'A', 'b': 'B'},
                       4: {'c': 'C', 'd': 'D'}
                      },
                      {
                       2: 'two',
                       3: {'a': 'A', 'b': 'B'},
                       4: {'d': 'D'},
                       5: {'e': 'E'}
                      }) => {1: 'one', 4: {'c': 'C'}}
    """

    # make a result we can edit
    result = dict(dict1)

    # find the common keys -- i.e., the ones we might need to subtract
    common_keys = set(dict1.keys()) & set(dict2.keys())
    for key in common_keys:
        val1, val2 = dict1[key], dict2[key]

        if val1 == val2:
            # values are the same: subtract
            del result[key]
        else:
            from .lists import list_subtract
            # values are different: set the output key to the different between the values
            result[key] = _val_subtract(val1, val2, dict_subtract, list_subtract)

    return result

def map_keys_to_ints(input_dict):
    """
    Returns a new dict where all keys of input_dict are cast to int.

    Useful for JSON dicts where we end up stringifying dict keys that are
    actually all integers
    """
    return dict((int(key), value) for key, value in input_dict.iteritems())

def flatten_dict_tree(d):
    """
    Flattens a nested dictionary.

    :param d: a dictionary which may contain other dictionaries
              which themselves contain dictionaries, and so on.

    :returns:

    A dictionary whose keys are every key that appears in the tree,
    and whose values are the values they correspond to (which may
    themselves be branches of the original tree. We assume that
    all keys are unique; if they are not, you may need to walk at
    least a branch of the tree to get the value you want.
    """
    result = {}

    def process(d):
        for k, v in d.iteritems():
            result[k] = v
            if isinstance(v, dict):
                process(v)

    process(d)

    return result


def flatten_dict_keys(in_dict, separator='.'):
    """Flatten the key names in a nested dictionary.

    Assumes all dict keys are strings.

    .. code-block:: python

        >>> flatten_dict_keys({'a': {'b': 3}, 'c': {'d': {'e': 45}}})
        {'a.b': 3, 'c.d.e': 45}
    """
    queue = collections.deque(in_dict.iteritems())
    if isinstance(in_dict, OrderedDict):
        out_dict = OrderedDict()
    else:
        out_dict = {}

    while True:
        try:
            key, value = queue.popleft()
        except IndexError:
            return out_dict

        if isinstance(value, dict):
            queue.extendleft(
                ((key + separator + inner_key), inner_value) for inner_key, inner_value in value.iteritems()
            )
        else:
            out_dict[key] = value


def walk_dict_tree(dict_or_dicts, path):
    """Generator function to walk through all the values at a given
    depth in a dictionary tree.

    (A dictionary tree is a dictionary whose values may also be
    dictionary trees or lists of dictionary trees. Like the way
    we represent filled rows from the database.)

    For example:

    .. code-block:: python

        walk_dict_tree([{'users': [{'name': 'Dave'}, {'name': 'Rhett'}]},
                        {'users': [{'name': 'Bran'}]},
                        {'users': [{'name': ['Cyndi', 'Constantino']}]},
                        {'users': None}], 'users.name')


    yields ['Dave', 'Rhett', 'Bran', 'Cyndi', 'Constantino'] (and doesn't
        get hung up on the None value)

    walk_dict_tree() works whether the values in your dictionaries
    are dictionaries or lists (or, at the very end of your path,
    anything).

    walk_dict_tree determines if a field is a dictionary
    or a list of dictionaries by calling isinstance(field, list).

    :param dict_or_dicts: a dictionary tree, or a sequence of
                            dictionary trees
    :param path: a dot-separated list of relations to follow, e.g.
        'biz_bookmarks.business'. walk_dict_tree(dicts, '') simply
        returns each row
    """
    # break path into its pieces
    chain = link_path_to_chain(path)

    def walk_chain(x, idx_in_chain):

        # if it's a list, walk each value in the list
        if isinstance(x, list):
            for item in x:
                for result in walk_chain(item, idx_in_chain):
                    yield result
        # base case; we've found a value at the right depth
        # and it's not a list
        elif idx_in_chain >= len(chain):
            yield x
        # we can't walk None, so bail out
        elif x is None:
            return
        else:
            # we're going to look up the given key, so hopefully
            # it's a dict
            for result in walk_chain(x[chain[idx_in_chain]],
                                     idx_in_chain + 1):
                yield result

    # package tuples, sequences, etc. up as a list
    if isinstance(dict_or_dicts, list): # common case
        dict_trees = dict_or_dicts
    else:
        dict_trees = makelist(dict_or_dicts)

    # walk our dict_trees recursively
    for result in walk_chain(dict_trees, 0):
        yield result


def build_map_by_key(sequence, key='id', value_func=None):
    """
    Returns a dict mapping keys of elements in `sequence` to the elements themselves.

    If elements are dicts, you may specify a `key` (this can be a dot
    seperated string represented a nested dict) name in each dict
    to use for keying elements in the returned dict:

    .. code-block:: python

        build_map_by_key([{'id': 1}, {'id': 2}])
        # {1: {'id': 1}, 2: {'id': 2}}

    Otherwise, specify `key` as a getter function:

    .. code-block:: python

        build_map_by_key([[1,2,3],[2,4,5]], key=lambda x: x[0])
        # {1: [1,2,3], 2: [2,4,5]}

    You may also specify a value_func which is a function that is passed
    each entry in the sequence to construct the value in the map. By default
    the entire entry is used as the value.
    """
    if callable(key):
        key_func = key
    else:
        key_func = lambda element: get_deep(element, key)

    if value_func:
        return dict((key_func(i), value_func(i)) for i in sequence)
    return dict((key_func(i), i) for i in sequence)

def _build_map_to_iterable(sequence, add_value_func, key='id', value_func=None):
    """Return a dictionary mapping keys to iterables.

    :param sequence: input iterable to process.
    :param add_value_func: function taking in the current dictionary, a key, and a
        new value. It defines how new values should be added to the dictionary
        for the given key.
    :param key: defines the key of the dictionary. The key can be the name of an
        attribute of items in sequence or a function that takes in an element of
        the sequence an returns the key.
    :param value_func: function taking in a key, a value, and the result
        dictionary. Defines how values should be added to the dictionary.

    """
    if callable(key):
        key_func = key
    else:
        key_func = operator.itemgetter(key)

    out = {}
    for i in sequence:
        value = value_func(i) if value_func else i
        # Associates a value to a key
        add_value_func(out, key_func(i), value)
    return out

def build_map_to_list_by_key(sequence, key='id', value_func=None):
    """
    Return a dict mapping keys of elements in `sequence` to lists
    of the elements with that key.

    Example:

    .. code-block:: python

        build_map_to_list_by_key([{'id': 1, 'val': 'A'},
                                  {'id': 1, 'val': 'B'}])

        # {1: [{'id': 1, 'val': 'A'}, {'id': 1, 'val': 'B'}] }

    If the sequence elements are dicts, you may specify a `key` name
    in each dict to use for keying lists of elements in the returned dict.
    Otherwise, specify `key` as a getter function:

    .. code-block:: python

        build_map_to_list_by_key([[0,1,2], [0,3,4]], key=lambda x: x[0])
        # {0: [[0,1,2], [0,3,4]]}

    You may also specify a value_func which is a function that is passed
    each entry in the sequence to construct the value in the map. By default
    the entire entry is used as the value.

    """
    append_value_func = lambda out, key, value: out.setdefault(key, []).append(value)
    return _build_map_to_iterable(sequence, append_value_func, key, value_func)

def build_map_to_set_by_key(sequence, key='id', value_func=None):
    """
    Return a dict mapping keys of elements in `sequence` to sets
    of the elements with that key. Otherwise, the behavior is similar
    to build_map_to_list_by_key.

    """
    add_value_func = lambda out, key, value: out.setdefault(key, set()).add(value)
    return _build_map_to_iterable(sequence, add_value_func, key, value_func)

def build_map_to_val(dictionarysequence, key, valkey):
    """
    Given a sequence of dicts and two keys (key, valkey), returns a
    dict of {d[key] => d[valkey]} for all dictionaries d in the sequence.
    """
    return dict((i[key], i[valkey]) for i in dictionarysequence)

def remap_names(dictionary, remapping, keep_unmapped_keys=True):
    """
    Given a dictionary and a remapping dictionary of the form {"old_key": "new_key"},
    returns a new dictionary with remapped key names.  By default, unmapped keys are
    returned in the new dictionary.  keep_unmapped_keys=False will cause unmapped keys
    to be absent from the resultant dictionary.
    """
    remapped_dictionary = {}

    # Add the new keys with their values from the original dictionary
    for old_key, new_key in remapping.iteritems():
        if old_key in dictionary:
            remapped_dictionary[new_key] = dictionary[old_key]

    if keep_unmapped_keys:
        # Update all other keys that weren't already added with their new value
        for key, value in dictionary.iteritems():
            if key not in remapping:
                remapped_dictionary[key] = value

    return remapped_dictionary

def iter_deep_keys(dictionary):
    """
    Given a nested dictionary, yields deep key chains suitable for use with
    set_deep and get_deep.
    """

    def inner(thing, chain_prefix):
        if type(thing) == dict:
            for key, value in thing.iteritems():
                for x in inner(value, chain_prefix + (key,)): yield x
        elif type(thing) in (list, tuple):
            for i in xrange(0, len(thing)):
                for x in inner(thing[i], chain_prefix + (i,)): yield x
        else:
            yield chain_prefix

    for x in inner(dictionary, ()): yield x

def top_dict_items(dictionary, count):
    """ Return a new dictionary that only has the top 'count' items in
    'dictionary', based on the values
    """
    return dict(sorted(dictionary.iteritems(), key=operator.itemgetter(1), reverse=True)[:count])

def getitem_invariant(iterable, key, on_error_return=NULL_ARG):
    """Just a conveninece facade for getattr_invariant with the right arguments
    for it to work with dicts.
    """
    from yelp_lib.objects import getattr_invariant # Circular import
    return getattr_invariant(iterable, key, on_error_return, attr_getter=operator.getitem)
