"""
Utility methods for manipulating lists.
"""

from .common import _val_subtract

def without_none(a_list):
    """Compacts a list by removing any None elements."""
    return [item for item in a_list if item is not None]


def partition(pred, xs):
    """Partition a list by a predicate. The returned result is (items satisfying
    the predicate, items not satisfying the predicate)."""

    sat = []
    nsat = []
    for x in xs:
        if pred(x):
            sat.append(x)
        else:
            nsat.append(x)
    return sat, nsat


def unlist(a_list):
    """Convert the (possibly) single item list into a single item"""
    if len(a_list) > 1:
        raise ValueError(len(a_list))

    if len(a_list) == 0:
        return None
    else:
        return a_list[0]


def one(a_list):
    """Convert the single item list into a single item"""
    (value,) = a_list
    return value


def makelist(x):
    """If x is already a list, tuple, or sequence (not including
    strings and dictionary-like objects), return list(x). Otherwise,
    return [x]. (Even if x is really a list, returns a copy of x)

    This is useful for method arguments that normally take a single
    item of a non-list type, but occasionally take multiple items.
    """
    if isinstance(x, basestring) or hasattr(x, 'keys'):
        return [x]
    else:
        try:
            return list(x)
        except (TypeError, NotImplementedError):
            return [x]


def relist(a_val):
    """Like makelist except None => []"""
    if a_val is None:
        return []
    else:
        return makelist(a_val)


def flatten(xs):
    """
    Flattens a list that may or may not contain other lists as elements.

    flatten([1,2,3]) => [1,2,3]
    flatten([[1,2],3]) => [1,2,3]
    """
    flattened = []
    for x in xs:
        flattened.extend(x)
    return flattened


def deep_flatten(iterable):
    """
    Returns a list of all the elements from a list of lists (of lists of lists....)
    Turns something like [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]
    to [1, 2, 3, 4, 5, 6, 7, 8]
    """
    flattened = []
    for thing in iterable:
        if hasattr(thing, '__iter__'):
            flattened.extend(deep_flatten(thing))
        else:
            flattened.append(thing)
    return flattened


def list_subtract(list1, list2):
    """
    Returns the difference between list1 and list2.

    list_subtract([1,2,3], [3,2,1]) == [1,3]

    If any items in the list are container types, the method recursively calls
    itself or .dicts.dict_subtract() to subtract the child
    containers.
    """
    from .dicts import dict_subtract

    # call val_subtract on all items that are not the same
    res_list = [_val_subtract(val1, val2, dict_subtract, list_subtract)
                for val1, val2 in zip(list1, list2) if val1 != val2]

    # now append items that come after any item in list1
    res_list += list1[len(list2):]

    # return a tuple of list1 is a tuple
    if isinstance(list1, tuple):
        return tuple(res_list)
    else:
        return res_list

def last(listlike):
    """Get the last element from a random-access (list-like) collection or None."""
    if listlike:
        return listlike[-1]
    else:
        return None

def listify(records, field='id'):
    """
    Convert:
        a single value,
        a list of values,
        a single dictionary containing the value in a specfied field,
        a list of records containing a field
    to:
        a list of fields.
    """

    if isinstance(records, basestring):
        # Yes, ok, techinically strings are sequences of characters.  I don't care.
        records = [records]
    else:
        # convert single values to a list.
        try:
            records[0]
        except IndexError:
            pass
        except:
            records = [records]

    # if records are dictionaries, extract ids
    try:
        return [r[field] for r in records]
    except TypeError:
        return records
