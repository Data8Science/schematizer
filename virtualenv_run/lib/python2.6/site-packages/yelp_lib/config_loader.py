"""Generic module for using non-code-based configuration files.

Basic usage:
    Call yelp.util.config_loader.load with the relative path to a YAML config
    file. It will return the loaded version of said YAML file and cache it for
    future reference. The file will be re-parsed any time it is accessed and
    its mtime has changed. You should not cache returned data from load() yourself,
    but should instead call it every time you need to access its contents so as to
    be able to change configuration without gracefulling.

Loaders:
    yelp.util.config_loader.load takes an optional "loader" argument which should
    be a function that takes a file-like object and deserializes it. Some example
    loaders are provided in this module.
"""

from __future__ import with_statement

from collections import namedtuple
import os
import os.path
import re
import time
import yaml

# The minimum amount of time between stats (in seconds)
MIN_CHECK_TIME=2

# A cache of config files. Maps full path => (mtime, data)
_config_cache = {}

# A cache of stat times (to limit how frequently we check things).
# Maps full path => last check time
_stat_times = {}


ConfigCache = namedtuple('ConfigCache', 'mtime data')

def load(file_name, root, loader=yaml.safe_load, min_check_time=MIN_CHECK_TIME,
        min_age=0):
    """Load a configuration file. The file_name is interpreted to be relative to
    the config directory unless otherwise specified. Configuration files are cached
    and will be returned from local memory unless their mtime has changed.

    Args:
        file_name - A path relative to root to a configuration file.
        root - Root for config files.
        loader - A function which takes a file-like object and loads it
        min_check_time - minimum number of seconds between stats
        min_age - minimum age of the file required to reload it
    """
    full_path = os.path.join(root, file_name)
    now = time.time()
    if now - _stat_times.get(full_path, 0) > min_check_time:
        mtime = os.stat(full_path).st_mtime
        _stat_times[full_path] = now
        if full_path not in _config_cache or (mtime != _config_cache[full_path].mtime \
                and (now - _config_cache[full_path].mtime) > min_age):
            with open(full_path, 'r') as f:
                data = loader(f)
                _config_cache[full_path] = ConfigCache(mtime, data)
    return _config_cache[full_path].data


# Alias "load" as "get"
get = load

def unload(file_name, root):
    """Unloads the given config file."""

    full_path = os.path.join(root, file_name)
    if full_path in _config_cache:
        del _config_cache[full_path]
        del _stat_times[full_path]

#----- BEGIN EXAMPLE LOADERS -----#

_comment_re = re.compile("#.*")

def plain_text_loader(callback=None):
    """Example loader that deserializes from a plain-text file.
    Any text after a "#" is ignored, any blank lines are ignored,
    and all strings are stripped. Takes an optional "callback" function,
    which is called on the list of cleaned lines before storing; otherwise,
    the list is stored directly."""
    def loader(text_file):
        data = []
        for line in text_file:
            line = _comment_re.sub("", line)
            line = line.strip()
            if line == "":
                continue
            data.append(line)
        if callback:
            return callback(data)
        else:
            return data
    return loader
