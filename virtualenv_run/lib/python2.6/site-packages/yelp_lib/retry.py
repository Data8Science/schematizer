# -*- coding: utf-8 -*-
"""A retry decorator / apply-er that is modular.

The 3 main components:
policy_gen - Generator that yields when we should try calling f; ends
    when no more retries should be attempted
retry_exceptions - Tuple of exceptions to retry on
on_exception - Funtion called on any retry-able exception


Some examples:

Retry f(x) 5 times with no backoff:
apply_retry(range(5), f, (x, ))

Retry f(x) 5 times with exp backoff from 1 second doubling until 30 seconds:
apply_retry(backoff_policy(1, 2, 30), f, (x, ))

Retry f(x) 5 times only on TimeoutError or IOError:
apply_retry(range(5), f, (x, ), retry_exceptions=(TimeoutError, IOError))

You can also specify functions to run when a retryable exception is
handled:
def log_f(i, ex):
    logging.error('Try #{0}: {1!r}'. format(i, ex))

Retry f(x) 5 times, logging every retry:
apply_retry(range(5), f, (x, ), on_exception=log_f)


All of these options can be applied as a decorator using
@retry_deco(...), with the exception that you have to pass a function
that will make a retry policy:
@retry_deco(lambda: backoff_policy(1, 2, 30))
"""
from __future__ import absolute_import

import functools
import itertools
import time


def backoff_policy(start_seconds=0.25, factor=2, max_seconds=8):
    """Yields a retry counter. After each try, sleep an exponentially
    increasing number of seconds. Be done if we would have slept more
    than max_seconds."""
    for i in itertools.count(0):
        yield
        # After this attempt, sleep for some time.
        sleep_seconds = start_seconds * factor ** i
        if sleep_seconds <= max_seconds:
            time.sleep(sleep_seconds)
        # If we're over the max time, then we're done generating the
        # retry counter, so break. This only makes this stop yielding.
        else:
            break


def delay_policy(times, sleep_seconds=0.5):
    """Yields a retry counter. After each try, sleep sleep_seconds."""
    for _ in range(times):
        yield
        time.sleep(sleep_seconds)


def apply_retry(policy_gen, f, args=(), kwargs={}, retry_exceptions=(Exception, ), on_exception=None):
    """Retry a function some number of times.

    Args:
        policy_gen - Generator that yields when we should try f
        f - Function to call
        args - Arguments to f
        kwargs - Kwarguments to f
        retry_exceptions - Only retry on these exceptions
        on_exception - Called whenever a retry-able exception is caught; takes:
            i - Retry count
            ex - Caught exception
    """
    ex = None
    for i, _ in enumerate(policy_gen):
        try:
            # Kwargs are shallow copied on function call; we don't have
            # to worry about the mutable default argument here.
            return f(*args, **kwargs)
        except retry_exceptions as ex:
            if on_exception:
                on_exception(i, ex)
    # If we went through the loop at least once and there was an
    # exception.
    if ex:
        raise
    else:
        raise RuntimeError('retry generator must yield at least one item')


def retry_deco(policy_gen_maker, retry_exceptions=(Exception, ), on_exception=None):
    """Decorator to retry a function some number of times.

    All arguments identical to apply_retry. policy_gen_maker is a
    function that when called will return a generator function that can
    be used in apply_retry. This is because each invocation to the
    wrapped function needs it's own generator state.

    Sample usage:
    @retry_deco(lambda: range(5))
    """
    def constructed_deco(f):
        """Actual decorator that will be applied to f. Has all of the
        apply_retry arguments in place."""
        @functools.wraps(f)
        def wrapped_f(*args, **kwargs):
            # Because we need a *new* generator each time f is to be
            # called, we have to pass in a generator maker to the
            # decorator.
            policy_gen = policy_gen_maker()
            return apply_retry(
                policy_gen,
                f,
                args=args,
                kwargs=kwargs,
                retry_exceptions=retry_exceptions,
                on_exception=on_exception,
            )
        return wrapped_f
    return constructed_deco
