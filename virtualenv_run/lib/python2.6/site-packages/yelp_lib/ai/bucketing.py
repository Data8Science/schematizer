"""Utilities for placing values into buckets, and choosing from a number
of weighted options.

Assumptions about buckets:
- buckets represent half-open intervals [a, b)
- buckets are referred to by their floor (a).
- We use None (not -Inf) to refer to the lowest bucket because python effectively treats
  None as negative infinity (i.e. None < number returns True for any number)
- A bucketing scheme is represented as a sorted list; e.g. [None, 10, 100]
"""
import datetime
import hashlib
import random
from bisect import bisect_left
from bisect import bisect_right


def mega_hash(v):
    """
    Hash a value of any type to a float in [0, 1) by using its str
    representation.
    """
    hashed = int(hashlib.md5(str(v)).hexdigest(), 16)
    return float(hashed) / (2**128)

def weighted_choice(choices, r=None):
    """Choose from several weighted options.

    Args:
    choices -- a list of tuples of (value, weight). Can also be a dictionary,
        in which case we'll sort the dictionary keys.
    r -- a number in [0, 1). If None, we'll use random().
        mega_hash() is also a good option.
    """
    chooser = make_weighted_chooser(choices)
    return chooser(r)

def make_weighted_chooser(choices):
    """Make a function that randomly selects from a list of weighted
    choices. This function can optionally take an argument in [0, 1)
    to determine which choice to make. This is a little more efficient
    than calling weighted_choice() repeatedly.

    Args:
    choices -- a list of tuples of (choice, weight). Can also be a dictionary,
        in which case we'll sort the dictionary keys.
    """
    if isinstance(choices, dict):
        # sorting keeps ordering stable if items are later added to
        # or removed from the dictionary.
        choices = sorted(choices.iteritems())

    # massage choices so that chooser() can run efficiently
    floor_list = []
    floor_to_threshold = {}
    floor = 0

    for value, weight in choices:
        if not (0 <= weight < float('inf')):
            raise ValueError('weights must be at least 0')

        floor_list.append(floor)
        floor_to_threshold[floor] = value
        floor += weight

    total_weight = floor
    if total_weight <= 0:
        raise ValueError('at least one weight must be positive')

    def chooser(r=None):
        if r is None:
            r = random.random()
        elif not (0 <= r < 1):
            raise ValueError('r must be in the range [0, 1)')

        floor = floor_from_sorted_list(r * total_weight, floor_list)
        return floor_to_threshold[floor]

    return chooser

def floor_from_sorted_list(x, floor_list):
    """Put the value x into a bucket.

    We'll return the largest element in floor_list that is <= x, or None if
    x is less than all of them.  (We assume floor_list is a list of
    bucket edges sorted ascending).

    We'll ignore any None values at the beginning of floor_list
    """
    # skip over None at the beginning of the list
    # (Python 3.0 can't compare values to None)
    lo = 0
    while lo < len(floor_list) and floor_list[lo] is None:
        lo += 1

    idx = bisect_right(floor_list, x, lo)

    if idx == 0:
        return None
    else:
        return floor_list[idx - 1]

def reason_for_floor(floor, floor_list):
    """Figure out why a value was bucketed by floor_from_sorted_list()

    Args:
    floor -- the bucket returned by floor_from_sorted_list()
    floor_list -- a sorted list of values, including None to represent
        a value lower than any value.

    Returns a tuple like ('>=', 8) or ('<', 2) to describe why a value
    fell into the given bucket. Will return None if floor_list is empty
    or only contains None.
    """
    if floor is not None:
        return ('>=', floor)
    else:
        for next_highest_floor in floor_list:
            if next_highest_floor is not None:
                return ('<', next_highest_floor)
        else:
            return None

def floor_counts(sorted_values, floor_list):
    """Count the number of values that fall into each bucket.

    We'll return a dictionary mapping floors from (sorted ascending)
    floor_list to the number of values in sorted_values that are >= to that floor.
    We'll map None to the number of values less than every floor.

    We'll ignore any None values at the beginning of floor_list,
    but sorted_values shouldn't contain None.

    We count elements in sorted_values using a binary search per floor,
    so this runs in O(len(floor_list) * log(len(sorted_values))) time
    """
    counts = {}

    prev_idx = 0
    prev_floor = None

    for floor in floor_list:
        if floor == prev_floor:
            continue

        idx = bisect_left(sorted_values, floor)
        counts[prev_floor] = idx - prev_idx

        prev_idx = idx
        prev_floor = floor

    # get count for the final bucket
    counts[prev_floor] = len(sorted_values) - prev_idx

    return counts

def floor_lists(tuples, floor_list):
    """Create a map of buckets to values that fall into each bucket.

    Args:
    tuples - a sequence or generator of (value, obj) tuples, where value
        is the bucketing value of obj.  For example, if tuples is:
            [(8,  {'friend_count': 8, 'user_name': 'russ'}),
             (10, {'friend_count': 10, 'user_name': 'darwin'}),
             (8,  {'friend_count': 8, 'user_name': 'jeremy'})]
        then tuples represents user dictionaries that we wish to bucket by friend_count
    floor_list - a list of bucket edges sorted ascending

    We'll return a dictionary mapping floors from floor_list to a list
    of objs in tuples that have values >= to that floor.  We'll
    map None to the elements less than every floor.

    We'll ignore any None values at the beginning of floor_list,
    but elems shouldn't contain None as a value.

    Using the example above,
        floor_lists(elems, [None, 8, 10])
    will return: {None: [], 8: [<russ>, <jeremy>], 10: [<darwin>]}

    Runs in O(log(|floor_list|) * |elems|) time.
    """
    bucked_lists = dict((fl, []) for fl in floor_list)

    # If no bucket edges, everything maps to None
    bucked_lists.setdefault(None, [])

    for value, obj in tuples:
        bucket = floor_from_sorted_list(value, floor_list)
        bucked_lists[bucket].append(obj)

    return bucked_lists

def pick_distro_uniform_floor_list(sorted_values, size):
    """Given a sorted list of values, pick buckets so that the values
    will be approximately equally distributed between the buckets.

    Args:
    sorted_values -- a sorted list of values
    size -- number of buckets to pick

    Returns: A sorted list of length size. Each item in the list will be a
    lower bound for values in the corresponding bucket. The first item in
    the list will always be None (to catch all values lower than the second
    item in the list).

    You can use can take the list returned, and pass it to floor_list.

    We assume that sorted_values doesn't have big clumps of the same value;
    if it does, it's possible to get the same floor value two or more times
    """
    floor_list = []

    for bucket_num in xrange(size):
        idx = len(sorted_values) * bucket_num / size
        if idx == 0:
            floor_list.append(None)
        else:
            floor_list.append(sorted_values[idx])

    return floor_list

def pick_range_uniform_floor_list(sorted_values, num_buckets=10):
    """Given a sequence of sorted values, pick bucket edges that
    uniformly span the domain of `sorted_values`.  Supports numeric
    values as well as datetimes.
    """
    if not sorted_values:
        return [] # No values to bucket
    elif num_buckets == 0:
        return [] # No buckets

    min_val = sorted_values[0]
    max_val = sorted_values[-1]
    val_range = abs(max_val - min_val)

    # Try to support datetimes
    if isinstance(val_range, datetime.timedelta):
        incr = val_range / int(num_buckets)
    else:
        incr = val_range / float(num_buckets)

    if incr == datetime.timedelta(0) or incr == 0:
        floor_list = [None, min_val, max_val]
    else:
        floor_list = [None]
        for index in range(num_buckets + 1):
            floor_list.append(min_val + index * incr)

    return floor_list

