"""
A wrapper for the csv module that encodes unicode strings into utf-8. In most places,
you can just use:

from util import csv_utf8


in place of

import csv


(and replace "csv" with "csv_utf8")

These classes just wrap existing classes/methods of the same name. If you
haven't already memorized the csv module's API, you'll need to see
http://docs.python.org/lib/module-csv.html for details.

NOTE: The `restkey` and `restval` arguments to `DictReader` and `DictWriter`
are unreliable -- if you set them to anything but their defaults, they may be
inadvertently stringified!
"""
import csv
from StringIO import StringIO

from yelp_lib.containers import dicts


def _to_utf8(v):
    """Overcome all odds and find a way to turn `v` into a UTF-8 bytestring.
    `None` is left unchanged.
    """
    if v is None:
        # None is a perfectly cromulent value to put in a csv file
        return None
    elif isinstance(v, str):
        # In this case we have to assume it's already utf8.
        return v
    else:
        return unicode(v).encode('utf-8')

def _from_utf8(v, errors="strict"):
    """Decode strs into unicode. We first try UTF-8, and if that
    fails, we try windows-1252 and latin-1 as fallbacks (latin-1
    should always work)."""
    if v is None:
        # The csv module returns None for missing fields
        return None
    elif isinstance(v, unicode):
        return v

    try:
        return unicode(v, 'utf-8')
    except TypeError:
        # We're only allowed to specify an encoding for str values, for whatever reason.
        return unicode(v)
    except UnicodeDecodeError:
        try:
            return v.decode('windows-1252')
        except UnicodeDecodeError:
            return v.decode('latin-1', errors) # should always work

class DictWriter(csv.DictWriter):
    """Like csv.DictWriter, but encodes unicode values into UTF-8.
    Keys still need to be strs or ASCII unicode values.
    """
    def __init__(self, csvfile, fieldnames, **kwargs):
        fieldnames = [_to_utf8(field) for field in fieldnames]
        csv.DictWriter.__init__(self, csvfile, fieldnames, **kwargs)

    def writerow(self, row):
        row = dict((_to_utf8(k), _to_utf8(v)) for (k,v) in row.iteritems())
        csv.DictWriter.writerow(self, row)

    def writerows(self, rows):
        for row in rows:
            self.writerow(row)

class Writer:
    """Like the writer object returned by csv.writer(), except that it encodes
    values into UTF-8."""

    def __init__(self, *args, **kwargs):
        """Takes the same args as csv.writer()"""
        self.writer = csv.writer(*args, **kwargs)

    def writerow(self, row):
        row = [_to_utf8(v) for v in row]
        self.writer.writerow(row)

    def writerows(self, rows):
        for row in rows:
            self.writerow(row)

writer = Writer

class DictReaderException(Exception):
    pass

class DictReader(csv.DictReader):
    """Like csv.DictReader, but decodes values into unicodes. Keys still need
    to be strs or ASCII unicode values
    """
    def next(self):
        return dict((_from_utf8(k), _from_utf8(v)) for (k,v) in csv.DictReader.next(self).iteritems())

class Reader:
    """
    Like the reader object returned by csv.reader, except that it decodes values
    into Unicode.
    """
    def __init__(self, *args, **kwargs):
        """Takes the same args as csv.reader()"""
        self.reader = csv.reader(*args, **kwargs)

    def __iter__(self):
        return self

    def next(self):
        return [_from_utf8(v) for v in self.reader.next()]

reader = Reader

def write_to_string_as_csv(headers, rows):
    """
    Writes the given headers / rows to a string as a csv and returns the result.

    Args:
        headers: a list of all possible columns in the CSV
        rows: a list of dictionaries, where each dictionary maps column->value for a single CSV row
    """
    output_file_handle = write_to_io_stream_as_csv(headers, rows)
    return output_file_handle.getvalue()

def write_to_io_stream_as_csv(headers, rows, fields_to_add_if_absent=None):
    """
    Returns a filehandle to a CSV generated from the given headers & rows.

    Args:
        headers: a list of all possible columns in the CSV
        rows: a list of dictionaries, where each dictionary maps column->value for a single CSV row
        fields_to_add_if_absent: extra field names to include if they don't appear in `rows`
    """
    # Ensure the headers are correct for writing
    headers = list(headers)
    if fields_to_add_if_absent:
        # The headers we need but are missing
        headers_to_add = set(fields_to_add_if_absent) - set(headers)

        #Add them to the front of the header list, sorted to make them look nice
        headers = sorted(list(headers_to_add)) + headers
    headers = tuple(header.strip() for header in headers)

    # Write the rows into the file
    output_file_handle = StringIO()
    writer = DictWriter(output_file_handle, fieldnames=headers)

    # Write the headers as a dict
    writer.writerow(dict((h, h) for h in headers))

    # Write all the result rows
    for row in rows:
        # Last check that we won't try to write rows that aren't in the csv
        row = dicts.filter_by_keys(row, headers)

        writer.writerow(row)

    # seek(0) so our caller can actually read the file if they desire
    output_file_handle.seek(0)

    return output_file_handle
