"""
Utility methods useful for inspecting python code execution.
"""
import os
import sys
import traceback


def showstack(startat=1, separator='->'):
    """Format a stack trace for logging."""
    def format_frame(frame):
        filename, line_num, code_name, _ = frame
        filename = os.path.basename(filename)
        return '%s (%s:%s)' % (code_name, line_num, filename)

    stack = traceback.extract_stack(sys._getframe(startat))
    return separator.join(format_frame(frame) for frame in stack)

def get_str_exception_traceback(type, value, tb):
    """One usually calls this function in the following way:
        exc_str = get_str_exception_traceback(*sys.exc_info())
    Args:
        type - exception type being handled.
        value - exception parameter
        tb - the stack trace.
    Returns - a str of the traceback.
    """
    return ''.join(traceback.format_exception(type, value, tb))

def get_current_traceback_as_str():
    """See above."""
    return get_str_exception_traceback(*sys.exc_info())

def itersubclasses(cls, _seen=None):
    """Iterate over all subclasses of a given class, in depth first order.

    Recipe from:
    http://code.activestate.com/recipes/576949/
    """

    if not isinstance(cls, type):
        raise TypeError('itersubclasses must be called with new-style classes, not %.100r' % cls)
    if _seen is None:
        _seen = set()
    try:
        subclasses = cls.__subclasses__()
    except TypeError: # fails only when cls is type
        subclasses = cls.__subclasses__(cls)
    for subclass in subclasses:
        if subclass not in _seen:
            _seen.add(subclass)
            yield subclass
            for subclass in itersubclasses(subclass, _seen):
                yield subclass
