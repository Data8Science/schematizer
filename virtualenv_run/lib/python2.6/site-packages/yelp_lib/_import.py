"""Utilities for importing other modules"""

def last_dot_splitter(dotted_path):
    """
    Split a string on the last dot.

    For example:
        'aaa.bbb.ccc' => ('aaa.bbb', 'ccc')
        'aaa'         => ('', 'aaa')
    """""
    path, _, last_segment = dotted_path.rpartition('.')
    return (path, last_segment)

def import_module_class(dotted_path):
    """
    Import a module + class path.

    Given a path like 'a.b.c.d', imports (and returns) an object named
    'd' from the module 'a.b.c'.
    """
    dotted_path = dotted_path.encode('ascii')
    module_name, class_name = last_dot_splitter(dotted_path)

    mod = import_module(module_name)
    try:
        attr = getattr(mod, class_name)
    except AttributeError:
        raise AttributeError("Module %r has no class %r" % (module_name, class_name))

    return attr

def import_module(dotted_path):
    """
    Import a dotted module path.

    Given a path like 'a.b.c', imports (and returns) module 'c' from
    package 'a.b'.
    """
    mod = __import__(dotted_path, globals(), locals(), [])

    for name in dotted_path.split('.')[1:]:
        try:
            mod = getattr(mod, name)
        except AttributeError:
            raise AttributeError("Module %r has no attribute %r" % (mod, name))

    return mod

def _import(dotted_path):
    """
    Given a path like 'a.b', import an object named 'b' from module 'a.b'.

    Primarily used as a shortcut for importing Cheetah template classes,
    as they have the exact same name as the module they are defined in.

    Returns the imported object.
    """
    _, last = last_dot_splitter(dotted_path)
    return import_module_class('.'.join([dotted_path, last]))

def get_full_dotted_type_string(obj):
    """
    Return the full dotted path of the given object.

    For example:
        datetime.date(2010, 10, 10) -> 'datetime.date'
    """
    return get_full_dotted_type_string_for_class(type(obj))

def get_full_dotted_type_string_for_class(cls):
    """
    Return the full dotted path of the given class.

    For example:
        datetime.date -> 'datetime.date'
    """
    return "%s.%s" % (cls.__module__, cls.__name__)

def all_submodules(dotted_path):
    """
    Return the list of all submodules of this module.

    >>> all_submodules('A.B.C.D')
    ['A.B.C.D', 'B.C.D', 'C.D', 'D']
    """

    module_parts = dotted_path.split('.')
    return [
            '.'.join(module_parts[i:])
            for i in xrange(len(module_parts))
    ]

def error_about_module_class(exception, dotted_path):
    """
    returns true if the `exception` object is about the `dotted_path`

    >>> error_about_module_class(
    ...     ImportError('No module named foo.bar'), 'cmds.foo.bar.MyClass')
    True
    """
    dotted_path = dotted_path.encode('ascii')
    mod, class_name = last_dot_splitter(dotted_path)
    known_errors = [
            AttributeError("Module %r has no class %r" % (
                mod, class_name
            ))
    ]
    known_errors.extend(
        ImportError('No module named %s' % submodule)
        for submodule in all_submodules(mod)
    )

    #exception equality is undefined, so we compare their representation-strings
    known_errors = tuple(repr(err) for err in known_errors)
    return repr(exception) in known_errors
