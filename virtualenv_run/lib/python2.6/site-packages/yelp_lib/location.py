# -*- coding: utf-8 -*-
# Don't change any of these values, because we don't have a good way
# of synchronizing releases of the webapp and geocoder projects.
class Accuracy:
    UNKNOWN_LOCATION = 0
    COUNTRY = 1
    REGION = 2
    COUNTY = 3
    TOWN = 4
    # This is for our airport geocoder. An airport we consider to be
    # slightly larger then a neighborhood but smaller than a town.
    AIRPORT = 4.25
    # Only used when we matched one of our neighborhoods. Should be a
    # flag, not an accuracy value. Oh well.
    NEIGHBORHOOD = 4.5
    ZIPCODE = 5
    # For cases where we have the entire postcode in a country where
    # postcodes are very precise (such as Canada and the UK).
    FULL_ZIP = 5.5
    STREET = 6
    # This indicates that we don't have a street number, but we
    # borrowed the geocode of another address geocoded to ADDRESS or
    # higher that's in the same full postcode.
    STREET_AND_FULL_ZIP = 6.25
    # Like STREET_AND_FULL_ZIP, except we DO have a street number, and
    # we borrowed the geocode of the closest neighboring address.
    ADDRESS_WITH_SAME_STREET_AND_FULL_ZIP = 6.5
    INTERSECTION = 7
    ADDRESS = 8
    PREMISE = 9
    # Someone set the accuracy of this business by hand through the
    # admin interface.
    BY_HAND = 9.5

# Replace this with a datastructure some day. You could implement this
# coercion behavior by overriding __setattr__ .

# Some of the choices below were forced by existing tests,
# specifically yelp.tests.util.addr.location_test
# UserDictToLocation.test_basic .
LOC_FIELD_TYPES = {
    'address1': (unicode, u''),
    'address2': (unicode, u''),
    'address3': (unicode, u''),
    'neighborhood': (unicode, u''),
    'borough': (unicode, u''),
    'city': (unicode, u''),
    'county': (unicode, None),
    'state': (unicode, ''),
    'country': (unicode, ''),
    'zip': (unicode, ''),
    'isGoogleHood': (bool, False),
    'usingDefaultZip': (bool, False),
    'unformatted': (unicode, u''),
    'display': (unicode, u''),
    'longitude': (float, None),
    'latitude': (float, None),
    'min_longitude': (float, None),
    'min_latitude': (float, None),
    'max_longitude': (float, None),
    'max_latitude': (float, None),
    'poly': (lambda p: [(float(x), float(y)) for (x, y) in p], None),
    'language': (unicode, None),
    'accuracy': (float, None),
    'provenance': (unicode, None),
    }

def sanitize(loc):
    """
    Take something that might resemble a "location dictionary" and
    convert it into a "location dictionary", by putting coercing
    existing fields to their types and stubbing missing fields with
    default values.
    """
    loc = dict(loc)
    for name, (coerce_fn, default_value) in LOC_FIELD_TYPES.iteritems():
        if (name in loc) and (loc[name] is not None):
            loc[name] = coerce_fn(loc[name])
        else:
            loc[name] = default_value
    # Repair the accuracy as it is often wrong.
    loc['accuracy'] = infer_accuracy(loc)
    return loc

def infer_accuracy(loc):
    """
    Returns the max of either the location dictionary's stated
    accuracy or the inferred minimum accuracy.
    """
    return max(infer_minimum_accuracy(loc), loc.get('accuracy', Accuracy.UNKNOWN_LOCATION))

def infer_minimum_accuracy(loc):
    """
    Infers the minimum accuracy for a location dictionary by
    inspecting the fields that the location dictionary contains.
    """
    if loc.get('accuracy') == Accuracy.AIRPORT:
        return Accuracy.AIRPORT
    elif loc.get('address1') or loc.get('address2') or loc.get('address3'):
        return Accuracy.STREET
    elif loc.get('zip'):
        return Accuracy.ZIPCODE
    elif loc.get('neighborhood'):
        return Accuracy.NEIGHBORHOOD
    elif loc.get('city'):
        return Accuracy.TOWN
    elif loc.get('county'):
        return Accuracy.COUNTY
    elif loc.get('state'):
        return Accuracy.REGION
    elif loc.get('country'):
        return Accuracy.COUNTRY
    else:
        return Accuracy.UNKNOWN_LOCATION

def truncate_lnglat(loc, places):
    if loc is None:
        return None
    else:
        loc = dict(loc)
        loc['longitude'] = round(loc['longitude'], places)
        loc['latitude'] = round(loc['latitude'], places)
        return loc
