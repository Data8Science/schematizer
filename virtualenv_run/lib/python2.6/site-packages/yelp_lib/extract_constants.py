#!/usr/bin/python
"""Evaluate the given config module, and print out a file containing all
the data structure in the file. This allows us to import external functions
and run computationally intensive operations in our configs.

This handles basic data structures and data types, and regexes

Constants whose name starts with '__' will be ignored (except as below)

If there is a list named '__all__' or '__show__' in the original file,
only print out constants appearing in that list. '__all__' will also be
included in the final file

If there is a sequence named '__hide__' in the original file, don't print
out constants in that list. This is mostly useful for hiding temporary variables
used for iteration (so you don't have to say [__i for __i in ...])
"""
import pprint
import re
import sys
from optparse import OptionParser
import time


# TODO: move this out of yelp_lib and to some other package.


# don't recurse farther than this into data structures
DEFAULT_MAX_DEPTH = 10

def is_basic(x, max_depth=DEFAULT_MAX_DEPTH):
    """ Returns a tuple. The first value is a boolean indicating
    whether the value is of a 'basic' type. The second value, if
    the first value is False, is the first type encountered which
    was not 'basic' (otherwise the second value is None). """
    if max_depth <= 0:
        return False, None
    if x is None:
        return True, None
    elif type(x) in (bool, int, long, float, str, unicode):
        return True, None
    # we support regexes
    elif type(x) == re._pattern_type:
        return True, None
    elif type(x) in (tuple, list, set, frozenset):
        return all(is_basic(item, max_depth-1) for item in x), None
    elif type(x) == dict:
        return all(is_basic(k, max_depth-1) and is_basic(v, max_depth-1) for (k,v) in x.iteritems()), None
    else:
        return False, type(x)

def extract_constants(module, max_depth=DEFAULT_MAX_DEPTH):
    """Get all the constants out of a module. Ignore things that
    aren't basic data types, or whose names start with '__'"""
    constants = {}

    # explicitly hide or show constants
    all_symbol = set(getattr(module, '__all__', []))
    show = all_symbol or set(getattr(module, '__show__', []))
    hide = set(getattr(module, '__hide__', []))

    for name, value in module.__dict__.iteritems():
        if ((name.startswith('__') or
            (show and name not in show) or
            (hide and name in hide))):
            continue

        basic, not_basic_type = is_basic(value)
        if basic:
            constants[name] = value
        else:
            print >> sys.stderr, 'WARNING: "%s" does not have a basic value -- found %r' % (name, not_basic_type)

    if all_symbol:
        constants['__all__'] = sorted(all_symbol)

    return constants

def pprint_constants(constants, out):
    """Print out the dictionary of constants on the command line."""
    print >> out, "# -*- coding: utf-8 -*-"
    print >> out, "# This file was autogenerated by tools/extract_constants.py in yelp_lib"
    print >> out, "# Please don't edit it by hand."

    if any(type(v) == re._pattern_type for v in constants.itervalues()):
        print >> out, 'import re'

    for (name, value) in sorted(constants.iteritems()):
        print >> out
        # pprint doesn't handle regexes
        if isinstance(value, re._pattern_type):
            print >> out, '%s = %s' % (name, repr_re_pattern(value))
        else:
            print >> out, name + ' = ',
            pprint.pprint(value, out)

def repr_re_pattern(pattern):
    """Print out an expression that evaluates to the given compiled regex"""
    assert isinstance(pattern, re._pattern_type)

    # figure out what flags, if any, are set
    flags = []
    # Industrial Light and Magic Sucks? Was that intentional?
    for flag in 'ILMSUX':
        flag_bit = getattr(re, flag)
        if flag_bit & pattern.flags:
            flags.append('re.%s' % flag)

    # Ticket #6274: it'd be awesome if we could print the pattern as a raw string
    if flags:
        return 're.compile(%r, %s)' % (pattern.pattern, ' | '.join(flags))
    else:
        return 're.compile(%r)' % (pattern.pattern)

def main():
    started_time = time.time()

    parser = OptionParser()
    parser.add_option('-o', "--output-filename", dest="out_filename", default="", help="Name of file to output to (default is stdout)")

    opts, args = parser.parse_args()

    if not args:
        print >> sys.stderr, "Please specify at least one module to load."
        sys.exit(1)

    sys.path.append('.')

    if opts.out_filename:
        out = open(opts.out_filename, 'w')
    else:
        out = sys.stdout

    constants = {}

    for module_name in args:
        if module_name.endswith('.py'):
            module_name = module_name[:-3]
            module_name = module_name.replace('/', '.')
        __import__(module_name)
        module = sys.modules[module_name]
        constants.update(extract_constants(module))

    pprint_constants(constants, out)

    print >> sys.stderr, 'time to extract constants: %is' % (time.time() - started_time)

if __name__ == '__main__':
    main()
