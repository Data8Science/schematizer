import datetime
from optparse import Option
from optparse import OptionParser
from optparse import OptionValueError
from optparse import Values
import re

#from yelp_lib import dates
#from util.crypto import InvalidEncryptedId
#from yelp.core import encapsulation
#from yelp.util.safeeval import safeeval
from .containers.dicts import filter_by_keys
#from .containers import lists

#
# TODO(spatel) Temporarily support --date only in yelp_lib. Needed to fix kolrabi report batch breakage.
#

# match time deltas like '1d5m' or '5 hours, 2.5 seconds'
TIMEDELTA_DHMS_RE = re.compile(
    r'^\s*'
    r'(?P<negative>-)?'
    r'((?P<days>\d+(\.\d+)?)\s*(d|days?))?'
    r',?\s*((?P<hours>\d+(\.\d+)?)\s*(h|hours?))?'
    r',?\s*((?P<minutes>\d+(\.\d+)?)\s*(m|minutes?))?'
    r',?\s*((?P<seconds>\d+(\.\d+)?)\s*(s|secs?|seconds?))?'
    r'\s*$')


# match the format produced by timedelta.__str__, which attaches
# the negative sign to days only
TIMEDELTA_STR_RE = re.compile(r'^\s*'
                              r'((?P<days>-?\d+)\s*days?,\s*)?'
                              r'(?P<hours>\d?\d):(?P<minutes>\d\d)'
                              r':(?P<seconds>\d\d+(\.\d+)?)'
                              r'\s*$')


# Add 'date', 'timedelta', 'iterable', and 'id_list' types to OptionParser:
def parse_date(a_date):
    """Parse a date string

    Arguments:
    a_date -- string, a date specified either like 'today', 'yesterday' or
    '2009-11-11'

    Returns:
    a date
    """
    if a_date.lower() in ['today', 'now']:
        return datetime.date.today()
    elif a_date.lower() == 'yesterday':
        return datetime.date.today() - datetime.timedelta(days=1)
    elif a_date.lower().endswith(' days ago'):
        num = int(a_date.split(' ', 1)[0])
        return datetime.date.today() - datetime.timedelta(days=num)
#	elif a_date.lower().endswith(' months ago'):
#		months = int(a_date.split(' ', 1)[0])
#		return dates.months_ago(datetime.date.today(), months)
    else:
        return datetime.date(*map(int, a_date.split('-', 3)))


def check_date(option, opt, value):
    try:
        return parse_date(value)
    except ValueError:
        raise OptionValueError("option %s: unexpected date: %r" % (opt, value))


#def parse_timedelta(value):
#	"""Convert a string to a timedelta. We accept formats like:
#
#	1d5m
#	5 hours, 2.5 seconds
#	10:05:02
#	2 days, 6:00:00
#
#	This should be able to parse any datetime.timedelta that was converted
#	to a string with str() (that's the format with colons)
#
#	You can only put negative signs the beginning; so for example, -1d12h
#	means 36 hours ago. However, somewhat confusingly, -1 day, 12:00:00
#	means 12 hours ago, for consistency with str(timedelta(...)).
#
#	Raise a ValueError if it's not a format we recognize.
#	"""
#	match = TIMEDELTA_DHMS_RE.match(value)
#
#	if not match:
#		match = TIMEDELTA_STR_RE.match(value)
#
#	if not match:
#		raise ValueError()
#
#	timedelta_kwargs = dict((k, float(v))
#							for k, v in match.groupdict().iteritems()
#							if k != 'negative' and v is not None)
#
#	if not timedelta_kwargs:
#		raise ValueError()
#
#	sign = -1 if match.groupdict().get('negative') else 1
#
#	return sign * datetime.timedelta(**timedelta_kwargs)


#def check_timedelta(option, opt, value):
#	"""A wrapper for parse_timedelta() that issues an approriate
#	OptionValueError for strings we can't parse"""
#	try:
#		return parse_timedelta(value)
#	except ValueError:
#		raise OptionValueError("option %s: unexpected timedelta: %r" % (opt, value))


#def parse_iterable(option, opt, value):
#	"""
#	Parses the iterable command line option.
#	"""
#	if value is None:
#		return None
#
#	try:
#		parsed_iterable_option = safeeval(value)
#	except SyntaxError:
#		# Encrypted IDs can be invalid syntax if you try to eval them...check and pass them through as strings if so
#		if encapsulation.is_valid_id(value):
#			parsed_iterable_option = value
#		else:
#			raise OptionValueError("option %s: invalid iterable definition: %r" % (opt, value))
#	except NameError:
#		# If you pass in just a valid identifier name, it will try to parse it and probably not be able to find the var
#		parsed_iterable_option = value
#
#	return lists.relist(parsed_iterable_option)


#def parse_id_list(option, opt, value):
#	"""Return a list of encrypted IDs from a command line option"""
#	if value is None:
#		return None
#
#	try:
#		id_list = parse_iterable(option, opt, value)
#		return encapsulation.objectidify(id_list)
#	except (InvalidEncryptedId, OptionValueError):
#		raise OptionValueError("option %s: invalid ID list definition: %r" % (opt, value))


class CustomOption(Option):
    TYPES = list(Option.TYPES) + ['date', 'iterable', 'id_list', 'timedelta']
    TYPE_CHECKER = Option.TYPE_CHECKER.copy()
    TYPE_CHECKER['date'] = check_date
    #TYPE_CHECKER['iterable'] = parse_iterable
    #TYPE_CHECKER['id_list'] = parse_id_list
    #TYPE_CHECKER['timedelta'] = check_timedelta


def get_option_parser(option_class=CustomOption, **kwargs):
    '''
    Returns an OptionParser instance. Currently includes our fancy-shmancy option class with some new types added by default.
    '''
    return OptionParser(option_class=option_class, **kwargs)


class OptionArguments(object):
    @classmethod
    def regenerate(self, opt_parser, option_dict, destinations=[]):
        if isinstance(option_dict, Values):
            option_dict = option_dict.__dict__

        working_option_dict = option_dict
        if destinations:
            working_option_dict = filter_by_keys(option_dict, destinations)

        output_list = []
        opt_dest_map = {}
        for option_group in [opt_parser] + opt_parser.option_groups:
            opt_dest_map.update((opt.dest, opt) for opt in option_group.option_list)

        for opt_dest, opt_val in working_option_dict.iteritems():
            current_option = opt_dest_map.get(opt_dest)

            # If we don't know anything about this destination or the opt value is None, don't do anything
            if not current_option or opt_val is None:
                continue

            # Retrieve the list of arguments for this storage type... append this to the output list
            action_fxn = getattr(OptionArguments, "_handle_action_%s" % current_option.action)
            fxn_arglist = action_fxn(current_option, opt_val)
            output_list.extend(fxn_arglist)

        return output_list

    @classmethod
    def __convert_value_to_string(self, opt_type, opt_val):
        """Convert a raw value to something we can represent on the cmd line"""
        if opt_type in ['int', 'long', 'float', 'string', 'choice']:
            return str(opt_val)
        elif opt_type == 'date':
            return str(opt_val)
        elif opt_type == 'complex':
            # Strip parans
            complex_string = str(opt_val)
            return complex_string.replace('(', '').replace(')', '')
        else:
            raise ValueError("Unknown type: %s" % opt_type)

    @classmethod
    def _handle_action_store(self, opt_def, opt_val):
        if not opt_val:
            return []

        # Lets make sure this is a list
        final_option_values = [opt_val] if opt_def.nargs == 1 else opt_val
        option_prefix = opt_def.get_opt_string()
        output_list = [option_prefix]
        output_list.extend(self.__convert_value_to_string(opt_def.type, each_val) for each_val in final_option_values)
        return output_list

    @classmethod
    def _handle_action_append(self, opt_def, opt_vals):
        """Action append essentially is a repeated version of _handle_action_store"""
        output_list = []
        for val in opt_vals:
            output_list.extend(self._handle_action_store(opt_def, val))

        return output_list

    @classmethod
    def _handle_action_store_const(self, opt_def, opt_val):
        """For constants, we don't need to pass anything back since the OptionParser parameter keeps the constant"""
        return [opt_def.get_opt_string()]

    @classmethod
    def _handle_action_store_true(self, opt_def, opt_val):
        """For constants, we don't need to pass anything back since the OptionParser parameter keeps the constant"""
        if opt_val != True:
            return []

        return [opt_def.get_opt_string()]

    @classmethod
    def _handle_action_store_false(self, opt_def, opt_val):
        """For constants, we don't need to pass anything back since the OptionParser parameter keeps the constant"""
        if opt_val != False:
            return []

        return [opt_def.get_opt_string()]

    @classmethod
    def _handle_action_count(self, opt_def, opt_val):
        """Return this repeated counter"""
        option_prefix = opt_def.get_opt_string()
        return [option_prefix for i in xrange(opt_val)]

    @classmethod
    def _handle_action_callback(self, opt_def, opt_val):
        raise NotImplementedError
