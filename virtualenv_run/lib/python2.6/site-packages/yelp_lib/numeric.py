"""
Utility functions that manipulate numbers.

Don't add functions that format numbers for display to this file. Chances are
they're not general enough (and i18n-friendly enough) to belong here.
"""
from __future__ import division

import decimal
import math

from .arguments import max_not_none
from .arguments import min_not_none

def float_equal(a, b, tolerance=1e-6):
    """Return True iff a and b are equal within `tolerance`"""
    return abs(a-b) <= tolerance


def float_le(a, b, tolerance=1e-6):
    """Return True iff a < b beyond `tolerance`"""
    return a + tolerance < b


def float_ge(a, b, tolerance=1e-6):
    """Return True iff a > b beyond `tolerance`"""
    return a > b + tolerance


def float_leq(a, b, tolerance=1e-6):
    """Return True iff a <= b within `tolerance`"""
    return a <= b + tolerance


def float_geq(a, b, tolerance=1e-6):
    """Return True iff a >= b within `tolerance`"""
    return a + tolerance >= b


def get_decimal(x, default):
    """Return Decimal(x), or default if Decimal(x) failed"""
    try:
        return decimal.Decimal(x)
    except:
        return default


def get_int(x, default):
    """Return int(x), or default if int(x) failed"""
    try:
        return int(x)
    except:
        return default


def get_float(x, default):
    """Return float(x), or default if float(x) failed"""
    try:
        return float(x)
    except:
        return default


def safe_div(a, b, default=0.0):
    """Divide safely, returns default when b == 0"""
    if b == 0:
        return default
    return float(a)/float(b)


def percent(a, b, default=0.0):
    """Return a/b as a float representing a percentage,
    or default if b is 0"""
    if not b:
        return default
    return float(100 * a) / float(b)


def formatted_percent(a, b, precision=0, default=0.0):
    """Return a/b as a formatted whole number percent
    string or default if b is 0"""
    if not b:
        return default
    return format_percent(float(a) / float(b), precision)


def percent_change(new, old, default=float('inf')):
    """Return the percentage change between the old and new value"""
    # TODO: would be more correct to return -inf, NaN, or inf as appropriate
    if not old:
        return default
    return 100 * float(new - old) / abs(float(old))


def format_percent(value, precision=0):
    """
    Return a formatted whole number percent string given a numeric value.

    As a special case, if value is None, the method will return "N/A".

    Arguments:
      value - the value.
      precision - the number of digits after the decimal point to display.

    example:
        format_percent(.5)  ->  '50%'
        format_percent(.24512312, 2) -> '24.51%'
        format_percent(None) -> 'N/A'
    """
    if value is None:
        return "N/A"
    # XXX(sumeet): It's dangerous that this behaves differently when passed a
    # `Decimal`.
    elif isinstance(value, (float, int)):
        value *= 100.0

    if precision > 0:
        return "%s%%" % round(value, precision)
    else:
        # round(1.0, 0) returns 1.0, so we need to fix it.
        return "%s%%" % int(round(value, precision))


class Percent(object):
    """A mathematical percentage.

    Encapsulates percentage display and arithmetic. If you're worried
    precision, use a Decimal.
    """

    def __init__(self, percentage):
        """Create a new `Percent` with `percentage`, preserving its precision.

        `Percent(1) is the same as '100%', and arithmetic will be performed
        using the integer value that was passed in. Likewise, `Percent(100)` is
        the same as '10000%'.

        `Percent(0.20)` is the same as '20%' and arithmetic will be performed
        with the `float` object that was passed in, `0.20`.

        `Percent(decimal.Decimal('0.20'))` would be the way to preserve decimal
        precision.
        """
        self.percentage = percentage

    @classmethod
    def from_percent(cls, value):
        """Return a new `Percent` from `value` per cent. In otherwords, the
        part before the '%' sign.

        If `value` is an integer, it'll create a new `Percent` with a `float`
        percentage.

        >>> Percent.from_percent(100)
        'Percent(1.0)'
        >>> Percent.from_percent(1)
        'Percent(0.01)'
        >>> Percent.from_percent(decimal.Decimal('100.0'))
        'Percent(Decimal('1.0'))
        """
        return cls(value / 100)

    def format(self, precision):
        """Return a string representation of this `Percent` with `precision`
        places after the decimal point.
        """
        if isinstance(self.percentage, decimal.Decimal):
            # XXX(sumeet): It's dangerous that `format_percent` behaves
            # differently when passed a `Decimal`.
            percentage = self.percentage * 100
        else:
            percentage = self.percentage

        return format_percent(percentage, precision)

    def __str__(self):
        """Return a string representation of this `Percent`, but round to zero
        decimal places unless the underlying value is a `Decimal`. If it's a
        `Decimal`, then use its precision.
        """
        if isinstance(self.percentage, decimal.Decimal):
            decimal_tuple = self.percentage.as_tuple()
            if decimal_tuple.exponent < 0:
                prec_after_decimal = (-1 * decimal_tuple.exponent)
            else:
                prec_after_decimal = 0

            # XXX(sumeet): It's dangerous that `format_percent` behaves
            # differently when passed a `Decimal`.
            return format_percent(self.percentage * 100, prec_after_decimal)

        return format_percent(self.percentage)

    __repr__ = lambda self: 'Percent(%r)' % self.percentage

    @property
    def complement(self):
        return type(self)(1 - self.percentage)

    def __mul__(self, value):
        return self.percentage * value

    def __eq__(self, percent):
        return self.percentage == percent.percentage


def round_down_to_int(value):
    """ Truncates a float to an int, handling negative numbers correctly (-.05 goes to -1) """
    if value >= 0:
        return int(value)
    return int(value) - 1


from collections import namedtuple

Frexped = namedtuple('Frexped', 'mantissa exponent')


def frexp10(n):
    """Split a number into a mantissa and base 10 exponent."""
    exp = int(math.floor(math.log10(n)))
    return Frexped(mantissa=n / 10 ** exp, exponent=exp)


class RoundsSigFigs(object):

    def __init__(self, value, sigfigs, rounding_function):
        if not isinstance(sigfigs, (int, long)):
            raise TypeError('sigfigs must be an integer')
        if sigfigs < 1:
            raise ValueError('sigfigs must be at least 1')

        self._value = value
        self._sigfigs = sigfigs
        self._rounding_function = rounding_function

    def round(self):
        if self._value == 0:
            return 0
        rounded = math.copysign(self._mantissa * 10 ** self._exponent,
                                self._value)
        return int(rounded) if isinstance(self._value, (int, long)) else rounded

    @property
    def _exponent(self):
        return frexp10(abs(self._value)).exponent - self._sigfigs + 1

    @property
    def _mantissa(self):
        return self._rounding_function(abs(self._value) * 1.0 /
                                       10 ** self._exponent)


def round_to_sigfigs(value, sigfigs=1):
    """Round a value to the given number of significant digits.

    >>> round_to_sigfigs(234, 2)
    230
    >>> round_to_sigfigs(1.2, 1)
    1.0
    >>> round_to_sigfigs(0.15, 1)
    0.1
    """
    return RoundsSigFigs(value, sigfigs, round).round()


def truncate_to_sigfigs(value, sigfigs):
    return RoundsSigFigs(value, sigfigs, math.trunc).round()


def mean(xs):
    """Get the arithmetic mean of a sequence. Other types of means (geometric,
    harmonic, etc.) are strictly prohibited by the bylaws of the Yelp Developer
    Agreement, section 14.F.3.4.
    """
    if xs:
        return sum(xs) / float(len(xs))


def safe_mean(iterable, default=0.0):
    """Return the mean of an iterable of numbers, defaulting to 0.0 if
    the iterable contains no numbers.
    """
    total = 0.0
    count = 0

    for item in iterable:
        try:
            total += item
            count += 1
        except ValueError:
            pass

    if count:
        return total / count
    else:
        return default

def weighted_avg(*values_and_weights):
    """Get the weighted average of several values, given pairs of
    value, weight.

    >>> weighted_avg((1, 1), (2, 1), (4, 2))
    2.75

    If the weights add up to zero, or any value or weight is None, we return
    None.
    """
    total_value = 0
    total_weight = 0

    for value, weight in values_and_weights:
        if value is None or weight is None:
            return None
        total_value += value * weight
        total_weight += weight

    if total_weight == 0:
        return None

    return 1.0 * total_value / total_weight


def median(values):
    """Calculate the median of an (unsorted) list of `values`"""
    return median_sorted_values(sorted(values))


def median_sorted_values(sorted_values):
    """Given a sorted list, return the median."""
    return percentile(sorted_values, 50)


def stddev(xs, population=True):
    mu = mean(xs)
    denominator = float(len(xs) if population else len(xs) - 1)
    return math.sqrt(safe_div(sum((mu - x)**2 for x in xs), denominator))


def percentile(sorted_values, percent, count=None):
    """Return the given percentile of the list of sorted (numeric) values.

    percentile(sorted_values, 50) gives median.
    percentile(sorted_values, 100) gives max.
    """
    if count is None:
        count = len(sorted_values)

    if count == 0:
        return None

    index = percent / 100.0 * (count - 1)

    if index <= 0:
        return sorted_values[0]

    if index >= count - 1:
        return sorted_values[-1]

    lo_index = int(math.floor(index))
    hi_index = int(math.ceil(index))
    weight = index - lo_index

    lo = sorted_values[lo_index]
    hi = sorted_values[hi_index]

    if lo == hi:
        return lo # don't introduce rounding errors if we don't need to
    else:
        return lo * (1 - weight) + hi * weight


def clamp(lowbound, value, highbound):
    """Return value bounded by the provided low and high values"""
    assert lowbound <= highbound, '%s is not <= %s' % (lowbound, highbound)
    return min(highbound, max(lowbound, value))


def clamp_ignore_none(lowbound, value, highbound):
    """Return value bounded by the provided low and high values -- none values have no affect"""
    if value is None:
        raise ValueError("Cannot clamp None")
    return min_not_none(highbound, max_not_none(lowbound, value))


def coalesce_intervals(intervals):
    """Given a list of integer intervals represented as
    2-tuples, coalesce them into the minimum set of intervals.

    Throws a ValueError if the passed in intervals are not
    valid.  (5, 1) is an example of an invalid interval because
    the start is greater than the end.

    Ex. [(3,4), (5, 9), (6,7), (1,3), (10, 10)] -> [(1,4), (5,9)]
    """

    starts = [s for (s, e) in intervals]
    starts.sort()
    ends = [e for (s, e) in intervals]
    ends.sort()

    result = []
    interval_depth = 0
    start = 0

    while starts and ends:
        next_s = starts[0]
        next_e = ends[0]

        if next_s == next_e:
            starts.pop(0)
            ends.pop(0)
            continue

        if next_s < next_e:
            starts.pop(0)
            interval_depth += 1
            if interval_depth == 1:
                start = next_s
        else:
            ends.pop(0)
            interval_depth -= 1
            if interval_depth == 0:
                result.append((start, next_e))
            elif interval_depth < 0:
                raise ValueError, "Intervals are unbalanced."

    if ends:
        result.append((start, ends[-1]))

    if starts:
        raise ValueError, "Intervals are unbalanced."

    return result


def count_bits(x):
    """Counts the number of bits set to one in an unsigned number"""
    assert x >= 0
    c = 0
    while x:
        c += 1
        x &= x - 1 # flip the least significant bit that is set to one
    return c


def moving_avg_with_removal(day_items, days_in_moving_avg):
    """Compute a moving average of values where only the morecent value for each user at one
    time counts.

    This is useful for the review update feature where we we only want to have a
    user's most recent rating affect the average rating at a point in time.

    Args:
        day_items -- [(day, user, value)], a list of: day, the user that voted,
        and the vote value
        days_in_moving_avg -- int, the number of days in each moving average
    Returns:
        {day: moving average value for that day}
    """
    day_to_avg = {}

    # Make sure we have a list
    day_items = list(day_items)

    if not day_items:
        return day_to_avg

    # Reverse the list of items here so that we can consider only a user's most recent
    # vote efficiently
    day_items.sort(reverse=True)

    # Get a sequence of days we want
    days = set(day for day, _, _ in day_items)

    # For each day in day items, calculate moving average for that day
    # this should run in # days*# items
    for day in days:
        users_seen = set()
        num = 0
        total = 0
        # for each day, user, value in day_items add it to the running total and
        # number of items
        for day_, user, value in day_items:
            if not ((day - days_in_moving_avg) <= day_ <= day):
                continue
            if user in users_seen:
                continue
            else:
                users_seen.add(user)
            total += value
            num += 1
        if num > 0:
            day_to_avg[day] = float(total) / num
    return day_to_avg


def chunk(total_length, chunk_size):
    """Return an iterator containing integers of `chunk_size` or less that sum
    to `total_length`.

    >>> list(chunk(31, 10))
    [10, 10, 10, 1]
    """
    return (
        min(chunk_size, total_length - i)
        for i in xrange(0, total_length, chunk_size)
    )
