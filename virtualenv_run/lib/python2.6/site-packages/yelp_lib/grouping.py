"""
Utility methods for grouping items from sequences in various ways.
"""
import itertools
import types


def segment(x, n):
    """iterate over building n length segments from x"""
    if n <= 0:
        raise ValueError, n

    # for lists and tuples, slicing is most efficient
    if isinstance(x, (types.ListType, types.TupleType)):
        i = 0
        c = len(x)

        while i < c:
            yield x[i:i+n]
            i += n

    # special case for dicts, return dicts
    elif isinstance(x, types.DictType):
        for seg in segment(x.iteritems(), n):
            yield dict(seg)

    elif isinstance(x, types.FileType):
        while True:
            seg = list(itertools.islice(x, n))
            if not seg:
                return
            yield seg

    # otherwise, just build tuples bit by bit
    else:
        seg = []
        for item in x:
            seg.append(item)
            if len(seg) >= n:
                yield seg
                seg = []
        if seg:
            yield seg

def segment_degenerates(x, n):
    """Like segment, but if x is empty then one segment (containing x or []) is returned."""
    if x is None:
        return iter([[]])
    if len(x) == 0:
        return iter([x])
    return segment(x, n)

def segment_cols(l, n):
    """iterate over building n number of segments (columns) from l"""
    if n <= 0:
        raise ValueError, n
    if n == 1:
        return [l]

    out = []
    seg_len = len(l) / n
    c = len(l) % n
    start = 0
    end = start + seg_len

    while n > 0:
        if c > 0:
            m_end = end + 1
            c = c - 1
            out.append(l[start:m_end])
            end = m_end
        else:
            out.append(l[start:end])

        start = end
        end = end + seg_len
        n = n - 1

    return out


NOT_NONE = lambda x: x is not None
ALWAYS_TRUE = lambda x: True
IDENTITY = lambda x: x


def group_by_key(items, key, key_filter=NOT_NONE, multi_key=False,
                 val_func=IDENTITY, val_filter=NOT_NONE,
                 into=list, add='append'):
    """Replace code like this:

    user_to_reviews = {}
    for review in reviews:
        user_to_reviews.setdefault(review['user_id'], [])
        user_to_reviews[review['user_id']].append(review)

    with this:

    user_to_reviews = group_by_key(reviews, 'user_id')

    See test cases for more examples.

    Args:
    items -- dicts/lists/tuples to group (really anything that supports the
        [] operator)
    key -- a key found in all dicts/lists/tuples to group by
    key_filter, multi_key, val_func, into, add, filter -- same meaning as in
        group_by()

    Returns:
    (By default) a map from key to list of items matching that key (or similar)
    """
    return group_by(
        items, key_func=lambda d: d[key], key_filter=key_filter,
        multi_key=multi_key, val_func=val_func, val_filter=val_filter,
        into=into, add=add)


def group_field_by_key(items, field, key, key_filter=NOT_NONE,
                       multi_key=False, val_filter=NOT_NONE,
                       into=list, add='append'):
    """Replace code like this:

    user_to_biz_ids = {}
    for review in reviews:
        user_to_biz_ids.setdefault(review['user_id'], set())
        user_to_biz_ids[review['user_id']].add(review['business_ids'])

    with this:

    user_to_biz_ids = group_field_by_key(reviews, 'business_id', 'user_id')

    Also, you can replase code like this:

    key_to_values = {}
    for key, value in pairs:
        key_to_values.setdefault(key, [])
        key_to_values[key].append(value)

    with:

    key_to_values = group_field_by_key(pairs, 1, 0)

    See test cases for more examples.

    Args:
    items -- dicts/lists/tuples to group (really anything that supports the
        [] operator)
    field -- field whose value we want to keep
    key -- key in dict/list/tuple to group by
    key_filter, multi_key, val_filter, into, add, filter -- same meaning as in
        group_by().

    Returns:
    (By default) a map from key to set of field values matching that key
    """
    return group_by_key(
        items, key, key_filter=key_filter, multi_key=multi_key,
        val_func=lambda d: d[field], val_filter=val_filter,
        into=into, add=add)


def group_by(items, key_func, key_filter=NOT_NONE, multi_key=False,
                  val_func=IDENTITY, val_filter=NOT_NONE,
                  into=list, add='append'):
    """Group a bunch of items by key. The engine for the other group_by()
    functions.

    Args:
    items -- items to group
    key_func -- run this on an item to get the key to group by
    key_filter -- only keep keys if filter(key_func(item)) is True.
        Default is to filter out None values; you can disable the filter
        by setting it to lambda x: True
    multi_key -- if True, key_func actually returns a list (or other
        container) of keys. In this case, key_filter is applied to
        each key individually. If key_func returns None, it will be ignored.
    val_func -- run this on an item before adding it to the container for
        a particular key. Default is identity function.
    val_filter -- only keep items if filter(val_func(item)) is True.
        Default is to filter out None values; you can disable the filter
        by setting it to lambda x: True
    into -- kind of data structure to contain items matching a key
    add -- name of function to add items to the data structure (e.g. 'append'
        for a list, 'add' for a set). You could use 'extend'/'update'
        as well.

    Returns:
    (By default) a map from key to list of items matching that key
    """

    result = {}
    for item in items:
        # figure out keys
        if multi_key:
            key_vals = key_func(item) or () # safely handle None
        else:
            key_vals = (key_func(item),)

        # figure out value, and filter
        value = val_func(item)
        if not val_filter(value):
            continue

        for key_val in key_vals:
            # filter keys
            if not key_filter(key_val):
                continue

            # add value to the list (or whatever) for that key
            if key_val not in result:
                result[key_val] = into()
            getattr(result[key_val], add)(value)

    return result

