# -*- coding: utf-8 -*-
"""Utilities for handling IP addresses.

.. deprecated:: 9.1.0
   Use the ipaddress package directly.
.. deprecated:: 6.0.8
   (backport for yelp-main)
"""
import itertools
import random

import ipaddress


def _ip_address(ip):
    if isinstance(ip, basestring):
        # ipaddress library requires unicode, not bytestrings
        ip = unicode(ip)
    return ipaddress.ip_address(ip)

def inet_aton(ip):
    """Get an int representation of an ip address.

    :param ip: bytestring, unicode, int, or ipaddress representation of an ip
    :returns: int
    """
    return int(_ip_address(ip))

def inet_ntoa(ip):
    """Get a string representation of an ip address.

    :param ip: bytestring, unicode, int, or ipaddress representation of an ip
    :returns: string
    """
    return str(_ip_address(ip))


def inet_ntoa_safe(ip):
    """Get a string representation of an ip address.

    Will not convert if it's already a string.

    If the given value is not a value ip address,
    it will be returned as it was passed in.

    :param ip: bytestring, unicode, int, or ipaddress representation of an ip
    :returns: string
    """
    try:
        return inet_ntoa(ip)
    except ValueError:
        return ip

def inet_aton_safe(ip):
    """Get an int representation of an ip address.

    Will not convert if it's already an int.

    :param ip: bytestring, unicode, int, or ipaddress representation of an ip
    :returns: int
    """
    if isinstance(ip, (basestring, ipaddress._BaseAddress)):
        return inet_aton(ip)
    else:
        return ip


class Cidr(object):
    """Compatibility layer for IPv(4/6)Network.

    This is used instead of IPv(4/6)Network directly for
    backwards compatibility concerns.
    When iterating over this object, we need string IPs,
    as opposed to IPv4Addresses.

    .. deprecated:: 9.1.0
       Use IPv4Network/IPv6Network directly.
    .. deprecated:: 6.0.8
        (backport for yelp-main)
    """

    def __init__(self, addr, subnet=None):
        """Backwards compatible constructor.

        :param addr: An individual address or a network
            192.168.1.1, or 192.168.1.0/24
        :param subnet: If you don't include the prefix length, include it here
        """
        network = unicode(addr)
        if subnet is not None:
            network = u"{addr}/{subnet}".format(
                addr=addr, subnet=subnet)
        self._network = ipaddress.ip_network(network)

    def __iter__(self):
        for x in self._network:
            yield str(x)

    def __len__(self):
        return self._network.num_addresses

    def __getitem__(self, i):
        return self._network[i]

    def __str__(self):
        return str(self._network)

    def __int__(self):
        return int(self._network)

    def __eq__(self, other):
        if isinstance(other, Cidr):
            return self._network == other._network
        raise ValueError("Can't compare Cidr to non-Cidr")

    def __hash__(self):
        # This keeps Cidrs from hashing the same as IPv(4/6)Networks
        return hash((Cidr, self._network))


def parse_cidr(cidr):
    """Backwards compatible Cidr constructor.

    .. deprecated:: 9.1.0
       Use IPv4Network/IPv6Network.
    .. deprecated:: 6.0.8
        (backport for yelp-main)
    """
    return Cidr(cidr)


class CidrSet(object):
    """A wrapper class over SubnetTree that allows for iterating over the list
    and generating random ips from the list.

    .. deprecated:: 9.1.0
       Use IPv4Network/IPv6Network directly,
       or SubnetTree if you need the performance characteristics of
       discontigious IP networks (such as internal IP ranges at Yelp).
       If you need the set features in this class,
       please either implement your own,
       or submit a feature request.
    .. deprecated:: 6.0.8
        (backport for yelp-main)

    >>> cidr_set = CidrSet()
    >>> cidr_set.add_cidr('67.202.0.0/18')
    >>> cidr_set.add_cidr('72.44.32.0/19')
    >>> cidr_set.add_cidr('72.44.31.43')
    >>> '67.202.0.0' in cidr_set
    True
    >>> '67.202.1.100' in cidr_set
    True
    >>> '72.45.32.0' in cidr_set
    False
    >>> '72.44.31.43' in cidr_set
    True
    """

    def __init__(self, cidrs=None):
        import SubnetTree
        self._subnet_tree = SubnetTree.SubnetTree()
        self._cidr_set = set()
        for cidr in cidrs or ():
            self.add_cidr(cidr)

    @property
    def cidr_list(self):
        return map(str, self._cidr_set)

    def add_cidr(self, cidr):
        cidr = parse_cidr(cidr)
        if cidr in self._cidr_set:
            return
        self._cidr_set.add(cidr)
        self._subnet_tree[str(cidr)] = True

    def __contains__(self, key):
        addr = _ip_address(key)
        return str(addr) in self._subnet_tree

    def __len__(self):
        return len(list(self._cidr_set))

    def random_choice(self):
        cidr = random.choice(list(self._cidr_set))
        return random.choice(cidr)

    def ip_generator(self):
        """Iterates over all valid IPs in the ranges within this CidrSet."""
        return itertools.chain.from_iterable(self._cidr_set)

    def update_cidr(self, cidr_set):
        for cidr in cidr_set._cidr_set:
            self.add_cidr(cidr)

    def union(self, cidr_set):
        return type(self)(cidr_set._cidr_set | self._cidr_set)

    __or__ = union


def is_private_ip(ip):
    """Returns True if IP is in a private address range or a loopback IP
    (such as localhost).

    Checking for loopback is included here for backwards compatibility.

    :param ip: bytestring, unicode, int, or ipaddress representation of an ip
    """
    address = _ip_address(ip)
    return address.is_private or address.is_loopback


__all__ = ['inet_aton', 'inet_ntoa', 'inet_ntoa_safe', 'inet_aton_safe', 'CidrSet']
