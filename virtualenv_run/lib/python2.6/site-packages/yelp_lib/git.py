"""Python interface to Git operations."""

import logging
import os
import re
import subprocess


log = logging.getLogger(__name__)


MAX_OUTPUT_LENGTH = 1000000


class GitCommandError(Exception):
    """Raised when a git command fails."""
    pass


def build_command(command, *args):
    return [command] + filter(None, list(args))


def call_git(command, cwd=None):
    """Spawn a git subprocess to run a command, and return the results. Runs the
    command in the current directory. Should only be used for commands that
    don't care about a repo, like ls-remote."""
    proc = subprocess.Popen(['git'] + command,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
    stdout, stderr = proc.communicate()
    return proc.returncode, stdout, stderr


def handle_error(response, error_msg):
    """Handle a response from call_git(). If the return_code is Truthy,
    raise a GitCommandError, otherwise return the response. error_msg is
    formatted with context:
        {'return_code': ..., 'stdout': ..., 'stderr': ...}
    """
    return_code, stdout, stderr = response
    if return_code:
        context = {
            'return_code': return_code,
            'stdout': (stdout or '').strip(),
            'stderr': (stderr or '').strip()}
        raise GitCommandError(error_msg % context)
    return response


def handle_stdout(response):
    """Handle a response from call_git(). If there is stderr or a missing stdout
    return None, otherwise return the first word from stdout.
    """
    return_code, stdout, stderr = response
    if stderr or not stdout:
        return None
    return stdout.split()[0]


def handle_success(response, strip=True):
    """Handle a response from call_git(). If the command was successful return
    stdout, Otherwise return None.
    """
    return_code, stdout, stderr = response
    if return_code:
        log.warn("git command failed (%s): %s", return_code, stderr)
        return None
    return stdout.strip() if strip else stdout


def clone(repo_path, local_path=None):
    """Clone a git repository."""
    command = build_command('clone', repo_path, local_path)
    error_msg = "Git clone failed for %s: %%(stderr)s" % ' '.join(command)
    handle_error(call_git(command), error_msg)


class Git(object):
    """Interact with a git repository."""

    def __init__(self, repo_path=None):
        self.repo_path = repo_path or os.getcwd()

        if not os.path.exists(self.repo_path):
            raise IOError('Not a valid path: %s' % self.repo_path)

        # Get the toplevel path for this repository. We'll run all git
        # commands in the toplevel directory from now on.
        self.repo_path = self._get_toplevel_path()

    @classmethod
    def from_clone(cls, repo_path, local_path):
        """Create a Git object by cloning a repo repo."""
        clone(repo_path, local_path=local_path)
        return cls(repo_path=local_path)

    def _call_git(self, command):
        """Spawn a git subprocess to run a command, and return the results. Run
        the command with repo_path as the working directory.
        """
        return call_git(command, cwd=self.repo_path)

    def _get_toplevel_path(self):
        """Return the toplevel path of the current repository."""
        # If the repository is a bare repository we don't need to
        # (and shouldn't) do this. rev-parse command below will not
        # work in a bare repository.
        if self.is_bare():
            return self.repo_path

        command = ['rev-parse', '--show-toplevel']
        error_msg = 'Not a valid Git repository: %s' % self.repo_path
        _, stdout, _ = handle_error(self._call_git(command), error_msg)
        return stdout.strip()

    def is_bare(self):
        return self.config("core.bare") == "true"

    def fetch(self, remote='origin', ref=None, prune=True):
        command = ['fetch']
        if prune:
            command.append('--prune')
        if remote:
            command.append(remote)
            if ref:
                command.append(ref)
        rc, stdout, stderr = self._call_git(command)
        return rc == 0

    def pull(self, remote='origin', ref='HEAD'):
        command = ['pull']
        if remote and ref:
            command.append(remote)
            command.append(ref)
        rc, stdout, stderr = self._call_git(command)
        return rc == 0

    def config(self, key, value=None):
        """Get or set the contents of a git config key."""
        command = build_command('config', key, str(value) if value else None)
        rc, stdout, stderr = self._call_git(command)
        if value is None:
            return stdout.strip(os.linesep)
        else:
            return rc == 0

    def checkout(self, commit):
        """Checkout a branch, SHA, or tag."""
        error_msg = "Checkout failed (%(return_code)s): %(stderr)s"
        handle_error(self._call_git(['checkout', commit]), error_msg)

    def submodule_update(self, init=False):
        command = build_command('submodule', 'update', '--init' if init else None)
        error_msg = "%s failed %%(return_code)s: %%(stderr)s" % ' '.join(command)
        handle_error(self._call_git(command), error_msg)

    def current_branch(self):
        """Return the currently checked-out branch, if any."""
        rc, stdout, stderr = self._call_git(['name-rev', '--name-only', 'HEAD'])
        if stderr:
            return None
        if '~' in stdout:
            return None
        return stdout.strip()

    @classmethod
    def get_remote_head_sha(cls, ref, remote):
        """Get the SHA-1 for a given head on a given remote.
        Use this only if working outside a Git repo; otherwise,
        use remote_head_sha()."""
        return handle_stdout(call_git(['ls-remote', '-h', remote, ref]))

    @classmethod
    def get_remote_tag_sha(cls, ref, remote):
        """Get the SHA-1 for a given tag on a given remote.
        Use this only if working outside a Git repo; otherwise,
        use remote_tag_sha()."""
        return handle_stdout(call_git(['ls-remote', '-t', remote, ref]))

    def remote_head_sha(self, ref, remote='origin'):
        """Get the SHA-1 for a given head on a given remote."""
        return handle_stdout(self._call_git(['ls-remote', '-h', remote, ref]))

    def remote_tag_sha(self, ref, remote='origin'):
        """Get the SHA-1 for a given tag on a given remote."""
        return handle_stdout(self._call_git(['ls-remote', '-t', remote, ref]))

    def sha(self, ref):
        """Get the SHA-1 for a given local ref."""
        return handle_success(self._call_git(['rev-parse', '--verify', '--quiet',  ref]))

    def merge_base(self, ref1='origin/master', ref2='HEAD'):
        """Gets the merge base between two refs.
        If only one ref is specified, assume HEAD as the second.
        If no refs are specified, assumes HEAD and origin/master."""
        return handle_success(self._call_git(['merge-base', ref1, ref2]))

    def diff(self, ref1=None, ref2='HEAD', extra_args=None, strip=True):
        """Get a diff between two refs.
        If only one ref is specified, assume HEAD as the second.
        If no refs are specified, assumes HEAD and the merge-base of
        HEAD and origin/master."""
        if not ref1:
            ref1 = self.merge_base()
        command = ['diff', ref1, ref2]
        if extra_args:
            command.extend(extra_args)
        rc, stdout, stderr = self._call_git(command)
        if rc != 0:
            return None
        return stdout.strip(os.linesep) if strip else stdout

    def changed_files(self, ref1='origin/master', ref2='HEAD'):
        """Get what files changed between two refs.
        If only one ref is specified, assume HEAD as the second.
        If no refs are specified, assume HEAD and the merge-base of
        HEAD and origin/master."""
        merge_base = self.merge_base(ref1, ref2)
        if not merge_base:
            print "Error: unable to find merge base between %s and %s" % (ref1, ref2)
            return None
        raw_output = self.diff(ref1=merge_base, ref2=ref2, extra_args=['--name-only']).strip(os.linesep)
        if not raw_output:
            return None
        return raw_output.split(os.linesep)

    def format_log(self, ref1='HEAD', ref2=None, count=None, extra_args=None):
        """Get the log entry for a given commit or commit range.
        To prevent silliness, either a range or a maximum number of commits
        (count) must be specified; grabbing unlimited history is not supported."""
        if not (ref1 and ref2) and not count:
            raise ValueError('Must specify either a commit range or a max number of commits.')
        command = ['log']
        if count:
            command.append('-n%d' % count)
        if extra_args:
            command.extend(extra_args)
        if ref1 and ref2:
            command.append('%s..%s' % (ref1, ref2))
        elif ref1:
            command.append(ref1)
        return handle_success(self._call_git(command))

    def rev_list(self, oldsha, newsha, first_parent=False):
        command = ['rev-list']
        if first_parent:
            command += ['--first-parent']

        command += ['%s..%s' % (oldsha, newsha)]

        rc, stdout, stderr = self._call_git(command)
        if rc != 0:
            return None
        return stdout.split('\n')[:-1]

    def author_list(self, oldsha, newsha):
        command = ['log', '--no-merges', '--format=%ae', '%s..%s' % (oldsha, newsha)]
        rc, stdout, stderr = self._call_git(command)
        if rc != 0:
            return None
        emails = set(stdout.split('\n')[:-1])
        return sorted(e.split('@')[0] for e in emails)

    def whatchanged_raw_email(self, oldsha, newsha):
        command = ['whatchanged', '--pretty=%h {%ae} %s', '%s..%s' % (oldsha, newsha)]
        return handle_success(self._call_git(command), strip=False)

    def whatchanged_raw(self, oldsha, newsha):
        command = ['whatchanged', '--oneline', '%s..%s' % (oldsha, newsha)]
        return handle_success(self._call_git(command), strip=False)

    def whatchanged(self, oldsha, newsha):
        changed = self.whatchanged_raw(oldsha, newsha)
        if changed:
            return changed.split('\n')[:-1]

    def get_branch_for_commit(self, commit):
        command = ['rev-list', '--format=%d', '%s' % '^'+commit+'^', '%s' % commit]
        branch = handle_success(self._call_git(command))
        if branch:
            return branch.split('\n')[-1]

    def get_diff_for_commit(self, commit):
        diff = self.diff('%s^' % commit, commit, strip=False)
        if len(diff) > MAX_OUTPUT_LENGTH:
            diff = diff[:MAX_OUTPUT_LENGTH]

        return diff

    def get_patch_log(self, oldsha, newsha):
        command = ['log', '-p', '%s..%s' % (oldsha, newsha)]
        log = handle_success(self._call_git(command), strip=False)
        if not log:
            return

        if len(log) > MAX_OUTPUT_LENGTH:
            log = log[:MAX_OUTPUT_LENGTH] + '\n\n(Log truncated due to length)'

        return log

    def get_rev_info(self, commit):
        # This is pretty much copy-pasted from git-scripts' old git.py. It's bad, I know.
        # The format: commit body, subject, author name, email, date, parents
        command = ['rev-list', '-n1', '--format=B{%b}S{%s}AN{%an}AE{%ae}D{%ad}P{%p}', '%s' % commit]
        stdout = handle_success(self._call_git(command))
        if not stdout:
            return

        commit_info = ' '.join(stdout.split('\n')[1:])
        matches = re.match(
            'B{(?P<body>.*)}S{(?P<subject>.*)}AN{(?P<authorname>.*)}AE{(?P<email>.*)}D{(?P<date>.*)}P{(?P<parents>.*)}',
            commit_info,
        )
        if matches is not None:
            ret = matches.groupdict()
            ret['commit'] = commit
            return ret
        return None
