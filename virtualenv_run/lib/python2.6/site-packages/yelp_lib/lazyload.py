import logging

from yelp_lib import _import

class LazyLoaderError(Exception): pass
class LazyDuplicateNameError(LazyLoaderError): pass
class LazyNoSuchNameError(LazyLoaderError): pass

log = logging.getLogger("util.lazyload")

_NOT_SET_CACHED_VALUE = "_NOT_SET_CACHED_VALUE"

class LazyLoadInfo(object):
    """Object that represents a lazy-loaded value"""
    _cached_value = _NOT_SET_CACHED_VALUE

    def __init__(self, func, args, kwargs, caching=True):
        """Create a lazily evaluated value
        Value will be calculated be calling: func(*args, **kwargs)
        """
        self.func = func
        self.args = args
        self.kwargs = kwargs
        self.caching = caching

    def get_value(self):
        """Load a lazily evaluated value"""
        if self._cached_value is not _NOT_SET_CACHED_VALUE:
            return self._cached_value

        lazy_loaded_item = self.func(*self.args, **self.kwargs)

        if self.caching:
            # Cache the item if caching is enabled
            self._cached_value = lazy_loaded_item

            # Remove references to these as they are no longer needed
            self.func = None
            self.args = None
            self.kwargs = None

        return lazy_loaded_item


class LazyLoader(object):
    """A class maintaining a mapping from names to values that are created as needed
    See: tests/lazyload_test.py, or yelp/core/connection_token/conn_token.py for examples
    """
    def __init__(self, caching=True):
        """Initialize the class
        Args:
            caching - Should values be saved or recomputed on each load
        """
        # Map from names to function to call to compute value
        self._name_to_load_info_map = {}
        self._caching = caching

    def get_lazy_names(self):
        return self._name_to_load_info_map.keys()

    def add_lazy_func(self, name, func, *args, **kwargs):
        """Register a function to lazy load with
        On load we will call the function with the specified args and kwargs"""

        if name in self._name_to_load_info_map:
            raise LazyDuplicateNameError("Lazy-Value of name %r already registered: %s" % (name, self._name_to_load_info_map[name]))

        self._name_to_load_info_map[name] = LazyLoadInfo(func, args, kwargs, caching=self._caching)

    def load_lazily(self, name):
        """Load a lazily loaded value"""
        if name not in self._name_to_load_info_map:
            raise LazyNoSuchNameError("No name %r registered." % name)

        return self._name_to_load_info_map[name].get_value()

    def add_lazy_class(self, name, class_name, *args, **kwargs):
        """Register a class to lazy load
        Class will not be imported until load time so using this will speed up import
        time relative to construcing the class right away.

        Args:
            class_name - A string that we will dynamically import at load time
            args/kwargs - Return value will be instance class constructed with these args/kwargs
        """
        self.add_lazy_func(name, self._load_class, class_name, args, kwargs)

    def _load_class(self, class_name, args, kwargs):
        """Load class for add_lazy_class"""
        cls = _import.import_module_class(class_name)
        return cls(*args, **kwargs)

    def add_lazy_getattrs(self, names, proxied_object, attr_names=None):
        """Same as add_lazy_getattr, but allows multiple proxied attributes
        Args:
            names - list of names to register
            proxied_object - same as add_lazy_getattr
            attr_names - attribute names on the object, must be 1-1 with names (defaults to names)
        """
        if attr_names is None:
            attr_names = names

        for name, attr_name in zip(names, attr_names):
            self.add_lazy_getattr(name, proxied_object, attr_name)

    def add_lazy_getattr(self, name, proxied_object, attr_name=None):
        """Convenience method to register getattr on an object for lazy loading
        On lazyload returns getattr(proxied_object, attr_name)

        Args:
            proxied_object - object to get attribute off of
            attr_name - attribute name to get, defaults to name being added
        """
        if attr_name is None:
            attr_name = name

        self.add_lazy_func(name, self._load_proxied_attr, proxied_object, attr_name)

    def _load_proxied_attr(self, proxied_object, attr_name):
        """Load a proxied attribute added by add_lazy_proxy"""
        return getattr(proxied_object, attr_name)
 

class LazyLoaderMixin(object):
    """Mixin for providing lazy loaded attributes"""
    __lazyloader = None

    def set_lazy_loader(self, lazyloader):
        """Subclasses utilizing this Mixin should call this to set a loader"""
        self.__lazyloader = lazyloader

    def __getattr__(self, key):
        """Getattr redirects to the lazy loader"""
        if self.__lazyloader is None:
            raise AttributeError(key)

        try:
            return self.__lazyloader.load_lazily(key)
        except AttributeError:
            # Log an exception here so that exception is not ignored by python
            log.exception("Failed to lazyload: %s", key)
            raise
        except LazyNoSuchNameError:
            raise AttributeError(key)

    def __dir__(self):
        """dir() is augmented with the lazyloader values"""
        lazy_loaded_keys = []
        if self.__lazyloader:
            lazy_loaded_keys = self.__lazyloader.get_lazy_names()	

        # Need to reimplment dir because there is no super().__dir__
        # See: bugs.python.org/issue12166
        return dir(type(self)) + list(self.__dict__) + lazy_loaded_keys
