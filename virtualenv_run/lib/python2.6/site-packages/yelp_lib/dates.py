# -*- coding: utf-8 -*-
"""
Utility methods for manipulating dates and times.
"""
import calendar
import datetime
import logging
import sys
import time
import types

import pytz

import iso8601
import tzworld
from geogrid import GeoGrid

OUR_TIMEZONE = pytz.timezone('US/Pacific')
UTC_TIMEZONE = pytz.timezone('UTC')

DAYS_IN_MONTH = 30
DAYS_IN_WEEK = 7

STD_DATE_FORMAT = '%Y-%m-%d'

log = logging.getLogger("y_app.yelp_lib.dates")

# this code was lifted from Zope
weekday_abbr = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
weekday_full = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
MONTHNAME = [None, 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
# These monthnames aren't offsetted over
unoffsetted_monthnames = MONTHNAME[1:]


def business_days_ahead(num_days=0, start_date=None):
    """
    Add num_days to start_date counting only business days and not weekends.

    If start_date is a weekend and num_days is 0, business_days_ahead()
    will simply give the nearest business day, Monday.
    """
    assert num_days >= 0
    start_date = start_date or datetime.date.today()

    # For each *Business* week passed, we can add two days.
    num_weekends_passed = num_days / 5

    # If start date is a weekend, we want to start math on Monday.
    num_days_to_monday = 0
    if start_date.isoweekday() > 5:
        num_days_to_monday = 1 + (7 - start_date.isoweekday())
    # if we end up on a weekend
    elif start_date.isoweekday() + (num_days % 5) > 5:
        num_weekends_passed += 1

    # Total number of days to add to start_date.  For each weekend passed, we
    # add two days (Sat, Sun).
    total_num_days = num_days + num_days_to_monday + (num_weekends_passed * 2)

    return start_date + datetime.timedelta(days=total_num_days)


def unix_time_as_local_time_string(t):
    t = datetime.datetime.fromtimestamp(t)
    return datetime_as_local_time_string(t)


def to_js_unix_time(t):
    ''' Converts to javascript unix timestamp '''
    if isinstance(t, datetime.datetime) or isinstance(t, datetime.date):
        time_tuple = t.timetuple()
    else:
        time_tuple = time.gmtime(t)

    return time.mktime(time_tuple) * 1000


def datetime_as_local_time_string(t):
    return time.strftime('%F %H:%M:%S', t.timetuple())


def format_day_of_week(d, daynames=weekday_abbr):
    """
    Convert a day of week (0=Mon, 1=Tue, etc.) to a string.
    You can optionally specify your own daynames
    """
    assert len(daynames) == 7
    assert d >= 0 and d < 7
    return daynames[d]


def to_timestamp(datetime_val):
    if datetime_val is None:
        return None

    # If we don't have full datetime granularity, translate
    if isinstance(datetime_val, datetime.datetime):
        datetime_val_date = datetime_val.date()
    else:
        datetime_val_date = datetime_val

    if datetime_val_date >= datetime.date.max:
        return sys.maxint

    return int(time.mktime(datetime_val.timetuple()))


def to_datetime(value, preserve_max=False):
    if value is None:
        return None
    if isinstance(value, datetime.datetime):
        return value
    elif isinstance(value, datetime.date):
        return date_to_datetime(value, preserve_max=preserve_max)
    elif isinstance(value, float) or isinstance(value, int) or isinstance(value, long):
        return from_timestamp(value)
    raise ValueError("Can't convert %r to a datetime" % (value,))


def max_to_none(value):
    """ return None for dates or datetimes that are max, otherwise return the value as-is
    """
    if datetime.date.max == value or datetime.datetime.max == value:
        return None
    return value


def to_days(timedelta_value):
    return (timedelta_value.days +
            timedelta_value.seconds / 86400.0 +
            timedelta_value.microseconds / 86400000000.0)


def to_hours(timedelta_value):
    return (timedelta_value.days * 24 +
            timedelta_value.seconds / 3600.0 +
            timedelta_value.microseconds / 3600000000.0)


def to_minutes(timedelta_value):
    return to_hours(timedelta_value) * 60


def to_secs(timedelta_value):
    return (86400 * timedelta_value.days +
            timedelta_value.seconds +
            0.000001 * timedelta_value.microseconds)


def from_timestamp(timestamp_val):
    if timestamp_val is None:
        return None
    return datetime.datetime.fromtimestamp(timestamp_val)


def awarify(dt):
    """Given a naive `datetime`, return an equivalent aware one with Yelp's
    system timezone (Pacific). If `dt` is already aware, just return it.

    NOTE: You should only use aware `datetime`s if you really need them. For
    example, if you need to include the offset while sending an ISO 8601
    formatted string. Otherwise, stick to passing around naive datetimes.

    Also note that this method does not handle naive datetime.max or datetime.min
    """
    if dt.tzinfo is None:
        return OUR_TIMEZONE.localize(dt)
    return dt


def localize_to_geoquad_time(geoquad, naive_datetime):
    """Returns a datetime localized for this geoquad"""
    lng, lat = GeoGrid.center(geoquad)
    return localize_to_point(lng, lat, naive_datetime)


def current_datetime_at_point(longitude, latitude):
    """Returns the current datetime as seen from this point"""
    return localize_to_point(longitude, latitude, datetime.datetime.now())


def localize_to_point(longitude, latitude, naive_datetime):
    """Returns a datetime localized for this point"""
    location = {'longitude': longitude, 'latitude': latitude}
    timezone = tzworld.timezone_for_location(location)

    if timezone is None:
        return None

    return OUR_TIMEZONE.localize(naive_datetime).astimezone(timezone)


def intl_between_range(start, end, range_tz, point=None, point_tz=None):
    """Similar to between range, but makes timezones easy to deal with

    start & end are naive datetimes (eg they don't have a
    timezone). range_tz is the timezone they should refer to.

    point is a naive datetime (or datetime.now() if none is provided),
    and point_tz is the desired timezone for the point (or the server
    timezone if none is provided)
    """
    if not point:
        point = datetime.datetime.now()

    if not point_tz:
        point_tz = OUR_TIMEZONE

    # First move all the times into the range_tz timezone
    start = start.replace(tzinfo=range_tz)
    end = end.replace(tzinfo=range_tz)
    point = point.replace(tzinfo=point_tz).astimezone(range_tz)

    # Now we can do the straight comparison
    return start <= point <= end


def first_time_on_date(d):
    """Return a datetime of the first time on the given date"""
    return datetime.datetime(*d.timetuple()[:3])


def last_time_on_date(d):
    return first_time_on_date(d) + (datetime.timedelta(days=1) - datetime.timedelta.resolution)


def midnight(tonight=False, now=None):
    """
    Return a datetime of today's midnight. It defaults to midnight,
    yesterday (eg the start of today), unless tonight is specified
    """

    now = default_now(now)
    midnight = first_time_on_date(now)

    if tonight:
        midnight += datetime.timedelta(days=1)

    return midnight


def noon(current_date=None):
    return first_time_on_date(current_date or datetime.date.today()) + datetime.timedelta(hours=12)


def sunday_midnight(future=False, now=None):
    """
    Return the datetime of the last sunday at midnight. If future is
    True, return the next sunday at midnight

    Remember, Sunday midnight is actually monday at 00:00
    """
    if future:
        tonight = midnight(tonight=True, now=now)

        # Special case: if today's a sunday, midnight is monday, so we
        # want to use that (otherwise the code will roll forward to
        # next monday)
        if tonight.weekday() == 0:
            return tonight

        # If we're in the future, we want to roll forward however many
        # days we need to reach monday (monday.weekday() == 0). So if
        # tonight is sunday, roll forward 1, but if it's monday, roll
        # forward 7 days
        day_offset = 7 - tonight.weekday()
        tonight += datetime.timedelta(days=day_offset)

        return tonight
    else:
        tonight = midnight(tonight=False, now=now)
        # Otherwise we need to roll back the current number of
        # weekdays days so if we're currently on a sunday, then we
        # want to rollback 7 days, but if we're on a monday, we want
        # to roll back 1 day
        day_offset = tonight.weekday()
        tonight -= datetime.timedelta(days=day_offset)

        return tonight


def saturday_midnight(now=None):
    """
    Return the datetime of the last Saturday at midnight.

    Remember, Saturday midnight is actually Sunday at 00:00.

    N.B.: Not our usual "week" boundary, mostly useful for matching MySQL WEEK() functions.
    However, the User Ops pay system counts weeks Saturday Midnight to Saturday Midnight.
    """
    tonight = midnight(tonight=False, now=now)
    day_offset = (tonight.weekday() + 1) % 7
    tonight -= datetime.timedelta(days=day_offset)

    return tonight


def _datetime_weekday(start, direction, weekday):
    """Weekday refers to day of the week - i.e. there's no distinction here between weekday/weekend"""
    if weekday is None:
        weekday = (start.weekday() + 1 * direction) % len(weekday_abbr)
    elif isinstance(weekday, types.StringTypes):
        weekday = weekday_abbr.index(weekday)

    assert weekday > -1
    days = (weekday - start.weekday()) % len(weekday_abbr)

    if direction < 0:
        days += -7  # last week
    elif days == 0:
        days = 7
    return start + datetime.timedelta(days=days)


def next_weekday_datetime(start, weekday=None):
    return _datetime_weekday(start, 1, weekday)


def prev_weekday_datetime(start, weekday=None):
    return _datetime_weekday(start, -1, weekday)


def first_and_last_days_of_month(daynum):
    """
    given a datetime ordinal, return a tuple of the first and last day ordinals of the containing month.
    """
    dt = datetime.datetime.fromordinal(daynum)
    first_date, last_date = first_and_last_date(dt)
    return (first_date.toordinal(), last_date.toordinal())


def first_and_last_date_of_year(dt):
    """Return the first and last date of the year that contains the given date (dt)"""
    first = datetime.date(dt.year, 1, 1)
    last = datetime.date(dt.year, 12, 31)
    return first, last


def first_and_last_date(dt):
    """Return the first and last date of the month that contains the given date (dt)"""
    first = datetime.date(dt.year, dt.month, 1)
    last = datetime.date(dt.year, dt.month, days_in_month(dt))
    return first, last


def days_in_month(date):
    return calendar.monthrange(date.year, date.month)[1]


def is_month_end(daynum):
    """
    returns true if datetime ordinal is the last day of its month, false otherwise.
    """
    return datetime.datetime.fromordinal(daynum + 1).day == 1


def is_weekend(date):
    """Return true if the date is a saturday or sunday."""
    return bool(date.weekday() >= weekday_abbr.index('Sat'))


def months_ago(current_month, months_ago):
    ago_year = current_month.year
    ago_month = current_month.month - months_ago
    while ago_month < 1:
        ago_year -= 1
        ago_month += 12
    while ago_month > 12:
        ago_year += 1
        ago_month -= 12

    return datetime.date(ago_year, ago_month, 1)


def months_ago_ordinals(months=6):
    today = datetime.date.today()
    year = today.year
    month = today.month
    ordinals = []
    for i in range(months):
        newMonth = month - i
        newYear = year
        if newMonth < 1:
            newMonth += 12
            newYear -= 1
        ordinal = datetime.date(newYear, newMonth, 1).toordinal()
        ordinals.append((ordinal, '%s %02d' % (MONTHNAME[newMonth], newYear % 100)))
    ordinals.sort(key=lambda i: i[0])
    return ordinals


def get_last_day_of_month(month, year):
    """Returns the last day of the month"""
    return datetime.date(year, month, calendar.monthrange(year, month)[1])


def get_month_end_timestamp(month, year):
    """Unix timestamp of first day of the month that follows the given month and year"""
    end_month = month + 1
    if end_month > 12:
        end_month = 1
        end_year = year + 1
    else:
        end_year = year
    return to_timestamp(datetime.datetime(end_year, end_month, 1))


def get_month_start_timestamp(month, year):
    """Unix timestamp of first day of the given month and year"""
    return to_timestamp(datetime.datetime(year, month, 1))


def previous_month_year(month, year):
    """Return the month,year of the month before the given month and year"""
    prev_month = month - 1
    prev_year = year
    if prev_month < 1:
        prev_month = 12
        prev_year = year - 1
    return prev_month, prev_year


def date_to_month(a_date):
    return datetime.date(a_date.year, a_date.month, 1)


def this_month():
    """Get the current month (represented as the first day of the current
    month)"""
    return date_to_month(datetime.date.today())


def add_months(a_date, months, years=0):
    """Given a datetime.date, add the given number of years and months. Note
    that `datetime.datetime`s are also `datetime.date`s.

    If we end up with a day past the end of a month (e.g. Feb. 30),
    normalize it to the last day in the month
    """
    year = a_date.year + years
    month = a_date.month + months

    # normalize months
    month_idx = month - 1
    year_idx = month_idx / 12
    month_idx = month_idx % 12

    month = month_idx + 1
    year = year + year_idx

    try:
        return a_date.replace(year=year, month=month)
    except ValueError:
        _, last_day_of_month = calendar.monthrange(year, month)
        return a_date.replace(year=year, month=month, day=last_day_of_month)


def get_day_in_month_or_last_day(date, desired_day):
    """Given a date object and a numeric day of the month, return either that numbered day in the month or the last day
    if the month doesn't have the desired day."""
    return date.replace(day=min(desired_day, days_in_month(date)))


def seconds_ago(num_seconds, current_time=None):
    """Returns the datetime for <num_seconds> before current_time."""
    return default_now(current_time) - datetime.timedelta(seconds=num_seconds)


def seconds_ahead(num_seconds, current_time=None):
    """Returns the datetime for <num_seconds> after current_time."""
    return seconds_ago(-num_seconds, current_time=current_time)


def minutes_ago(num_minutes, current_time=None):
    return seconds_ago(num_minutes * 60, current_time=current_time)


def minutes_ahead(num_minutes, current_time=None):
    return minutes_ago(-num_minutes, current_time=current_time)


def days_ago(num_days, current_date=None):
    """Return a date num_days days ago"""
    return (current_date or datetime.date.today()) - datetime.timedelta(days=num_days)


def days_ahead(num_days, current_date=None):
    return days_ago(-num_days, current_date)


def yesterday(current_date=None):
    """Return yesterday"""
    return days_ago(1, current_date)


def tomorrow(current_date=None):
    """Return tomorrow"""
    return days_ahead(1, current_date)


def default_now(a_datetime=None):
    return a_datetime or datetime.datetime.now()


def default_today(a_date=None):
    return a_date or datetime.date.today()


def inclusive_month_range(start, end):
    """Given two dates, yield all months between and including those
    dates.

    We represent a month as the datetime.date for the 1st day of that
    month."""
    start_month = date_to_month(start)
    end_month = date_to_month(end)

    assert start_month <= end_month

    curr_month = start_month
    while curr_month <= end_month:
        yield curr_month
        curr_month = add_months(curr_month, 1)


def inclusive_date_range(start, end, step=None):
    return date_range(start, end + datetime.timedelta(days=1), step=step)


def date_range(start, end, step=None):
    """Kind of like xrange() for datetime.date objects.

    Yield all dates starting with start, and up to (but not including) end."""
    step = step or datetime.timedelta(days=1)
    while start < end:
        yield start
        start += step


def inclusive_date_list(min_date, max_date):
    """
    Return an inclusive list of dates given min/max date.

    If only min or max date is set, return a single date.
    Return [] if neither is set.
    """
    if min_date and max_date:
        return list(inclusive_date_range(min_date, max_date))

    chosen_date = min_date or max_date
    if chosen_date:
        return [chosen_date]
    return []


def date_to_weekday(date):
    """Return the weekday given the date. 0 = Monday."""
    return calendar.weekday(date.year, date.month, date.day)


class TimeIt(object):
    """Simple timing class, one just needs to call t.start() to start the timer.
    To get the current elapsed time just call t.get_ms_elapsed()."""
    def __init__(self):
        self.start_time = None

    def start(self):
        self.start_time = datetime.datetime.now()

    def get_ms_elapsed(self):
        delta = datetime.datetime.now() - self.start_time
        msecs = delta.seconds * 1000.0 + delta.microseconds / 1000.0
        return msecs

    def get_elapsed(self):
        return self.get_ms_elapsed() / 1000.0


def get_datetime(t, preserve_max=False):
    try:
        return to_datetime(t, preserve_max=preserve_max)
    except ValueError:
        return None


def get_date(t):
    if isinstance(t, datetime.datetime):
        # Note this case must come first because a datetime is a date
        return datetime_to_date(t)
    elif isinstance(t, datetime.date):
        return t
    elif isinstance(t, float) or isinstance(t, int) or isinstance(t, long):
        return datetime_to_date(from_timestamp(t))

    return None


def date_to_datetime(dt, preserve_max=False):
    if preserve_max and datetime.date.max == dt:
        return datetime.datetime.max
    return datetime.datetime(*dt.timetuple()[:3])


def datetime_to_date(dt):
    return datetime.date(*dt.timetuple()[:3])


def total_seconds(weeks=0, days=0, hours=0, minutes=0, seconds=0):
    """
    Return total seconds
    """
    return (weeks * 604800) + (days * 86400) + (hours * 3600) + (minutes * 60) + seconds


class TimePeriod(object):
    """Represents a time period either from a specific time to another time,
    or a specific day to another day

    All times are inclusive.
    """

    # Borrowed from the Unicode CLDR 25 and translated to strftime format, to
    # avoid a babel dependency.  See:
    # http://www.unicode.org/cldr/charts/25/by_type/date_&_time.gregorian.html
    # Full year is actually not CLDR, but we prefer full four digits
    EN_DATE_FORMAT = "{0.month}/{0.day}/{0.year}"
    EN_TIME_FORMAT = "{0.hour}:{0.minute:02d} {0:%p}"
    EN_DATETIME_FORMAT = EN_DATE_FORMAT + ' ' + EN_TIME_FORMAT

    def __init__(self, first_time, last_time, allow_start_after_end=False):
        """
        Args
            first_time - the first datetime/date that that TimePeriod represents
            last_time - the last datetime/date that this TimePeriod represents

            If this above times are specified as datetimes, they will be assumed to have 1 second
            resolution, if they are dates then a day resolution will be used

            allow_start_after_end - dont use this flag (used for constructing the NullPeriod)
        """
        self._first_time = first_time

        # Handle the Null initilization - need this because some SQLAlchemy stuff does this
        # It is an error to try to access a TimePeriod constructed in this way
        if self._first_time is None:
            assert last_time is None
            self._last_time = None
            return
        # Set the end time
        self._first_time = self._normalize_first_time(first_time, preserve_max=True)
        self._last_time = self._normalize_last_time(last_time or datetime.datetime.max)

        if not allow_start_after_end:
            assert self._first_time <= self._last_time, "Start: %s > End: %s" % (self._first_time, self._last_time)

    def time_length(self):
        """Return a timedelta that is the total length of this TimePeriod"""
        return self.last_time - self.first_time + datetime.timedelta.resolution

    def total_seconds(self):
        """Return the total number of seconds in this TimePeriod (rounded down)"""
        time_length = self.time_length()
        return total_seconds(days=time_length.days, seconds=time_length.seconds)

    def total_days(self):
        """Return the total number of days in this TimePeriod (rounded down)"""
        return self.time_length().days

    @staticmethod
    def _normalize_first_time(t, preserve_max=False):
        """Normalize first time in a period to be the beginning of the second it starts on.

        Does not normalize datetime.datetime.max if preserve_max=True.
        """
        dt = get_datetime(t)
        if preserve_max and dt == datetime.datetime.max:
            return dt
        return datetime.datetime(*dt.timetuple()[:6])

    @staticmethod
    def _normalize_last_time(t):
        """This function will return the last microsecond that this timeperiod represents"""
        normalized_time = TimePeriod._normalize_first_time(t)
        if isinstance(t, datetime.datetime):
            # Datetimes cover the last full second the represent
            # (because the DB only has second time resolultion)
            return normalized_time + (datetime.timedelta(seconds=1) - datetime.timedelta.resolution)
        elif isinstance(t, datetime.date):
            return last_time_on_date(t)
        else:
            raise TypeError("Cannot _normalize_late_time with a %r" % t)

    def __nonzero__(self):
        return bool(self._first_time is not None)

    @classmethod
    def from_time_period_or_time(cls, time_period_or_time):
        """Create a TimePeriod from another time period or a datetime
        If the passed in value is a time_period then then function will return the same time period
        If it is a date it will return a TimePeriod representing that entire date
        If it is a datetime it rill return a TimePeriod representing the second that the datetime is in
        """
        first_time, last_time = cls.to_first_and_last_time(time_period_or_time)
        return cls(first_time, last_time)

    @classmethod
    def from_strings(cls, start_time_str, end_time_str):
        """Create a TimePeriod from two strings representing a datetime
        TODO: Should take into account percision of string
        e.g., from_strings("2011-08-01", "2011-08-01") != from_strings("2011-08-01T00:00:00", "2011-08-01T00:00:00")
        """
        start_time = start_time_str and datetime_from_string(start_time_str)
        end_time = end_time_str and datetime_from_string(end_time_str)
        return cls(start_time, end_time)

    @staticmethod
    def to_first_and_last_time(time_period_or_time):
        """Return the first and last time represented by the given object
        For a TimePeriod this will be the time period first and last time, for a datetime/date it will be that time
        This function is useful for when you want to use a datetime/date as if is were a time period
        """
        if isinstance(time_period_or_time, TimePeriod):
            return time_period_or_time.first_time, time_period_or_time.last_time
        elif isinstance(time_period_or_time, datetime.date):
            return TimePeriod._normalize_first_time(time_period_or_time), TimePeriod._normalize_last_time(time_period_or_time)

        raise ValueError("Cannot call to_first_and_last_time on a %s" % time_period_or_time.__class__)

    @staticmethod
    def get_containing_period(period_list):
        """Get the smallest period that contains all the TimePeriods in period_list."""
        if not period_list:
            return NullTimePeriod

        return TimePeriod(
            min([period.first_time for period in period_list]),
            max([period.last_time for period in period_list])
        )

    @property
    def first_time(self):
        return self._first_time

    @property
    def last_time(self):
        return self._last_time

    def time_right_after(self):
        return self.last_time + datetime.timedelta.resolution

    def time_right_before(self):
        return self.first_time - datetime.timedelta.resolution

    def replace(self, **kwargs):
        """Replace the first/last time of this time period with the given value"""
        # Need these to be kwargs so we can distinquish between
        # not passing in a value and passing in None
        first_time = kwargs.pop('first_time', self.first_time)
        last_time = kwargs.pop('last_time', self.last_time)
        assert not kwargs, "Unknown kwargs passed to TimeUtil.replace: %s" % kwargs
        return TimePeriod(first_time, last_time)

    def first_day(self):
        return self._time_as_date(self.first_time)

    def last_day(self):
        return self._time_as_date(self.last_time)

    def _time_as_date(self, t):
        if t is None:
            return None

        return get_date(t)

    def date_range(self):
        """Return an iterable of the days that fall in this time period"""
        return inclusive_date_range(self.first_day(), self.last_day())

    def prev_period(self):
        raise NotImplementedError("prev_period: %r" % self)

    def next_period(self):
        raise NotImplementedError("next_period: %r" % self)

    def jump_to(self, date_or_period):
        """Return the nearest period that overlaps with date_or_period.

        In this implementation, the number of calls made to self.prev_period or
        self.next_period is linear in the number of periods between self and
        date_or_period. Certain cases (e.g., a month period) could be handled in
        constant time, so override this method in those cases.
        """
        if self.overlaps(date_or_period):
            return self

        first_time, last_time = self.to_first_and_last_time(date_or_period)
        # if this is a poorly formed (or Null) time period, exit with a Null period
        if first_time > last_time:
            return NullTimePeriod

        move_backward = last_time < self.first_time

        current_period = self
        while True:
            if move_backward:
                current_period = current_period.prev_period()
            else:
                current_period = current_period.next_period()

            if current_period.overlaps(date_or_period):
                return current_period

    def __hash__(self):
        return self.__str__().__hash__()

    def __repr__(self):
        return "%s.%s(%r, %r)" % (self.__class__.__module__, self.__class__.__name__, self.first_time, self.last_time)

    def __str__(self):
        return "TimePeriod(%s)" % self.to_user_string()

    #TODO: unify time display between this, StandardModel, and models.billing.PaymentProgram
    def to_user_string(self, **kwargs):
        """Return a string suitable for displaying to end users"""

        # TODO: This is not properly internationalized, we could use something
        # like TranslateableText here, but punting for now
        return "%s - %s" % (self.display('first_time', **kwargs), self.display('last_time', **kwargs))

    def to_short_string(self):
        return self.to_user_string().replace('-', 'to')

    def display(self, key, **kwargs):
        def format_date(a_time, can_show_date_function, **kwargs):
            if a_time is None or a_time.date() == datetime.date.max:
                # Format None and datetime.date.max as empty string
                return ''

            always_show_date_time = kwargs.pop('always_show_date_time', False)
            if not always_show_date_time and a_time == can_show_date_function(a_time):
                return self.EN_DATE_FORMAT.format(a_time)
            else:
                return self.EN_DATETIME_FORMAT.format(a_time)

        if key == '':
            return self.to_user_string(**kwargs)
        if key == 'first_time':
            return format_date(self.first_time, first_time_on_date, **kwargs)
        elif key == 'last_time':
            return format_date(self.last_time, last_time_on_date, **kwargs)
        else:
            raise AssertionError("Unknown display key: %r" % key)

    def overlaps(self, time_period_or_time):
        """Returns True iff there is a some overlap between timeperiod self and other"""
        other_first_time, other_last_time = self.to_first_and_last_time(time_period_or_time)
        if self.first_time > other_last_time:
            return False

        if self.last_time < other_first_time:
            return False

        return True

    def intersection(self, other):
        """Returns the intersection of two time periods"""
        if self is NullTimePeriod:
            return NullTimePeriod

        elif other in self:
            # other is a subset of self, so other is the intersection
            return other

        elif self in other:
            # self is a subset of other, so self is the intersection
            return self

        elif self.first_time in other:
            # If our first day is in other, return a TimePeriod from that day to the min last days
            return TimePeriod(self.first_time, min(self.last_time, other.last_time))

        elif self.last_time in other:
            # We know self.first_day() < other.first_day() because first_day is not in other, and last_day is.
            return TimePeriod(other.first_time, self.last_time)

        else:
            # There is no overlap because other is not contain in self, and the first and last day of self is not in other
            return NullTimePeriod

    def __contains__(self, time_period_or_time):
        """Returns true of item falls completely within self"""
        other_first_time, other_last_time = self.to_first_and_last_time(time_period_or_time)
        return (self.first_time <= other_first_time) and (other_last_time <= self.last_time)

    def __cmp__(self, other):
        # Everything is bigger than None
        if other is None:
            return 1

        return cmp(self.first_time, other.first_time) or cmp(self.last_time, other.last_time)

    def _json_encode(self):
        """Return a dict representing this TimePeriod"""
        return {
            'first_time': self.first_time.isoformat(),
            'last_time': self.last_time.isoformat(),
        }

    @classmethod
    def _json_decode(cls, json_dict):
        """Return a TimePeriod from a dict representing a TimePeriod"""
        return cls(datetime_from_string(json_dict['first_time']), datetime_from_string(json_dict['last_time']))


class _NullTimePeriod(TimePeriod):
    """A TimePeriod that contains no days, no other time periods, and evaluates to False"""
    def __init__(self):
        super(_NullTimePeriod, self).__init__(datetime.date.max, datetime.date.min, allow_start_after_end=True)

    def __nonzero__(self):
        """We want the empty time period to evaluate to False"""
        return False

    def __repr__(self):
        return "dates.NullTimePeriod"

    def __str__(self):
        return self.__repr__()

    def prev_period(self):
        return self

    def next_period(self):
        return self

NullTimePeriod = _NullTimePeriod()


class _IndeterminateFuturePeriod(TimePeriod):
    """A time period that exists at positive infinity.

    Useful for something like an active_period that you know starts at some point (so is
    non-NullTimePeriod), but that start has yet to be defined. This makes comparisons between
    other time periods much nicer.
    """
    def __init__(self):
        super(_IndeterminateFuturePeriod, self).__init__(datetime.datetime.max, datetime.datetime.max)

    def __repr__(self):
        return "dates.IndeterminateFuturePeriod"

    def __str__(self):
        return self.__repr__()

    def prev_period(self):
        return self

    def next_period(self):
        return self

IndeterminateFuturePeriod = _IndeterminateFuturePeriod()


class _AllTimePeriod(TimePeriod):
    """A TimePeriod that contains all days, all other time periods, and evaluates to True"""
    def __init__(self):
        super(_AllTimePeriod, self).__init__(datetime.date.min, datetime.date.max)

    def __repr__(self):
        return "dates.AllTimePeriod"

    def __str__(self):
        return self.__repr__()

    def prev_period(self):
        return NullTimePeriod

    def next_period(self):
        return NullTimePeriod

AllTimePeriod = _AllTimePeriod()


class InstantaneousTimePeriod(TimePeriod):
    """A TimePeriod that represents a discrete moment in time.

    Effectively creates a 1-second TimePeriod.
    """
    def __init__(self, current_time=None):
        current_time = default_now(current_time)
        super(InstantaneousTimePeriod, self).__init__(current_time, current_time)


class FixedDayPeriod(TimePeriod):
    def __init__(self, date, num_days):
        self.num_days = num_days
        date = get_date(date)
        super(FixedDayPeriod, self).__init__(date, days_ahead(num_days - 1, date))

    def prev_period(self):
        return FixedDayPeriod(self.first_day() - datetime.timedelta(days=self.num_days), self.num_days)

    def next_period(self):
        return FixedDayPeriod(self.first_day() + datetime.timedelta(days=self.num_days), self.num_days)


class DayPeriod(FixedDayPeriod):
    def __init__(self, date):
        super(DayPeriod, self).__init__(date, 1)

    def jump_to(self, date_or_period):
        """Return the nearest DayPeriod that overlaps with date_or_period.
        This is faster than the base class version.
        """
        return DayPeriod(date_or_period)

    def to_short_string(self):
        return self.display('first_time')


class WeekPeriod(FixedDayPeriod):
    """Represents a week long time period, starting on an arbitrary day"""
    def __init__(self, start_date):
        """start_date - date that this WeekPeriod starts on"""
        super(WeekPeriod, self).__init__(start_date, 7)

    def jump_to(self, date_or_period):
        """Return the nearest WeekPeriod that overlaps with date_or_period and starts
        on the same weekday as self. This is faster than the base class version.
        """
        self_weekday = date_to_weekday(self.first_day())
        date_or_period_weekday = date_to_weekday(date_or_period)
        days_back = (date_or_period_weekday - self_weekday + 7) % 7
        return WeekPeriod(date_or_period - datetime.timedelta(days_back))


class FixedCalendarMonthPeriod(TimePeriod):
    """A TimePeriod that spans a fixed number of calendar months. Every subsequent period is defined relative to
    this start point. For instance a three month period starting in January is not the same as a three month period
    starting in February. The next period for January starts in April and the next for February starts in May.

    Example:

    .. code-block:: python

        five_months = dates.FixedCalendarMonthPeriod(2013, 1, num_months=5)
        five_months
        #yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2013, 1, 1, 0, 0), datetime.datetime(2013, 5, 31, 23, 59, 59, 999999))
        five_months.next_period()
        #yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2013, 6, 1, 0, 0), datetime.datetime(2013, 10, 31, 23, 59, 59, 999999))
        date = datetime.date(2012, 12, 1)
        five_months.jump_to(date)
        #yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2012, 8, 1, 0, 0), datetime.datetime(2012, 12, 31, 23, 59, 59, 999999))
    """
    _num_months = None

    def __init__(self, year, first_month, num_months=None):
        """Takes a year and a month (which specify the first month in the period), and
        an number that indicates the length of the period in months."""
        self.year = int(year)
        self.month = int(first_month)
        first_date = datetime.date(self.year, self.month, 1)
        last_month = first_date + CalendarDuration(months=(num_months - 1))
        _, last_date = first_and_last_date(last_month)

        self._num_months = num_months
        super(FixedCalendarMonthPeriod, self).__init__(first_date, last_date)

    def __str__(self):
        return self.to_short_string()

    def to_short_string(self):
        """Prints the time period based on start year, start month, and number of months in the period.

        Example:

        .. code-block:: python

            five_months = dates.FixedCalendarMonthPeriod(2013, 1, num_months=5)
            five_months.to_short_string()
            #'05@201301'
        """
        return "%.2d@%.4d%.2d" % (self._num_months, self.first_time.year, self.first_time.month)

    @classmethod
    def from_short_string(cls, short_string):
        """Returns a new FixedCalendarMonthPeriod from a string representation: <num_months>@YYYYMM.

        Example:

        .. code-block:: python

            five_months = dates.FixedCalendarMonthPeriod.from_short_string("05@201301")
            #yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2013, 1, 1, 0, 0), datetime.datetime(2013, 5, 31, 23, 59, 59, 999999))
        """
        num_months, year, first_month = int(short_string[0:2]), int(short_string[3:7]), int(short_string[7:9])
        if cls._num_months:
            assert cls._num_months == num_months, "{0} != {1}".format(cls._num_months, num_months)
        return cls.from_date(datetime.date(year, first_month, 1), num_months=num_months)

    def _json_encode(self):
        """JSON encode the FixedCalendarMonthPeriod
        We use the short string to encode the FixedCalendarMonthPeriod
        """
        return {'short_string': self.to_short_string()}

    @classmethod
    def _json_decode(cls, json_dict):
        return cls.from_short_string(json_dict['short_string'])

    def prev_period(self):
        return FixedCalendarMonthPeriod.get_prev_fixed_month_period(self)

    def next_period(self):
        return FixedCalendarMonthPeriod.get_next_fixed_month_period(self)

    @classmethod
    def from_date(cls, date, num_months=None):
        return cls(date.year, date.month, num_months)

    @classmethod
    def get_prev_fixed_month_period(cls, fixed_month_period, num_periods=1):
        """Returns a new FixedCalendarMonthPeriod that is immediately previous to the given
        period. If num_periods is specified, gives the period starting num_periods periods before.

        Example:

        .. code-block:: python

            jan = dates.FixedCalendarMonthPeriod(2013,1)
            dates.FixedCalendarMonthPeriod.get_prev_fixed_month_period(jan)
            #yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2012, 12, 1, 0, 0), datetime.datetime(2012, 12, 31, 23, 59, 59, 999999))
            dates.FixedCalendarMonthPeriod.get_prev_fixed_month_period(a, num_periods=2)
            #yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2012, 11, 1, 0, 0), datetime.datetime(2012, 11, 30, 23, 59, 59, 999999))
        """
        assert isinstance(fixed_month_period, cls)
        new_first_month = fixed_month_period.first_day() - CalendarDuration(months=(fixed_month_period._num_months * num_periods))
        return cls.from_date(datetime.date(new_first_month.year, new_first_month.month, 1), num_months=fixed_month_period._num_months)

    @classmethod
    def get_next_fixed_month_period(cls, fixed_month_period):
        """Returns a new FixedCalendarMonthPeriod that is immediately subsequent to the given
        period.

        Example:

        .. code-block:: python

            jan = dates.FixedCalendarMonthPeriod(2013,1)
            dates.FixedCalendarMonthPeriod.get_next_fixed_month_period(jan)
            #yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2013, 2, 1, 0, 0), datetime.datetime(2013, 2, 28, 23, 59, 59, 999999))
        """
        assert isinstance(fixed_month_period, cls)
        new_first_month = fixed_month_period.first_day() + CalendarDuration(months=fixed_month_period._num_months)
        return cls.from_date(datetime.date(new_first_month.year, new_first_month.month, 1), num_months=fixed_month_period._num_months)

    def jump_to(self, date_or_period):
        """Return the nearest FixedCalendarMonthPeriod that overlaps with date_or_period.

        This is less intuitive than for a day or a month, where you know what day or month you
        are on just by looking at the calendar date. Here you need to remember that that the
        period you are in depends on the start date of the period you're measuring from.
        It's similar to a rolling week in that way, where which week you are in depends on which
        weekday you started counting on.

        Example:

        .. code-block:: python

            date = datetime.date(2013,5,1)
            two_months_from_jan = dates.FixedCalendarMonthPeriod(2013, 1, num_months=2)
            two_months_from_jan.jump_to(date)
            # yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2013, 5, 1, 0, 0), datetime.datetime(2013, 6, 30, 23, 59, 59, 999999))

            two_months_from_feb = dates.FixedCalendarMonthPeriod(2013, 2, num_months=2)
            two_months_from_feb.jump_to(date)
            # yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2013, 4, 1, 0, 0), datetime.datetime(2013, 5, 31, 23, 59, 59, 999999))

            three_months_from_jan = dates.FixedCalendarMonthPeriod(2013, 1, num_months=3)
            three_months_from_jan.jump_to(date)
            # yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2013, 4, 1, 0, 0), datetime.datetime(2013, 6, 30, 23, 59, 59, 999999))

            # Also works for finding the nearest overlapping time period.
            period = dates.FixedCalendarMonthPeriod(2013,1,num_months=1)
            two_months_from_feb.jump_to(period)
            # yelp_lib.dates.FixedCalendarMonthPeriod(datetime.datetime(2012, 12, 1, 0, 0), datetime.datetime(2013, 1, 31, 23, 59, 59, 999999))
        """
        first_time, last_time = self.to_first_and_last_time(date_or_period)
        if last_time < self.first_time:
            return self._new_period_from_date(last_time)
        elif self.last_time < first_time:
            return self._new_period_from_date(first_time)
        else:
            return self

    def _new_period_from_date(self, date):
        """Return the FixedCalendarMonthPeriod containing date that starts
        on the same month offset as self"""
        date = date_to_month(date)
        months_back = self._month_difference(date, self.first_time) % self._num_months
        first_date = date - CalendarDuration(months=months_back)
        return self.from_date(first_date, num_months=self._num_months)

    @staticmethod
    def _month_difference(d1, d2):
        """ Takes two date/datetime objects and returns the number of months between their two dates ceil-ed.
        Returns a negative number if the first date is less than the second.
        Example:

        .. code-block:: python

            dates.month_difference(datetime.date(2013,2,1),datetime.date(2013,1,30))
            #1
        """
        return (d1.year - d2.year)*12 + d1.month - d2.month


class CalendarMonthPeriod(FixedCalendarMonthPeriod):
    """Represents a calendar month long period. It is basically a FixedCalendarMonthPeriod with
    some added features specific to single months.

    Example:

    .. code-block:: python

        january_2013 = dates.CalendarMonthPeriod(2013, 1)
        january_2013.month_name()
        #'Jan'
        january_2013.to_date()
        #datetime.date(2013, 1, 1)
        dates.CalendarMonthPeriod.from_date(january_2013.to_date())
        #yelp_lib.dates.CalendarMonthPeriod(datetime.datetime(2013, 1, 1, 0, 0), datetime.datetime(2013, 1, 31, 23, 59, 59, 999999))
    """
    _num_months = 1

    def __init__(self, year, month):
        super(CalendarMonthPeriod, self).__init__(year, month, num_months=self._num_months)

    def month_name(self):
        return MONTHNAME[self.month]

    def to_short_string(self):
        """Prints the time period based on start year, and start month.

        Example:

        .. code-block:: python

            january_2013 = dates.CalendarMonthPeriod(2013, 1)
            january_2013.to_short_string()
            #'201301'
        """
        return "%.4d%.2d" % (self.year, self.month)

    @classmethod
    def from_short_string(self, short_string):
        year, month = short_string[0:4], short_string[4:]
        return CalendarMonthPeriod(year, month)

    def to_date(self):
        """Convert to an instance of datetime.date.
        returns the first day of the time period"""
        return self.first_day()

    def prev_month(self):
        return CalendarMonthPeriod.get_prev_fixed_month_period(self)

    prev_period = prev_month

    def next_month(self):
        return CalendarMonthPeriod.get_next_fixed_month_period(self)

    next_period = next_month

    @classmethod
    def get_prev_month(cls, billing_period, months=1):
        return CalendarMonthPeriod.get_prev_fixed_month_period(billing_period, num_periods=months)

    @classmethod
    def get_next_month(cls, billing_period):
        return CalendarMonthPeriod.get_next_fixed_month_period(billing_period)

    @classmethod
    def from_date(self, date, num_months=None):
        """Returns a new CalendarMonthPeriod containing the given date"""
        return CalendarMonthPeriod(date.year, date.month)

    @classmethod
    def get_month_range(self, first_month, last_month):
        """Return all the CalendarMonthPeriods between two months inclusive"""
        assert min(first_month, last_month) == first_month
        months = []

        while last_month >= first_month:
            months.append(last_month)
            last_month = last_month.prev_month()

        return months

    @classmethod
    def get_months_between_dates(self, first_date, last_date, inclusive=True):
        """Return all the CalendarMonthPeriods between two timestamps.

        Args:
        first_date -- first date in the interval of interest.
        last_date -- last date in the interval of interest.
        inclusive -- if True, return month(s) that contained the timestamp.
            If False, return the months strictly between first and last dates,
            i.e. first_date not in returned_value and last_date not in returned_value.

        Return: a list of CalendarMonthPeriods.
        """
        assert first_date <= last_date

        months = [self.from_date(first_date)]

        while last_date > months[-1].last_time:
            months.append(months[-1].next_month())

        if not inclusive:
            return months[1:-1]

        return months

    @classmethod
    def get_current_month(self):
        today = default_now()
        return CalendarMonthPeriod(today.year, today.month)


class QuarterPeriod(FixedCalendarMonthPeriod):
    """A FixedCalendarMonthPeriod representing a 3 month period. The Quarter is not a 'calendar quarter' (ie is not alligned to start on Jan-1, April-1, etc).

    Example:

    .. code-block:: python

        Q1 = dates.QuarterPeriod(2013,1)
        Q1
        #yelp_lib.dates.QuarterPeriod(datetime.datetime(2013, 1, 1, 0, 0), datetime.datetime(2013, 3, 31, 23, 59, 59, 999999))
    """
    _num_months = 3

    def __init__(self, year, month):
        """Basically syntactic sugar for dates.FixedCalendarMonthPeriod(...) where num_months=3."""
        super(QuarterPeriod, self).__init__(year, month, num_months=self._num_months)

    @classmethod
    def from_date(cls, date, num_months=None):
        return cls(date.year, date.month)

    def prev_quarter(self):
        return QuarterPeriod.get_prev_fixed_month_period(self)

    prev_period = prev_quarter

    def next_quarter(self):
        return QuarterPeriod.get_next_fixed_month_period(self)

    next_period = next_quarter

    @classmethod
    def get_prev_quarter(cls, billing_period):
        return QuarterPeriod.get_prev_fixed_month_period(billing_period)

    @classmethod
    def get_next_quarter(cls, billing_period):
        return QuarterPeriod.get_next_fixed_month_period(billing_period)


class HalfYearPeriod(FixedCalendarMonthPeriod):
    """A FixedCalendarMonthPeriod representing a 6 month period.

    Example:

    .. code-block:: python

        JantoJun = dates.HalfYearPeriod(2013,1)
        JantoJun
        #yelp_lib.dates.HalfYearPeriod(datetime.datetime(2013, 1, 1, 0, 0), datetime.datetime(2013, 6, 30, 23, 59, 59, 999999))
    """
    _num_months = 6

    def __init__(self, year, month):
        """Basically syntactic sugar for dates.FixedCalendarMonthPeriod(...) where num_months=6."""
        super(HalfYearPeriod, self).__init__(year, month, num_months=self._num_months)

    @classmethod
    def from_date(cls, date, num_months=None):
        return cls(date.year, date.month)

    def prev_half_year(self):
        return HalfYearPeriod.get_prev_fixed_month_period(self)

    prev_period = prev_half_year

    def next_half_year(self):
        return HalfYearPeriod.get_next_fixed_month_period(self)

    next_period = next_half_year

    @classmethod
    def get_prev_half_year(cls, billing_period):
        return HalfYearPeriod.get_prev_fixed_month_period(billing_period)

    @classmethod
    def get_next_half_year(cls, billing_period):
        return HalfYearPeriod.get_next_fixed_month_period(billing_period)


class YearPeriod(FixedCalendarMonthPeriod):
    """A FixedCalendarMonthPeriod representing a 12 month period.

    Example:

    .. code-block:: python

        Year2013 = dates.YearPeriod(2013,1)
        Year2013
        #yelp_lib.dates.YearPeriod(datetime.datetime(2013, 1, 1, 0, 0), datetime.datetime(2013, 12, 31, 23, 59, 59, 999999))
    """
    _num_months = 12

    def __init__(self, year, month):
        """Basically syntactic sugar for dates.FixedCalendarMonthPeriod(...) where num_months=12."""
        super(YearPeriod, self).__init__(year, month, num_months=self._num_months)

    @classmethod
    def from_date(cls, date, num_months=None):
        return cls(date.year, date.month)

    def prev_year(self):
        return YearPeriod.get_prev_fixed_month_period(self)

    prev_period = prev_year

    def next_year(self):
        return YearPeriod.get_next_fixed_month_period(self)

    next_period = next_year

    @classmethod
    def get_prev_year(cls, billing_period):
        return YearPeriod.get_prev_fixed_month_period(billing_period)

    @classmethod
    def get_next_year(cls, billing_period):
        return YearPeriod.get_next_fixed_month_period(billing_period)

def midnight_last_monday(relative_to=None, tzinfo=None):
    """
    Get a datetime for midnight monday before today.
    This is useful because business hours are stored in the DB as
    'minutes since midnight monday'.
    """
    if relative_to:
        tzinfo = relative_to.tzinfo
        today = relative_to.date()
    else:
        # This is the correct date since now() correctly accounts for DST.
        today = datetime.datetime.now(tzinfo).date()
    monday = today - datetime.timedelta(days=today.weekday())
    midnight_monday = datetime.datetime(monday.year, monday.month, monday.day)
    if tzinfo:
            return tzinfo.localize(midnight_monday)
    else:
            return midnight_monday


def negative_milliseconds(now=None):
    if now is None:
        now = time.time()
    return int(now * -1000)


def from_var_dict_to_datetime(time_dict, prefix=None):
    if prefix is None:
        prefix = ''
    else:
        prefix = '%s_' % prefix

    # add field prefixes if non-empty
    time_fields = ['%s%s' % (prefix, field) for field in ('month_day_year', 'time')]  # TODO: need better i18n support?
    time_str = "%s %s" % tuple([time_dict[field] for field in time_fields])
    return datetime.datetime.strptime(time_str, "%m/%d/%Y %I:%M %p")  # TODO: need better i18n support?


def from_datetime_to_var_dict(time_publish_intended):
    """Given a datetime object, split into variables needed for the datetime selector widget"""
    format_dict = dict(month_day_year='%m/%d/%Y', time='%I:%M %p')  # TODO: need better i18n support?
    time_vars = {}
    for field, format in format_dict.iteritems():
        time_vars[field] = time_publish_intended.strftime(format)
    return time_vars


def datetime_from_string(time_str):
    """Do our best to get a datetime.datetime for the given string.

    >>> datetime_from_string("2009")
    ('year', datetime.datetime(2009, 1, 1, 0, 0))
    >>> datetime_from_string("2009-12")
    ('month', datetime.datetime(2009, 12, 1, 0, 0))
    >>> datetime_from_string("2009-12-25")
    ('day', datetime.datetime(2009, 12, 25, 0, 0))
    >>> datetime_from_string("2009-12-25 13")
    ('hour', datetime.datetime(2009, 12, 25, 13, 0))
    >>> datetime_from_string("2009-12-25 13:05")
    ('minute', datetime.datetime(2009, 12, 25, 13, 5))
    >>> datetime_from_string("2009-12-25 13:05:14")
    ('second', datetime.datetime(2009, 12, 25, 13, 5, 14))
    >>> datetime_from_string("2009-12-25 13:05:14.453728")
    ('microsecond', datetime.datetime(2009, 12, 25, 13, 5, 14, 453728))

    Inspired by http://code.activestate.com/recipes/577135/
    """

    formats = [
        "%Y",
        "%Y-%m",
        "%Y-%m-%d",
        "%Y-%m-%d %H",
        "%Y-%m-%d %H:%M",
        "%Y-%m-%d %H:%M:%S",
        "%Y-%m-%dT%H",
        "%Y-%m-%dT%H:%M",
        "%Y-%m-%dT%H:%M:%S"
    ]

    # Anything after a '.' will be microseconds
    if time_str.count('.') == 1:
        time_str, microseconds_str = time_str.split('.')
        # This is magic.
        microseconds = int((microseconds_str + '000000')[:6])
    else:
        microseconds = 0

    for time_str_format in formats:
        try:
            a_time = datetime.datetime.strptime(time_str, time_str_format)
        except ValueError:
            # Try the next format
            continue

        if microseconds:
            assert "%S" in time_str_format, "Can't specify microseconds without specifying seconds! %s" % time_str_format
            a_time = a_time.replace(microsecond=microseconds)

        return a_time
    else:
        # We failed to parse the time string wit any formatter
        def format_to_human(format_str):
            """Make a format string more human readable"""
            return format_str.replace(
                "%Y", "YYYY"
            ).replace(
                "%m", "MM"
            ).replace(
                "%d", "DD"
            ).replace(
                "%H", "HH"
            ).replace(
                "%M", "MM"
            ).replace(
                "%S", "SS"
            )

        raise ValueError(
            "could not determine date from %r: does not match any of the accepted patterns ('%s')"
            % (time_str, [format_to_human(f) for f in formats])
        )


def datetime_from_iso8601(datestring):
    """Parses ISO 8601 dates into datetime objects

    The timezone is parsed from the date string. However it is quite common to
    have dates without a timezone (not strictly correct). In this case the
    default timezone specified in default_timezone is used. This is UTC by
    default.
    """
    return iso8601.parse_date(datestring)


def date_from_iso8601(datestring):
    """Parses ISO 8601 dates into date objects
    """
    return iso8601.parse_date(datestring).date()


def time_delta_total_seconds(td):
    """Returns total seconds for time delata, since timedelta.total_seconds is not available on python < 2.7.
    Note that it rounds down, so time_delta_total_seconds(datetime.timedelta(milliseconds=999)) => 0."""
    return (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10 ** 6) / 10 ** 6


def business_days_ahead_calendar(num_days=0, start_datetime=None, holiday_calendar=None):
    """Return the nth next business day from the input datetime.

    Args -
        num_days: number of days to go ahead
        start_datetime: date or datetime to start from (defaults to now)
        holiday_calendar: collection of dates to avoid in addition to weekends
            (this function will break if you pass in holidays that are also
            weekends)
    Returns -
        the date which is 'num_days' business days ahead of start_datetime

    GOTCHA:
        If the current day is not a work day, going 'n' days forward will
        actually a) go to the first workday, then b) go 'n' days forward
    """
    # TODO: Add time-zone logic
    # TODO: Add cutoff time-of-day logic
    current_date = datetime_to_date(default_now(start_datetime))
    new_date = business_days_ahead(
            num_days,
            current_date,
    )

    if holiday_calendar is not None:
        assert not any(is_weekend(day) for day in holiday_calendar), "Holiday calendar cannot contain weekends"

        date_range = TimePeriod(current_date, new_date)

        # Figure out how many holidays business_days_ahead ignored
        holidays_between_days = sum(date_range.overlaps(holiday) for holiday in holiday_calendar)

        # For each day we ignored, go ahead one day. If we land on a holiday, go ahead again.
        for _ in xrange(holidays_between_days):
            new_date = business_days_ahead(1, new_date)

            if new_date in holiday_calendar:
                new_date = business_days_ahead(1, new_date)

    return new_date


class CalendarDuration(object):
    """Represents duration in terms of years, months and days.

    This is similar to `datetime.timedelta`, but it can represent imprecise
    calendar units (years and months).
    """

    def __init__(self, years=0, months=0, days=0):
        """Instantiate a new `CalendarDuration` lasting `years`, `months` and
        `days`.

        Optional arguments:
        years -- number of years (default `0`)
        months -- number of months (default `0`)
        days -- number of days (default `0`)
        """
        self.years = years
        self.months = months
        self.days = days

    def __add__(self, term):
        """Given a `datetime.date`, return a `datetime.date` that is
        `self.years`, `self.months`, and `self.days` after it.

        If `term` is a `CalendarDuration`, return a new `CalendarDuration` that
        is the sum of `total_months` and `days`.

        Note that `datetime.datetime`s are also `datetime.date`s.
        """
        if isinstance(term, datetime.date):
            return add_months(term, self.months, self.years) + datetime.timedelta(days=self.days)
        else:
            return type(self)(
                months=self.total_months + term.total_months,
                days=self.days + term.days
            )

    __radd__ = __add__

    def __rsub__(self, a_date):
        """Given a `datetime.date`, return a `datetime.date` that is
        `self.years`, `self.months`, and `self.days` before it.

        Note that `datetime.datetime`s are also `datetime.date`s.
        """
        return a_date + type(self)(-self.years, -self.months, -self.days)

    def __sub__(self, calendar_duration):
        """Return a new `CalendarDuration` that is the difference between
        `self` and `calendar_duration`.
        """
        return type(self)(
            months=self.total_months - calendar_duration.total_months,
            days=self.days - calendar_duration.days
        )

    def __nonzero__(self):
        """Return `False` if years, months and days are all 0."""
        return any((self.years, self.months, self.days))

    def __repr__(self):
        return '%s(years=%d, months=%d, days=%d)' % (type(self).__name__, self.years, self.months, self.days)

    def __eq__(self, calendar_duration):
        if calendar_duration is None:
            return None

        return (self.years, self.months, self.days) == (calendar_duration.years, calendar_duration.months, calendar_duration.days)

    def _get_months(self):
        return self._months

    def _set_months(self, value):
        """Set the number of months. If `value` is at least a year, add the
        value to `self.years` and store the remaining months.
        """
        if value < 12:
            self._months = value
        else:
            self.years += value // 12
            self._months = value % 12

    months = property(_get_months, _set_months)

    @property
    def total_months(self):
        """Return the total number of months represented (including years).

        Note that this does not take days into account. Days cannot be factored
        into months.
        """
        return (self.years * 12) + self.months

    @classmethod
    def from_dates(cls, start_date, end_date):
        """Return the `CalendarDuration` to represent the difference between
        `end_date` and `start_date`.

        >>> CalendarDuration.from_dates(start_date=datetime.datetime(2010, 2, 17), end_date=datetime.datetime(2011, 3, 17))
        CalendarDuration(years=1, months=1, days=0)
        """
        # If months exceed 12, they will overflow into years.
        end_date_total_months = (end_date.year * 12) + end_date.month
        start_date_total_months = (start_date.year * 12) + start_date.month
        return cls(
            months=end_date_total_months - start_date_total_months,
            days=end_date.day - start_date.day
        )


# Begin old dates.py

def convert_timezone(dt, source_timezone, target_timezone):
    """Convert `dt` from `from_timezone` to `target_timezone` and return a
    naive datetime.datetime.

    Arguments:
    dt -- a naive datetime.datetime
    source_timezone -- source time zone string or datetime.tzinfo
    target_timezone -- target time zone string or datetime.tzinfo
    """
    return convert_timezone_tz_aware(dt, source_timezone, target_timezone).replace(tzinfo=None)


def convert_timezone_tz_aware(dt, source_timezone, target_timezone):
    """Convert `dt` from `from_timezone` to `target_timezone` and return a
    tz aware datetime.datetime.

    Arguments:
    dt -- a naive datetime.datetime
    source_timezone -- source time zone string or datetime.tzinfo
    target_timezone -- target time zone string or datetime.tzinfo
    """
    if isinstance(source_timezone, basestring):
        source_timezone = pytz.timezone(source_timezone)
    if isinstance(target_timezone, basestring):
        target_timezone = pytz.timezone(target_timezone)

    if dt.tzinfo == source_timezone:
        dt_localized_to_source_timezone = dt
    else:
        assert dt.tzinfo is None, '`dt` must be a naive datetime.datetime or must match source_timezone'
        dt_localized_to_source_timezone = source_timezone.localize(dt)

    return dt_localized_to_source_timezone.astimezone(target_timezone)


def strptime_datetime(datestring, strptime_fmt):
    """convert datestring and strptime formatstring to a datetime
    object with the date field set."""
    ts = time.strptime(datestring, strptime_fmt)
    return datetime.datetime(year=ts[0], month=ts[1], day=ts[2])


def strptime_date(datestring, strptime_fmt=STD_DATE_FORMAT):
    """convert datestring and strptime formatstring to a date."""
    return strptime_datetime(datestring, strptime_fmt).date()


def current_date_in_time_zone(tz):
    """Get the current date in the given timezone."""
    date = pytz.timezone('UTC').localize(datetime.datetime.utcnow())
    encoded_tz = pytz.timezone(tz.encode('utf-8'))
    return date.astimezone(encoded_tz)


def now_as_timezone(tz=None):
    """Return the current time and date as a datetime.datetime

    Arguments
    tz -- the pytz time zone to return the date in

    Returns
    a datetime
    """
    dt = datetime.datetime.now()
    if tz is not None:
        dt = OUR_TIMEZONE.localize(dt)
        dt = dt.astimezone(tz)

    return dt


def today_as_timezone(tz=None):
    """Return today's date

    Arguments
    tz --
    """
    dt = datetime.datetime.now()
    if tz is not None:
        dt = OUR_TIMEZONE.localize(dt)
        if tz is not None:
            dt = dt.astimezone(tz)
    return dt.date()


def this_weekend(no_past=False, tz=None):
    """return next Friday, Sunday as dates.
    If no_past is true, return today rather than Friday
    if Friday is in the past."""
    _today = today_as_timezone(tz=tz)

    monday = _today - datetime.timedelta(_today.weekday())
    friday_weekday = 4
    sunday_weekday = 6
    friday = monday + datetime.timedelta(friday_weekday)
    sunday = monday + datetime.timedelta(sunday_weekday)

    if no_past and friday < _today:
        return _today, sunday
    else:
        return friday, sunday


def this_week(min_days_in_this_week=1, tz=None):
    """return (today, next sunday) as dates. You can optionally set what "today" is, for debugging and testing.

    Setting min_days_in_this_week allows you to guarantee that there are at least that many distinct days in
    the week returned (inclusive). For example, if today is Sunday, and min_days_in_this_week = 2, will return
    (today, NEXT sunday). Default is 1 (today and sunday may be the same day)."""
    _today = today_as_timezone(tz=tz)

    sunday = _today + datetime.timedelta(6 - _today.weekday())

    while(sunday - _today < datetime.timedelta(min_days_in_this_week - 1)):
        sunday += datetime.timedelta(7)

    return _today, sunday


def next_week(*args, **kwargs):
    """Return the monday after this_week() and the following sunday, as a tuple. Passes any (optional) arguments on to this_week()"""
    # next monday is the day after the sunday at the end of this week
    next_monday = this_week(*args, **kwargs)[1] + datetime.timedelta(1)
    next_sunday = next_monday + datetime.timedelta(6)
    return next_monday, next_sunday


def week_after_next(*args, **kwargs):
    return tuple(i + datetime.timedelta(7) for i in next_week(*args, **kwargs))


def find_weekdays(num_days=1, weekday_to_find=1, offset_days=0, ascending=True, tz=None):
    """by default, returns an array of 1 (num_days=1) next (ascending) tuesday (weekday_to_find=1)
    starting today (offset=0)"""

    _today = today_as_timezone(tz=tz)
    counter = _today + datetime.timedelta(offset_days)
    weekdays = []

    while(len(weekdays) < num_days):
        if counter.weekday() == weekday_to_find:
            weekdays.append(counter)
        if ascending:
            counter += datetime.timedelta(1)
        else:
            counter -= datetime.timedelta(1)
    return weekdays


def age_from_date(year, month, day):
    """Return the age and date of something in years, given its creation date. This will
    raise ValueError if year/month/day are not valid ints or are not a valid date.
    """
    birthdaydate = datetime.date(int(year), int(month), int(day))
    now = datetime.date.today()
    age = now.year - birthdaydate.year
    # Checks that the day/month within the year is earlier then the birthdays
    # day/month in its year.  If they are, the thing is technically a year
    # younger then the year would have you believe.
    if (now.month, now.day) < (birthdaydate.month, birthdaydate.day):
        age -= 1
    return age


# yelp_lib/dates.py

def current_hour():
    """Return the current hour, as an int"""
    return int(time.time() / 3600)


def unix_time():
    return int(time.time())


def unix_date():
    return to_timestamp(datetime.datetime.now().date())


def to_day_num(d):
    """
    Makes a best-effort attempt to convert `d` to an integral
    day number, as would be emitted by datetime.date.toordinal().

    Arguments:
        This method will work if `d` is a date, a datetime, an integer, a float,
        or None.  If d is None, the method is a no-op.
    """
    if d is None:
        return None
    elif isinstance(d, datetime.date):
        return d.toordinal()
    elif isinstance(d, datetime.datetime):
        return d.date().toordinal()
    elif isinstance(d, int):
        return d
    elif isinstance(d, float):
        return datetime.datetime.fromtimestamp(d).date()
    else:
        raise TypeError("non-date, non-datetime, non-integer argument!")


def get_next_month(month, strftime_fmt=None, month_count=1):
    """Given a month, return a datetime representing the first day of the next month"""
    if isinstance(month, str) and strftime_fmt:
        ts = time.strptime(month, strftime_fmt)
        month = datetime.datetime(year=ts[0], month=ts[1], day=ts[2])
    else:
        assert isinstance(month, (datetime.date, datetime.datetime))

    next_month = month
    for _ in range(month_count):
        if next_month.month == 12:
            next_month_month = 1
            next_month_year = next_month.year + 1
        else:
            next_month_month = next_month.month + 1
            next_month_year = next_month.year
        next_month = datetime.datetime(next_month_year, next_month_month, 1)

    return next_month


def get_prev_month(month, strftime_fmt=None, month_count=1):
    """Given a month, return a datetime representing the first day of the previous month."""
    if isinstance(month, str) and strftime_fmt:
        ts = time.strptime(month, strftime_fmt)
        month = datetime.datetime(year=ts[0], month=ts[1], day=ts[2])
    else:
        assert isinstance(month, (datetime.date, datetime.datetime))

    prev_month = month
    for _ in range(month_count):
        if prev_month.month == 1:
            prev_month_month = 12
            prev_month_year = prev_month.year - 1
        else:
            prev_month_month = prev_month.month - 1
            prev_month_year = prev_month.year
        prev_month = datetime.datetime(prev_month_year, prev_month_month, 1)

    return prev_month


def get_days_in_month(month, strftime_fmt=None):
    """
    Get the number of days in the month, (month - timestamp), date, or datetime value.
    """
    if isinstance(month, datetime.datetime):
        pass
    elif isinstance(month, datetime.date):
        month = datetime.datetime(year=month.year, month=month.month, day=month.day)
    elif isinstance(month, str) and strftime_fmt:
        ts = time.strptime(month, strftime_fmt)
        month = datetime.datetime(year=ts[0], month=ts[1], day=ts[2])
    else:
        month = datetime.datetime.fromtimestamp(month)

    # get the first day in the following month and subtract to get the last day in the target month
    next_month = get_next_month(month)
    month_last_day = next_month - datetime.timedelta(seconds=1)

    return month_last_day.day


def get_max_timestamp_in_day(day):
    """
    Get a timestamp value representing the last second of the last hour of the day,
    (day - timestamp), date, or datetime value.
    """
    if isinstance(day, datetime.datetime):
        pass
    elif isinstance(day, datetime.date):
        day = datetime.datetime(year=day.year, month=day.month, day=day.day)
    else:
        day = datetime.datetime.fromtimestamp(day)

    # get start of day day_number and the following day in epoch seconds
    day_number = day.toordinal()
    next_day = datetime.datetime.fromordinal(day_number + 1)
    day_end_timestamp = int(time.mktime(next_day.timetuple())) - 1

    return day_end_timestamp


def get_min_max_datetimes_in_month(month, strftime_fmt=None):
    """
    Get datetime values representing the min date in the first day,
    and the max time value on the last day of the month.
    """
    if isinstance(month, datetime.datetime):
        pass
    elif isinstance(month, datetime.date):
        pass
    elif isinstance(month, str) and strftime_fmt:
        ts = time.strptime(month, strftime_fmt)
        month = datetime.datetime(year=ts[0], month=ts[1], day=ts[2])
    else:
        month = datetime.datetime.fromtimestamp(month)

    month_min_datetime = month.replace(day=1)
    last_day_month = month.replace(day=get_days_in_month(month))
    month_max_datetime = datetime.datetime.fromtimestamp(get_max_timestamp_in_day(last_day_month))

    return month_min_datetime, month_max_datetime
