from __future__ import absolute_import, division, print_function

import logging
import warnings

import pyramid.httpexceptions
from pyramid.interfaces import IExceptionResponse
import pyramid.tweens

log = logging.getLogger(__name__)


def get_session_context_by_request(request, session):
    """Determine the correct session to use for the request.

    :param request: a :class:`pyramid.request.Request`
    :param session: a :class:`yelp_conn.session.YelpConnSession`
    :returns: a context manager for the session
    """
    if request.method != 'GET':
        log.info("Setting session to master_write.")
        session.enforce_read_only = False
        return session.master_connection_set

    if request.headers.get('X-Force-Master-Read') in (b'1', b'True'):
        log.info("Setting session to master_read.")
        return session.master_connection_set

    log.info("Setting session to slave_read.")
    return session.slave_connection_set


class AbortResponse(Exception):
    def __init__(self, response, exc):
        self.response = response
        self.exc = exc


def session_tween_factory(handler, registry):
    """Tween to put the session into the right state per request dependent upon
    request method, and return the session to the default state at the end of
    the request.

    The behavior is to wrap the request in:
     * ``session.connection_set_master_write`` on a non-``GET`` request
     * ``session.connection_set_master_read`` if the ``X-Force-Master-Read``
       header is set
     * ``session.connection_set_slave_read`` otherwise

    .. seealso::

        :mod:`yelp_clientlib.schemas` for details about the
        ``X-Force-Master-Read`` header.

    :param handler: a pyramid view handler
    :param registry: a :class:`pyramid.registry.Registry`
    :returns: a pyramid view wrapped in the correct yelp_conn.session context
    """
    try:
        session = registry.yelp_conn_session
    except AttributeError:
        raise AttributeError("yelp_conn_session not found on registry, use "
                             "config.set_yelp_conn_session")

    def commit_veto(request, response, exc):
        if response is None and IExceptionResponse.providedBy(exc):
            response = exc

        if response is None and exc:
            raise exc

        return response.status.startswith(('4', '5'))

    def session_tween(request):
        response = None
        exc = None
        try:
            with get_session_context_by_request(request, session):
                try:
                    response = handler(request)
                except Exception as e:
                    exc = e
                if commit_veto(request, response, exc):
                    raise AbortResponse(response, exc)
                session.commit()
                if exc:
                    raise exc
                return response
        except AbortResponse as e:
            session.rollback()
            if e.exc:
                raise e.exc
            return e.response
        except:
            session.rollback()
            raise
        finally:
            session.enforce_read_only = True
            session.remove()
    return session_tween


def set_yelp_conn_session(config, yelp_conn_session):
    def register():
        config.registry.yelp_conn_session = yelp_conn_session

    config.action('yelp_conn_session', register)


def includeme(config):
    config.add_directive('set_yelp_conn_session', set_yelp_conn_session)

    if 'pyramid_yelp_conn.session' in config.registry.settings:
        warnings.warn("Using settings['pyramid_yelp_conn.session'] is "
                      "deprecated, use config.set_yelp_conn_session instead",
                      DeprecationWarning)
        config.set_yelp_conn_session(
            config.registry.settings['pyramid_yelp_conn.session'])

    config.add_tween("pyramid_yelp_conn.session.session_tween_factory",
                     under=pyramid.tweens.EXCVIEW)
