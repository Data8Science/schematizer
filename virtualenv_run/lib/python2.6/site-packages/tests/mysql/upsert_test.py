# -*- coding: utf-8 -*-
import sqlalchemy
import testify as T
from sqlalchemy.ext.declarative import declarative_base

from yelp_conn.mysql.upsert import upsert_many
from yelp_conn.testing.sqlalchemy_test_case import SQLAlchemyTestCase


Base = declarative_base()


class UpsertTestCase(SQLAlchemyTestCase):

    def create_test_table(self):
        """Creates the test table.  Not an @setup because of setup order issues."""
        self.test_table = sqlalchemy.Table(
            'upsert_many_test_table',
            sqlalchemy.MetaData(),
            sqlalchemy.Column('a', sqlalchemy.Integer, primary_key=True),
            sqlalchemy.Column('b', sqlalchemy.Integer),
            sqlalchemy.Column('c', sqlalchemy.Integer),
            sqlalchemy.Column('d', sqlalchemy.Integer),
            mysql_engine='InnoDB',
        )

        with self.session_begin() as session:
            self.test_table.create(session.bind)

        class TestModel(Base):
            __table__ = self.test_table

            def __eq__(self, other):
                return  self.a == other.a and self.b == other.b and self.c == other.c and self.d == other.d

        self.test_model = TestModel

    def test_upsert_many_one_key(self):
        # Set up the table
        self.create_test_table()
        rows = [
            {'a': 1, 'b': 0, 'c': 0, 'd': 0},
            {'a': 2, 'b': 0, 'c': 0, 'd': 0},
        ]
        with self.session_begin() as session:
            session.execute(self.test_table.insert(), rows)

        # This should update the second row, leave the first alone, and add a third
        upsert_rows = [
            {'a': 2, 'b': 1, 'c': 1, 'd': 0},
            {'a': 3, 'b': 0, 'c': 0, 'd': 1},
        ]
        with self.session_begin() as session:
            upsert_many(self.test_model, session, [self.test_model.a], upsert_rows)

        # Validate results
        with self.session_begin() as session:
            actual_rows = session.query(self.test_model).order_by(self.test_model.a).all()
            for row in actual_rows:
                session.expunge(row)

        expected_rows = rows[:1] + upsert_rows
        for expected_row, actual_row in zip(expected_rows, actual_rows):
            T.assert_equal(expected_row['a'], actual_row.a)
            T.assert_equal(expected_row['b'], actual_row.b)
            T.assert_equal(expected_row['c'], actual_row.c)
            T.assert_equal(expected_row['d'], actual_row.d)

    def test_upsert_many_multikey(self):
        # Set up the table
        self.create_test_table()
        rows = [
            {'a': 1, 'b': 1, 'c': 1, 'd': 0},
            {'a': 2, 'b': 1, 'c': 0, 'd': 0},
            {'a': 3, 'b': 0, 'c': 1, 'd': 0},
        ]
        with self.session_begin() as session:
            session.execute(self.test_table.insert(), rows)

        # This should update the first row, leave the second and third alone,
        # and add a fourth
        upsert_rows = [
            {'a': 4, 'b': 1, 'c': 1, 'd': 0},
            {'a': 5, 'b': 0, 'c': 0, 'd': 1},
        ]
        with self.session_begin() as session:
            upsert_many(self.test_model, session, [self.test_model.b, self.test_model.c], upsert_rows)

        # Validate results
        with self.session_begin() as session:
            actual_rows = session.query(self.test_model).order_by(self.test_model.a).all()
            for row in actual_rows:
                session.expunge(row)

        expected_rows = rows[1:] + upsert_rows
        for expected_row, actual_row in zip(expected_rows, actual_rows):
            T.assert_equal(expected_row['a'], actual_row.a)
            T.assert_equal(expected_row['b'], actual_row.b)
            T.assert_equal(expected_row['c'], actual_row.c)
            T.assert_equal(expected_row['d'], actual_row.d)

if __name__ == '__main__':
    T.run()
