# -*- coding: utf-8 -*-
import sqlalchemy
import testify as T

from yelp_conn.mysql.insert import insert_on_duplicate_update
from yelp_conn.testing.sqlalchemy_test_case import SQLAlchemyTestCase


class InsertOnDuplicateUpdateTest(SQLAlchemyTestCase):

    __reuse_mysqld_for_tests__ = True

    @T.class_setup
    def create_test_table(self):
        self.test_table = sqlalchemy.Table(
            'insert_on_duplicate_update',
            sqlalchemy.MetaData(),
            # id will be used as the unique check
            sqlalchemy.Column('id', sqlalchemy.Integer, primary_key=True),
            # value will change with updates
            sqlalchemy.Column('value', sqlalchemy.Integer),
            # constant will stay the same even when (id, value) updated
            sqlalchemy.Column('constant', sqlalchemy.Integer),
            mysql_engine='InnoDB',
        )

        with self.session_begin() as session:
            self.test_table.create(session.bind)

    def test_insert_on_duplicate_update(self):

        # new rows
        new_rows = [{"id": 1, "value": 100, "constant": -1},
                    {"id": 2, "value": 200, "constant": -2},
                    {"id": 3, "value": 300, "constant": -3}]
        with self.session_begin() as session:
            session.execute(insert_on_duplicate_update(
                self.test_table,
                update_columns=[self.test_table.c.value]),
                            new_rows)

        with self.session_begin() as session:
            T.assert_equal(
                [(1, 100, -1),
                 (2, 200, -2),
                 (3, 300, -3)],
                map(tuple, session.query(self.test_table).order_by(self.test_table.c.id)))

        # partial overwrite rows
        partial_rows = [{"id": 2, "value": 400},
                        {"id": 3, "value": 600}]
        with self.session_begin() as session:
            session.execute(insert_on_duplicate_update(
                self.test_table,
                update_columns=[self.test_table.c.value]),
                            partial_rows)

        with self.session_begin() as session:
            T.assert_equal(
                [(1, 100, -1),
                 (2, 400, -2),
                 (3, 600, -3)],
                map(tuple, session.query(self.test_table).order_by(self.test_table.c.id)))

        # partial overwrites + new rows
        partial_new_rows = [{"id": 2, "value": 800, "constant": -20},
                            {"id": 3, "value": 1200, "constant": -30},
                            {"id": 4, "value": 400, "constant": -40},
                            {"id": 5, "value": 500, "constant": -50}]
        with self.session_begin() as session:
            session.execute(insert_on_duplicate_update(
                self.test_table,
                update_columns=[self.test_table.c.value]),
                            partial_new_rows)

        with self.session_begin() as session:
            T.assert_equal(
                [(1, 100, -1),
                 (2, 800, -2),
                 (3, 1200, -3),
                 (4, 400, -40),
                 (5, 500, -50)],
                map(tuple, session.query(self.test_table).order_by(self.test_table.c.id)))

    def test_insert_no_updates(self):
        """The ON DUPLICATE UPDATE SQL statement requires column expressions,
        so don't allow the function to be called without any"""
        T.assert_raises(ValueError,
                        insert_on_duplicate_update,
                        self.test_table,
                        update_columns=[])

    def test_insert_sql_injection(self):
        """Attempt to inject strings into SQL statement by way of column
        names."""
        T.assert_raises(ValueError,
                        insert_on_duplicate_update,
                        self.test_table,
                        update_columns=[self.test_table.c.value,
                                        "; DROP TABLE students;"])


if __name__ == '__main__':
    T.run()
