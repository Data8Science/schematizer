from testify import assert_equal, assert_raises, run

from yelp_conn.mysql.create import column
from yelp_conn.mysql.create import create_table
from yelp_conn.mysql.create import index
from yelp_conn.mysql.create import unique_index
from yelp_conn.mysql.drop import drop_table
from yelp_conn.mysql.merge import create_merge_table
from yelp_conn.mysql.merge import sub_tables
from yelp_conn.mysqldb import OperationalError
from yelp_conn.testing.mysql_test_case import MySQLTestCase


class TestMergeTables(MySQLTestCase):

    def test_no_sub_tables(self):
        assert_raises(ValueError, create_merge_table, self.cursor, 'empty', [])

    def test_if_exists_options_are_exclusive(self):
        assert_raises(ValueError, create_merge_table, self.cursor, 'foo', ['bar'], alter_if_exists=True, drop_if_exists=True)

    def test_merge_table_merges_tables(self):
        # create 5 tables, each with a single row
        for i in range(5):
            tbl_name = 'foo_%i' % i
            create_table(self.cursor, tbl_name, column('x', 'INT'), engine='MyISAM')
            self.cursor.execute('INSERT INTO `%s` (x) VALUES (%%(i)s)' % tbl_name, locals())

        create_merge_table(self.cursor, 'foo', ['foo_%i' % i for i in range(5)])

        self.cursor.execute('SELECT * FROM foo')
        assert_equal(set(range(5)), set(row[0] for row in self.cursor.fetchall()))

        # try dropping one of the tables, and rebuilding the merge table
        create_merge_table(self.cursor, 'foo', ['foo_%i' % i for i in range(1,5)], alter_if_exists=True)
        # have to drop the table after the merge table has already been altered or get an
        # OperationalError on mysql 5.5
        drop_table(self.cursor, 'foo_0')

        self.cursor.execute('SELECT * FROM foo')
        assert_equal(set(range(1,5)), set(row[0] for row in self.cursor.fetchall()))

        assert_equal(set(sub_tables(self.cursor, 'foo')), set('foo_%i' % i for i in range(1,5)))

        # try this again, using the drop_if_exists option
        drop_table(self.cursor, 'foo_1')
        create_merge_table(self.cursor, 'foo', ['foo_%i' % i for i in range(2,5)], drop_if_exists=True)

        self.cursor.execute('SELECT * FROM foo')
        assert_equal(set(range(2,5)), set(row[0] for row in self.cursor.fetchall()))

        assert_equal(set(sub_tables(self.cursor, 'foo')), set('foo_%i' % i for i in range(2,5)))

        # need to specify one option or the other; can't just re-create
        # an existing table
        assert_raises(OperationalError, create_merge_table, self.cursor, 'foo', ['foo_%i' % i for i in range(2,5)])

    def test_cant_merge_innodb_tables(self):
        # create 2 InnoDB tables
        create_table(self.cursor, 'inno1', column('x', 'INT'), engine='InnoDB')
        create_table(self.cursor, 'inno2', column('x', 'INT'), engine='InnoDB')

        # should work to create the merge table, but not to select from it
        create_merge_table(self.cursor, 'inno', ['inno1', 'inno2'])
        assert_raises(OperationalError, self.cursor.execute, 'SELECT * FROM inno')

    def test_merge_table_has_same_spec(self):
        for i in range(2):
            tbl_name = 'employee_%i' % i
            create_table(
                self.cursor, tbl_name,
                column('id', 'INT', primary_key=True, auto_increment=True),
                column('first_name', 'VARCHAR(255)'),
                column('last_name', 'VARCHAR(255)'),
                index('first_name'),
                unique_index('last_name', 'first_name'),
                engine='MyISAM',
            )

        create_merge_table(self.cursor, 'employee', ['employee_0', 'employee_1'])

        self.assert_tables_have_same_column_defs('employee_1', 'employee')
        self.assert_tables_have_same_index_defs('employee_1', 'employee')

if __name__ == '__main__':
    run()
