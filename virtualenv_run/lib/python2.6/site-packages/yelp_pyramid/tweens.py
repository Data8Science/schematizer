# -*- coding: utf-8 -*-
"""Tweens go around applications at the Pyramid level and have access to a
large number of the internals of the system. These tweens are for common
things required by Yelp services.

By default, :func:`.clog_logging_factory` is added when you include
:mod:`.yelp_pyramid` into your Pyramid config.


.. seealso::

    You can get more details about tweens in `pyramid documentation`_

.. _pyramid documentation:
   http://pyramid.readthedocs.org/en/latest/narr/hooks.html#registering-tweens
"""
from __future__ import absolute_import

import logging
import os
import socket
import struct
import time
import traceback
import warnings

import clog
import simplejson as json
import pyramid.tweens
import staticconf
from pyramid.httpexceptions import WSGIHTTPException


log = logging.getLogger(__name__)


yelp_pyramid_namespace = staticconf.NamespaceGetters('yelp_pyramid')

access_log_name = yelp_pyramid_namespace.get_string('access_log_name')
error_log_name = yelp_pyramid_namespace.get_string('error_log_name')

ACCESS_LOG_ENABLED_KEY = 'access_log_enabled'
ERROR_LOG_ENABLED_KEY = 'error_log_enabled'
_staticconf_access_log_enabled = yelp_pyramid_namespace.get_bool(
    ACCESS_LOG_ENABLED_KEY, default=True)
_staticconf_error_log_enabled = yelp_pyramid_namespace.get_bool(
    ERROR_LOG_ENABLED_KEY, default=True)


def access_log_enabled(registry):
    """Check the registry to see if we need to log accesses.

    Backs off to the staticconf value if data not present in the registry."""
    return registry.settings.get(ACCESS_LOG_ENABLED_KEY,
                                 _staticconf_access_log_enabled)


def error_log_enabled(registry):
    """Check the registry to see if we need to log errors.

    Backs off to the staticconf value if data not present in the registry."""
    return registry.settings.get(ERROR_LOG_ENABLED_KEY,
                                 _staticconf_error_log_enabled)


def logging_enabled(registry):
    """Check the registry to see if we need to do logging.

    Backs off to the staticconf values if data not present in the registry."""
    return access_log_enabled(registry) or error_log_enabled(registry)


def full_request_logging_enabled(registry):
    """Check the registry to see if full_request_logging is enabled

    Defaults to False if not specified. full_request_logging controls how much
    of a request is logged. Because if enabled extra request infromation is
    logged full_request_logging is space intensive and can lead to logging of
    PII. Use full_request_logging with caution.
    """
    full_request_logging = registry.settings.get(
        'full_request_logging_enabled',
        False
    )

    if full_request_logging:
        warnings.warn(
            'full_request_logging enabled - full_request_logging can possibly '
            'lead to the logging of personally identifiable information (PII).'
            ' See y/full_request_logging'
        )
    return full_request_logging


def get_unique_request_id():
    # Returns just a random value to use as a unique_request_id
    return os.urandom(8).encode('hex')


def dump_logging_data(request):
    """Given a request, dumps the current log data as a dictionary for
    storage/logging purposes."""
    return request.clog_data


def log_exception(request, version, full_request_logging=False):
    """Logs an unhandled exception using clog.

    request is formatted depending on full_request_logging.
    full_request_logging is space intensive and can lead to the logging of PII.
    """
    formatted_tb = traceback.format_exc()
    tb_dict = {
        'logger': __name__,
        'level': 'ERROR',  # same as above
        'message': 'service exception',
        'notify': {},
        'packed_time': struct.pack('<d', time.time()).encode('hex'),
        'hostname': socket.gethostname(),
        'unique_request_id': request.unique_request_id,
        'request': format_request_for_logging_error(
            request,
            version,
            full_request_logging=full_request_logging
        ),
        'traceback': formatted_tb.split('\n')
    }
    log_tb = json.dumps(tb_dict)
    clog.log_line(str(error_log_name), log_tb)


def format_request_for_logging_error(
    request,
    version,
    full_request_logging=False
):
    """Formats a request for logging an exception.

    :param request: a request object
    :param full_request_logging:
        a flag specifying how much information should be logged.
        full_request_logging is disabled by default and is space intensive and
        can lead to the logging of PII. Turn on with caution.

    attempt_to_parse_json_request_body is used to convert the request body to
    json if possible
    """
    request_dict = dict(
        host=request.headers.get('Host'),
        ip=request.headers.get('X-Forwarded-For', request.remote_addr),
        method=request.method,
        referer=request.headers.get('Referer'),
        uri=request.url,
        user_agent=request.headers.get('User-Agent'),
        version=version,
    )

    # Add additional parameters based on full_request_logging
    if full_request_logging:
        request_dict.update(
            dict(
                path=request.path,
                params=dict(request.params),
                headers=dict(request.headers),
                body=attempt_to_parse_json_request_body(request)
            )
        )

    return request_dict


def prepare_logging_data_for_request(request, full_request_logging=False):
    """Prepares access logging information upon request arrival.

    A `unique_request_id` and `clog_data` attribute are attached to the request
    instance. Whatever is in `clog_data` will be serialized into the access log
    at the end of the request.
    """

    request.unique_request_id = get_unique_request_id()
    request.clog_data = {
        'hostname': socket.gethostname(),
        'unique_request_id': request.unique_request_id,
        'tracking_id': request.headers.get('X-Tracking-Id'),
        'time': time.time(),
        'time_elapsed': None,
        'method_name': 'Unknown',
        'request': format_request_for_logging(
            request,
            full_request_logging=full_request_logging
        ),
        'response': {}
    }


def format_request_for_logging(request, full_request_logging=False):
    """Formats a request for logging.

    :param request: a request object
    :param full_request_logging:
        a flag specifying how much information should be logged.
        full_request_logging is disabled by default and is space intensive and
        can lead to the logging of PII. Turn on with caution.

    attempt_to_parse_json_request_body is used to convert the request body to
    json if possible
    """
    request_dict = dict(
        host=request.headers.get('Host'),
        method=request.method,
        remote_ip=request.headers.get('X-Forwarded-For', request.remote_addr),
        uri=request.url,
    )

    # Add additional parameters based on full_request_logging
    if full_request_logging:
        request_dict.update(
            dict(
                path=request.path,
                params=dict(request.params),
                headers=dict(request.headers),
                body=attempt_to_parse_json_request_body(request)
            )
        )

    return request_dict


def log_access(request, response, full_request_logging=False):
    """Logs a service access using clog.

    If the `prepare_logging_data_for_request` was not called on the
    request object before executing the request, the method will be
    called for you, but the request will not be timed properly.
    """
    # The absence of clog_data implies the user did not invoke
    # the prepare_logging_data_for_request method
    if not hasattr(request, 'clog_data'):
        prepare_logging_data_for_request(
            request,
            full_request_logging=full_request_logging
        )

    if request.matched_route:
        request.clog_data['method_name'] = request.matched_route.name
    current_time = time.time()
    request.clog_data['time_elapsed'] = (
        current_time - request.clog_data.get('time', current_time))
    if response:
        request.clog_data['response'] = {
            'status_code': response.status_int,
        }
    clog.log_line(str(access_log_name), json.dumps(request.clog_data))


def clog_logging_factory(handler, registry):
    """This tween adds logging around your application at the highest level
    possible.

    This logs to two scribe logs, the access log and the error log.

    The name of the logs is pulled from the
    `yelp_pyramid` namespace with `staticconf` with the keys of
    `access_log_name` and `error_log_name`.

    Logging can be individually enabled or disabled by using the
    `access_log_enabled` and `error_log_enabled` keys within the same
    namespace.

    Additional logging of other request parameters is supported through
    full_request_logging. full_request_logging should be used with caution
    as it is space intensive and can lead to the logigng of PII.
    """

    # Get the version once upon tween loading.
    version = registry.get('version', 'development')
    full_request_logging = full_request_logging_enabled(registry)

    def clog_logging_tween(request):
        if access_log_enabled(registry):
            prepare_logging_data_for_request(
                request,
                full_request_logging=full_request_logging
            )
        else:
            request.unique_request_id = get_unique_request_id()
            request.clog_data = {}

        response = None
        try:
            response = handler(request)
        except WSGIHTTPException:
            raise
        except Exception:
            if error_log_enabled(registry):
                log_exception(
                    request,
                    version,
                    full_request_logging=full_request_logging
                )
            raise
        finally:
            if access_log_enabled(registry):
                log_access(
                    request,
                    response,
                    full_request_logging=full_request_logging
                )
        return response

    return clog_logging_tween


def attempt_to_parse_json_request_body(request):
    """Takes a request object and attempts to return the json form of the body.
    If the request body is not valid json the original body is returned.
    """
    try:
        return request.json_body
    except ValueError:
        return request.body


def includeme(config):
    if logging_enabled(config.registry):
        config.add_tween("yelp_pyramid.tweens.clog_logging_factory",
                         under=pyramid.tweens.INGRESS)
