"""Backports from future versions of SQLA, because this is easier than actually
upgrading.
"""
from __future__ import absolute_import

from sqlalchemy import exc
import sqlalchemy.pool
from sqlalchemy.util import queue as sqla_queue
import threading


class QueuePool(sqlalchemy.pool.Pool):
    """SQLAlchemy's `QueuePool` class, backported from 0.9 for several fixes:

    - The `recreate` method didn't pass along `reset_on_return`.
    - Connecting could deadlock against itself, if the GC happened to run and
      discard an existing connection while one was being checked out.
    """

    def __init__(self, creator, pool_size=5, max_overflow=10, timeout=30,
                 **kw):
        sqlalchemy.pool.Pool.__init__(self, creator, **kw)
        self._pool = sqla_queue.Queue(pool_size)
        self._overflow = 0 - pool_size
        self._max_overflow = max_overflow
        self._timeout = timeout
        self._overflow_lock = threading.Lock()

    def _do_return_conn(self, conn):
        try:
            self._pool.put(conn, False)
        except sqla_queue.Full:
            try:
                conn.close()
            finally:
                self._dec_overflow()

    def _do_get(self):
        use_overflow = self._max_overflow > -1

        try:
            wait = use_overflow and self._overflow >= self._max_overflow
            return self._pool.get(wait, self._timeout)
        # This doesn't exist in 0.7's Queue implementation
        #except sqla_queue.SAAbort as aborted:
        #    return aborted.context._do_get()
        except sqla_queue.Empty:
            if use_overflow and self._overflow >= self._max_overflow:
                if not wait:
                    return self._do_get()
                else:
                    raise exc.TimeoutError(
                            "QueuePool limit of size %d overflow %d reached, "
                            "connection timed out, timeout %d" %
                            (self.size(), self.overflow(), self._timeout))

            if self._inc_overflow():
                try:
                    return self._create_connection()
                except:
                    self._dec_overflow()
                    raise
            else:
                return self._do_get()

    def _inc_overflow(self):
        if self._max_overflow == -1:
            self._overflow += 1
            return True
        with self._overflow_lock:
            if self._overflow < self._max_overflow:
                self._overflow += 1
                return True
            else:
                return False

    def _dec_overflow(self):
        if self._max_overflow == -1:
            self._overflow -= 1
            return True
        with self._overflow_lock:
            self._overflow -= 1
            return True

    def recreate(self):
        self.logger.info("Pool recreating")
        return self.__class__(self._creator, pool_size=self._pool.maxsize,
                          max_overflow=self._max_overflow,
                          timeout=self._timeout,
                          recycle=self._recycle, echo=self.echo,
                          logging_name=self._orig_logging_name,
                          use_threadlocal=self._use_threadlocal,
                          reset_on_return=self._reset_on_return,
                          _dispatch=self.dispatch)

    def dispose(self):
        while True:
            try:
                conn = self._pool.get(False)
                conn.close()
            except sqla_queue.Empty:
                break

        self._overflow = 0 - self.size()
        self.logger.info("Pool disposed. %s", self.status())

    def status(self):
        return "Pool size: %d  Connections in pool: %d "\
                "Current Overflow: %d Current Checked out "\
                "connections: %d" % (self.size(),
                                    self.checkedin(),
                                    self.overflow(),
                                    self.checkedout())

    def size(self):
        return self._pool.maxsize

    def checkedin(self):
        return self._pool.qsize()

    def overflow(self):
        return self._overflow

    def checkedout(self):
        return self._pool.maxsize - self._pool.qsize() + self._overflow
