# -*- coding: utf-8 -*-
"""A mysqld sandbox for end-to-end testing

This module provides tools for creating sandboxed mysqld instance for
integration and acceptance testing.


Testing with a ConnectionSet
----------------------------

If you're testing a data layer that uses :mod:`yelp_conn.session` or you want
a :class:`yelp_conn.connection_set.ConnectionSet`, you probably want to use
:func:`connection_set_context`. See the function docs for an example.


Testing with a socket
---------------------

If you want just a mysqld socket, and want to setup your connections yourself
you can use :func:`start`. See the function docs for an example.

Other useful utils
------------------

* :func:`database` - create a new database in your sandboxed mysqld
* :func:`load_fixtures` - load some fixtures into a database

"""
import contextlib
import functools
import logging
import os
import os.path
import random
import shutil
import subprocess
from subprocess import PIPE
import tempfile
import time

import MySQLdb
import sqlalchemy

from yelp_conn import connection_set
from yelp_conn import session
from yelp_conn import topology


log = logging.getLogger(__name__)


class SandboxError(Exception):
    """Base exception for sandbox errors."""


@contextlib.contextmanager
def start(config=None, max_delay=10):
    """Start a :class:`MySQLDaemon` sandbox.

    .. code-block:: python

        from yelp_conn.testing import sandbox

        with sandbox.start() as mysqld:
            with sandbox.database(mysqld) as db_name:
                ...
    """
    path = tempfile.mkdtemp()
    try:
        install_db(path)

        config = build_config(config or {}, path)
        socket = config['--socket']
        with MySQLDaemon(list(build_args(config)), socket) as mysqld:
            wait_on_file(mysqld.socket, max_delay=max_delay)
            yield mysqld
    finally:
        shutil.rmtree(path)


def install_db(path):
    args = [
        'mysql_install_db',
        '--no-defaults',
        '--datadir=%s' % path,
        '--ldata=%s' % path,
    ]

    log.info("Installing mysql db.")
    proc = subprocess.Popen(args, stdout=PIPE, stderr=PIPE)
    stdout, stderr = proc.communicate()
    if proc.returncode != 0:
        raise SandboxError("%s failed (%d), stdout: %r, stderr: %r" % (
                           args[0], proc.returncode, stdout, stderr))


def wait_on_condition(condition, delay, max_delay):
    start_time = time.time()

    def timeout():
        return time.time() - start_time >= max_delay

    while not condition():
        if timeout():
            return False
        time.sleep(delay)
    return True


def wait_on_file(path, delay=0.1, max_delay=5):
    log.info("Waiting on %s", path)

    def path_exists():
        return os.path.exists(path)

    if not wait_on_condition(path_exists, delay, max_delay):
        raise SandboxError("Waited %ss for %s" % (max_delay, path))


class Flag(object):
    """Sentinel to identify a mysql command argument which takes no value."""
    pass


def build_config(config, path):
    """Construct mysql arguments from defaults and a configuration. For example
    to create a read-only sandbox, without table grants:

    .. code-block:: python

        config = {
                '--read-only': Flag,
                '--skip-grant-tables': Flag,
        }
        config = build_config(config, '/tmp/path')

    :param config: a mapping of argument to value
    :type  config: dict
    :param path: directory path of the mysql working directory
    :type  path: string
    :returns: a dict of arguments to value from default and config
    :rtype: dict
    """
    full_path = functools.partial(os.path.join, path)
    base = {
        '--pid-file':              full_path('mysqld.pid'),
        '--socket':                full_path('mysqld.sock'),
        '--log-error':             full_path('mysql.err.log'),
        '--log_bin':               full_path('mysql-bin.log'),
        '--datadir':               full_path('.'),
        '--server-id':             random.randint(1, 1<<30),
        '--log-warnings':          Flag,
        '--skip-external-locking': Flag,
        '--innodb_file_per_table': Flag,
        '--skip-grant-tables':     Flag,
        '--skip-networking':       Flag,
        '--tmpdir':                '/nail/tmp',
        # these are all innodb/mysql options that reduce the safety of MySQL
        # in the case of disk problems, but don't affect locking or general
        # correctness.
        '--innodb_flush_log_at_trx_commit': '0', # don't issue fsyncs
        '--innodb_buffer_pool_size': '128M',     # bumped up from default of 8M
        '--innodb_fast_shutdown': '2',           # do less work on shutdown
        '--skip-innodb_checksums': Flag,         # don't do extra checksums
        '--sync-binlog': '0',                    # don't fsync binlogs
        '--max-allowed-packet': '32M',
        '--innodb_file_format': 'Barracuda'
    }
    base.update(config)
    return base



def build_args(config):
    """Return a generator of mysql arguments from the configuration."""
    for param, value in config.iteritems():
        if value is None:
            continue
        if value is Flag:
            yield param
        else:
            yield '%s=%s' % (param, value)


class MySQLDaemon(object):
    """Run and control a MySQLDaemon process.

    .. code-block:: python

        with MySQLDaemon(config) as mysqld:
            print mysqld.socket

    :param args: command line arguments used to call mysqld
    :type  args: list of strings
    """

    def __init__(self, args, socket):
        self.args = args
        self.socket = socket
        self.proc = None

    def start(self):
        self.proc = subprocess.Popen(
            ['mysqld'] + self.args, stderr=PIPE, stdout=PIPE)

    def __enter__(self):
        self.start()
        return self

    def __exit__(self, *args):
        if self.proc.poll() is None:
            self.kill()
            self.proc.wait()
            return

        if self.proc.returncode:
            stdout, stderr = self.proc.communicate()
            log.warn('%s\n%s', stdout, stderr)

    def terminate(self):
        self.proc.terminate()

    def kill(self):
        self.proc.kill()

    def get_dbi_conn(self, user=''):
        return MySQLdb.connect(unix_socket=self.socket,
                charset='utf8',
                use_unicode=True,
                user=user)

    def get_conn(self, user=''):
        return sqlalchemy.create_engine(
                ("mysql+mysqldb://{user}:@localhost/?unix_socket={socket}"
                 "&use_unicode=1&charset=utf8").format(
                         user=user,
                         socket=self.socket)).connect()


@contextlib.contextmanager
def database(mysqld, db_name='testing', user=''):
    """A context manager around a database.

    :param mysqld: A :class:`MySQLDaemon` instance which has an active context
    :returns: a context manager which returns the database name
    """
    conn = mysqld.get_conn(user=user)
    with conn.begin():
        conn.execute("CREATE DATABASE `%s`" % db_name)
    try:
        yield db_name
    finally:
        with conn.begin():
            conn.execute("DROP DATABASE `%s`" % db_name)


def build_connection_set(socket,
                         db_name,
                         conn_name='testing',
                         cluster='test_cluster',
                         replica='test_replica',
                         auto_commit=False):
    """Return a :class:`yelp_conn.connection_set.ConnectionSet` for the socket
    and database.

    :param socket: the file path to a mysqld socket
    :type  socket: string
    :param db_name: name of the database for the connection set
    :param conn_name: name of the connection set
    """
    entry = {
        'db': db_name,
        'charset': 'utf8',
        'passwd': '',
        'user': '',
        'use_unicode': True,
        'unix_socket': socket,
    }

    key = topology.ClusterKey(cluster, replica)
    entry = topology.CEP129ConnectionEntry(0, key, entry)
    conn_defs = {
        cluster: (topology.ConnectionDef(cluster, replica, auto_commit),
                  topology.ConnectionCluster.create(key, [entry], None))
    }
    return connection_set.ConnectionSet(conn_name, conn_defs, bypass=True)


@contextlib.contextmanager
def connection_set_context(fixtures=None, db_name='testing', **kwargs):
    """A higher level interface over the sandbox. This context will create a
    mysqld process, a database, and a connection_set, and will clean them up
    when the context exits.

    .. code-block:: python

        with connection_set_context() as conn_set:
            # Do something
            with conn_set.test_cluster as cursor:
                ...

    :param kwargs: kwargs are passed along to :func:`build_connection_set`
    """
    with start() as mysqld:
        with database(mysqld, db_name=db_name):
            if fixtures:
                load_fixtures(mysqld.get_conn(), db_name, fixtures)
            yield build_connection_set(mysqld.socket, db_name, **kwargs)


@contextlib.contextmanager
def sessionmaker_context(use_use=False, db_name='testing', **kwargs):
    """A higher level interface over the sandbox. This context will create a
    mysqld process, a database, a connection_set, and a yelp_conn.sessionmaker
    and will clean them up when the context exits.

    .. code-block:: python

        with sessionmaker_context(DEFAULT_CLUSTER) as sessionmaker, conn_set:
            session = sessionmaker()
            session.query(...)
            session.close()

    .. warning::
        You must call session.close() or your test will hang.

    :param kwargs: kwargs are passed along to :func:`build_connection_set`
    """
    # TODO: Figure out how to pass args to the sessionmaker.
    with connection_set_context(**kwargs) as conn_set:
        def get_connection_set(connection_set_name):
            return conn_set
        if use_use:
            sandbox_sessionmaker =  session.sessionmaker_with_use(connection_sets=get_connection_set)
        else:
            sandbox_sessionmaker = session.sessionmaker(connection_sets=get_connection_set)
        yield sandbox_sessionmaker, conn_set


@contextlib.contextmanager
def scoped_session_context(**kwargs):
    """A higher level interface over the sandbox. This context will create a
    mysqld process, a database, a connection_set, and a yelp_conn.scoped_session
    and will clean them up when the context exits.

    .. code-block:: python

        with sessionmaker_context(DEFAULT_CLUSTER) as scoped_session, conn_set:
            scoped_session.query(...)
            
    :param kwargs: kwargs are passed along to :func:`build_connection_set`
    """
    with sessionmaker_context(**kwargs) as (sandbox_sessionmaker, conn_set):
        sandbox_scoped_session = session.scoped_session(sandbox_sessionmaker)
        yield sandbox_scoped_session, conn_set
        sandbox_scoped_session.remove()


def load_fixtures(conn, database_name, fixtures):
    """Load database fixtures from a list of filenames and execute them in
    the database.

    :param conn: a :class:`sqlalchemy.engine.Connection` used to connect
    :param database_name: name of the database
    :param fixtures: list of filenames which contain database statements to
                     execute
    """
    with conn.begin():
        conn.execute('use %s' % database_name)
        for fixture in fixtures:
            with open(fixture, 'r') as fh:
                conn.execute(fh.read())
