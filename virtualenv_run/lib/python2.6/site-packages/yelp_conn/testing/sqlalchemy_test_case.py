# -*- coding: utf-8 -*-
import contextlib

import sqlalchemy.orm
from staticconf.testing import MockConfiguration
import testify as T

import yelp_conn
import yelp_conn.topology
from yelp_conn import config
from yelp_conn import connection_set
from yelp_conn.testing.mysql_test_case import MySQLTestCase


class SQLAlchemyTestCase(MySQLTestCase):
    """A test case for things that use SQLAlchemy. This sets up a temporary MySQL
    daemon for each test, and cleans it up afterward.

    .. deprecated:: 3.0.2

    .. warning::

        This class is deprecated. Use :mod:`yelp_conn.testing.sandbox` directly.
    """

    __test__ = False
    __insecure__ = False
    session = None

    @contextlib.contextmanager
    def session_begin(self, read_only=False):
        """Get a session and cleanup after it's done being used.
        """
        if self.session is not None:
            raise Exception('Sessions cannot be nested.')

        if read_only:
            self.session = self.session_maker_ro()
        else:
            self.session = self.session_maker_rw()

        try:
            yield self.session
        except:
            self.session.rollback()
            raise
        else:
            self.session.commit()
        finally:
            self.session.close()
            self.session = None

    def service_config(self):
        """These settings would normally be in something like config.yaml.
        Override for custom settings in your tests.
        """
        return {}

    def topology_dict(self):
        """These settings would normally be in something like topology.yaml.
        Override for custom settings in your tests.
        """
        return {
            'connection_sets': {
                'testing_rw': {
                    'testing': 'master'
                },
                'testing_ro': {
                    'connection_configuration': {'read_only': True},
                    'testing': 'slave'
                },
            },
            'topology': [
                {
                    'cluster': 'testing',
                    'replica': 'master',
                    'entries': [
                        {
                            'user': 'root',
                            'passwd': '',
                            'db': 'testing',
                            'unix_socket': self.daemon.socket,
                        },
                    ]
                },
                {
                    'cluster': 'testing',
                    'replica': 'slave',
                    'entries': [
                        {
                            'user': 'rdonly',
                            'passwd': '',
                            'db': 'testing',
                            'unix_socket': self.daemon.socket,
                        },
                    ]
                },
            ]
        }

    @T.setup_teardown
    def _setup_session_makers_per_test(self):
        if not self.__reuse_mysqld_for_tests__:
            return self._setup_session_makers()
        return iter([None])

    @T.class_setup_teardown
    def _setup_session_makers_per_class(self):
        if self.__reuse_mysqld_for_tests__:
            return self._setup_session_makers()
        return iter([None])

    def _setup_session_makers(self):
        conf = {'topology': yelp_conn.topology.TopologyFile(self.topology_dict())}
        with MockConfiguration(conf, namespace=config.namespace):
            self._setup_engines()
            self.session_maker_ro = sqlalchemy.orm.sessionmaker(bind=self.engine_ro)
            self.session_maker_rw = sqlalchemy.orm.sessionmaker(bind=self.engine_rw)
            self.session = None
            yield

    def _setup_engines(self):
        yelp_conn.reset_module()
        yelp_conn.initialize()

        conn_set = connection_set.ConnectionSet.testing_rw()
        self.engine_rw = conn_set.get_engine('testing')

        self._setup_rdonly_user()
        conn_set = yelp_conn.connection_set.ConnectionSet.testing_ro()
        self.engine_ro = conn_set.get_engine('testing')

    def _setup_rdonly_user(self):
        with contextlib.closing(self.engine_rw.connect()) as conn:
            conn.execute("CREATE USER 'rdonly'")
            conn.execute("GRANT SELECT ON *.* TO 'rdonly'")
