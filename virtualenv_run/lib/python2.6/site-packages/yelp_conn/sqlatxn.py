# -*- coding: utf-8 -*-
"""
Transaction decorators and a transaction manager class for creating
transactions from SQLAlchemy connections. These are to be used with SQLAlchemy
core tables.
"""
import contextlib
from yelp_conn import connection_set


@contextlib.contextmanager
def txn(connection, ro=False):
    """A context manager which begins and rollback/commits a transaction.
    On exception the transaction is rolled-back and the exception is re-raised.

    connection  - An SQLAlchemy connection object
    ro          - If True treats this transaction as a read-only transaction. On
                  success rollback() is called. If False (the default) treats
                  this transaction as a read-write transaction. On success
                  commit() is called.
    """
    trans = connection.begin()
    try:
        yield connection
        if ro:
            trans.rollback()
            return
        trans.commit()
    except:
        trans.rollback()
        raise
    finally:
        connection.close()


def txn_pair(rw_conn, ro_conn):
    """A context manager around a pair of transactions.

    rw_conn - an SQLAlchemy connection object to a read-write master
    ro_conn - an SQLAlchemy connection object to a read-only slave
    """
    return contextlib.nested(txn(rw_conn), txn(ro_conn, True))


class TransactionManager(object):
    """Manage read/write transactions. This class should be used with SQLAlchemy
    core tables.

    Example:

    txn_manager = TransactionManager('my_service_db')
    with txn_manager.begin():
        self.txn_manager.rw_conn.execute(...)
        self.txn_manager.ro_conn.execute(...)

    or

    with txn_manager.begin() as (ro_conn, rw_conn):
        ro_conn.execute(...)
        rw_conn.execute(...)
    """

    def __init__(self,
                 cluster_name,
                 rw_replica_name='primary_rw',
                 ro_replica_name='primary_ro',
                 connection_set_getter=connection_set.get_connection_set):
        """Create a new TransactionManager.

        :param cluster_name: name of the cluster  as configured in topology
                             and connection_sets.
        :param ro_replica_name: name of the read-only replica
        :param rw_replica_name: name of the read-write replica
        :param connection_set_getter: a callable used to return connection sets
                                      by name
        """
        self.ro_conn_set = connection_set_getter(ro_replica_name)
        self.rw_conn_set = connection_set_getter(rw_replica_name)
        self.ro_engine = self.ro_conn_set.get_engine(cluster_name)
        self.rw_engine = self.rw_conn_set.get_engine(cluster_name)
        self.cluster_name = cluster_name
        self.active_ro_conn = None
        self.active_rw_conn = None

    def _engine_connect(self, engine):
        """Add cluster name so that the connections returned from this
        context manager have a similar API to the raw connections returned
        by other parts of yelp_conn.
        """
        connection = engine.connect()
        connection.cluster = self.cluster_name
        return connection

    @contextlib.contextmanager
    def begin(self, rw=False, ro=False):
        """Return a context manager around a transaction."""
        assert ro or rw, "One connection type required."

        if ro and rw:
            conns = (self._engine_connect(self.rw_engine),
                     self._engine_connect(self.ro_engine))
            with txn_pair(*conns) as active_conns:
                self.active_rw_conn, self.active_ro_conn = active_conns
                yield active_conns
                self.active_ro_conn = self.active_rw_conn = None
            return

        if ro:
            with txn(self._engine_connect(self.ro_engine), ro=True) as ro_conn:
                self.active_ro_conn = ro_conn
                yield ro_conn
                self.active_ro_conn = None

        if rw:
            with txn(self._engine_connect(self.rw_engine)) as rw_conn:
                self.active_rw_conn = rw_conn
                yield rw_conn
                self.active_rw_conn = None

    @property
    def ro_conn(self):
        assert self.active_ro_conn, "No active RO transaction."
        return self.active_ro_conn

    @property
    def rw_conn(self):
        assert self.active_rw_conn, "No active RW transaction."
        return self.active_rw_conn

    def mark_dirty(self):
        """Mark this transaction as `dirty`. Dirty indicates that we've written
        data to the master, which we need to read immediately. This will cause
        the active_rw_conn to be returned as the active_ro_conn.

        Raises an assertion error if called when there is no active_rw_conn.
        """
        assert self.active_rw_conn, "No active RW transaction."
        self.active_ro_conn = self.active_rw_conn
