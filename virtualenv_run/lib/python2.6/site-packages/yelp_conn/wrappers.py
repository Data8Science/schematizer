# -*- coding: utf-8 -*-
"""
This module provides database connection and cursor wrapper classes.

* :class:`AnnotatingConnectionWrapper`
* :class:`AutocommitGuardConnectionWrapper`
* :class:`AutocommitGuardConnectionWrapper`

"""
import logging
import os
import socket
import sys
import threading

from yelp_conn import config


log = logging.getLogger(__name__)


class DelegatingConnectionWrapper(object):
    """A base class for creating connection wrappers. Connection wrappers wrap
    calls to `connection.cursor`.

    Subclasses should define a `CURSOR_CLASS` attribute which is the class to
    instantiate and wrap around cursors when one is created.
    :class:`DelegatingCursorWrapper` can be used to create cursor wrappers.
    """
    CURSOR_CLASS = None

    def __init__(self, conn, **kwargs):
        self._delegate = conn

    def cursor(self, *args, **kwargs):
        return self.CURSOR_CLASS(self, self._delegate.cursor(*args, **kwargs))

    def __getattr__(self, name):
        return getattr(self._delegate, name)

    def __enter__(self):
        return self.CURSOR_CLASS(self, self._delegate.__enter__())

    def __exit__(self, *args):
        return self._delegate.__exit__(*args)


class DelegatingCursorWrapper(object):
    """A base class for creating a cursor wrapper.  Cursor wrappers are able to
    wrap `execute()`, and `executemany()` calls on database cursors.

    By default this class will forward all calls along to the `cursor`.

    :param conn: the connection which created this cursor
    :param cursor: the cursor which is wrapped
    """

    def __init__(self, conn, cursor):
        self._delegate = cursor
        # for backwards compatibility
        self._conn = self.connection = conn

    def __getattr__(self, name):
        return getattr(self._delegate, name)



def fill_query(cursor, query, bind_values):
    if not bind_values:
        return query
    try:
        return query % cursor.connection.literal(bind_values)
    except TypeError:
        return query


class AutocommitGuardException(Exception):
    pass


class AutocommitGuardCursorWrapper(DelegatingCursorWrapper):

    def execute(self, query, args=None):
        self.connection.assert_threadsafe()
        normalized_query = query.lstrip().lower()

        # detect transaction start
        if normalized_query.startswith('start transaction') or normalized_query.startswith('begin'):
            self.connection.within_transaction = True
        # detect transaction end
        elif normalized_query.startswith('commit') or normalized_query.startswith('rollback'):
            self.connection.within_transaction = False
        # now complain loudly if we're writing outside of a transaction
        elif any(normalized_query.startswith(write_cmd) for write_cmd in ('insert', 'update', 'delete')):
            if not self.connection.within_transaction:
                raise AutocommitGuardException('No enclosing transaction detected, refusing to execute %s' % (query,))

        return self._delegate.execute(query, args)

    def executemany(self, *args, **kwargs):
        raise NotImplementedError


class AutocommitGuardConnectionWrapper(DelegatingConnectionWrapper):
    """
    Protects against accidentally writing on an autocommitting connection
    without being inside an explicitly created transaction.

    This also provides the functionality of util.rollback_manager,
    in that it swallows "unnecessary" rollbacks when there is no state
    to be rolled back.
    """

    CURSOR_CLASS = AutocommitGuardCursorWrapper
    within_transaction = False

    def __init__(self, conn):
        super(AutocommitGuardConnectionWrapper, self).__init__(conn)
        self._threadname = threading.currentThread().getName()

    def assert_threadsafe(self):
        current_threadname = threading.currentThread().getName()
        assert current_threadname == self._threadname, \
            'Connection created by thread %s but used by %s' % (self._threadname, current_threadname)

    def commit(self):
        self.assert_threadsafe()
        self.within_transaction = False
        self._delegate.commit()

    def rollback(self):
        self.assert_threadsafe()
        # skip rollback if we're not in a transaction
        if self.within_transaction:
            log.debug('Rollback necessary, forwarding to underlying connection.')
            self.within_transaction = False
            self._delegate.rollback()
        else:
            log.debug('Suppressed unnecessary rollback.')


class ToDBCursorWrapper(DelegatingCursorWrapper):
    """Cursor wrapper for doing queries with objects with a 'to_db' method (e.g., ObjectID)"""

    @staticmethod
    def convert_query_params_to_db(query_params):
        """This takes a dictionary or tuple of query_params passed to execute
        and converts the values to db format by calling to_db
        """

        def to_db(value):
            """Function to convert a single param to DB format by calling to_db()"""

            # We expect most params will not have a to_db function, so first we check for the attribute.
            to_db_func = getattr(value, 'to_db', None)
            if to_db_func is None:
                # TODO: Would be nice to check that this value is a primitive type
                return value

            ret = to_db_func()
            return ret

        # query_params can be either a dictionary or a tuple. We expect a
        # dictionary most of the time, so first try to treat the query_params
        # as a dict. If that fails then we will treat it as a tuple.
        try:
            items = query_params.iteritems()
        except AttributeError:
            items = enumerate(query_params)
            query_params = list(query_params)

        for key, value in items:
            # Update the values in-place
            query_params[key] = to_db(value)

        return query_params

    def execute(self, query, query_params=None):
        """Execute query after converting query_params to db format"""

        # Fast path for no query_params -- save the function call overhead
        if query_params:
            query_params = self.convert_query_params_to_db(query_params)

        return self._delegate.execute(query, query_params)

    def executemany(self, query, query_params=None):
        if query_params:
            query_params = [self.convert_query_params_to_db(param)
                            for param in query_params]
        return self._delegate.executemany(query, query_params)


class IsInstanceEncoderConnectionWrapper(DelegatingConnectionWrapper):
    """
    By default, MySQLdb uses the escaper for type str when no exact type-match
    is found. This wrapper adds functionality that enables subclasses of basic
    types to use the correct encoder, rather than the str-encoder.

    This is designed to be fully backward compatible with the standard mysqldb
    connection, except some cases that were previously errors will now work
    correctly.
    """

    CURSOR_CLASS = DelegatingCursorWrapper

    def __init__(self, *args, **kwargs):
        super(IsInstanceEncoderConnectionWrapper, self).__init__(*args, **kwargs)
        orig_str_encoder = self.encoders[str]
        self.encoders[str] = self.make_fallback_encoder(orig_str_encoder)


    def make_fallback_encoder(self, orig_str_encoder):
        def fallback_encoder(obj, encoders):
            """
            escape(obj, dict) -- escape any special characters in object obj
            using mapping dict to provide quoting functions for each type.
            Returns a SQL literal string.

            See also: MySQL-python-1.2.3/_mysql.c:1063
            http://mysql-python.svn.sourceforge.net/viewvc/mysql-python/tags/MySQLdb-1.2.3/MySQLdb/_mysql.c?view=markup#l1063
            """
            itemtype = obj.__class__
            if itemtype is str:
                # This is the usual case
                return orig_str_encoder(obj, encoders)

            # We don't want to recurse.
            encoders = encoders.copy()
            encoders[str] = orig_str_encoder
            itemconv, encoder_type = self.find_encoder(itemtype, encoders, orig_str_encoder)

            return itemconv(obj, encoders)
        return fallback_encoder

    @staticmethod
    def find_encoder(itemtype, encoders, default):
        # We need to choose the most specific encoder we can.
        # i.e. It doesn't make sense to encode an int as an object.
        # Of two candidate superclasses, the one with the longer
        # method-resolution-order is always the correct one to pick.
        for encodertype, encoder in sorted(
                encoders.items(),
                key=lambda item: len(item[0].__mro__),
                reverse=True
        ):
            if issubclass(itemtype, encodertype):
                return encoder, encodertype
        else:
            return default, None


class ToDBConnectionWrapper(DelegatingConnectionWrapper):
    CURSOR_CLASS = ToDBCursorWrapper


class EquivalenceConnectionWrapper(DelegatingConnectionWrapper):
    """Wrapper to help connections look equal to each other

    This wrappers expects a `me` attribute on the underlying connection
    which is the raw connection. This attribute is used to compare
    connections.
    """
    CURSOR_CLASS = DelegatingCursorWrapper

    def __init__(self, conn):
        assert hasattr(conn, "me"), "Requires a connection with a special me attribute"
        super(EquivalenceConnectionWrapper, self).__init__(conn)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __eq__(self, other):
        if other is None:
            return False
        try:
            return self._delegate.me == other.me
        except AttributeError:
            return False


def cleanup_query(query):
    """Remove trailing semi-colon and whitespace from a query.  MySQL doesn't
    allow comments after a semicolon.
    """
    return query.rstrip(' \r\n\t\v;')


def get_frames():
    """Modified version of traceback.extract_stack() that returns a generator
    instead of a list.
    """
    f = sys._getframe(1)
    while f is not None:
        co = f.f_code
        yield co.co_filename, f.f_lineno, co.co_name
        f = f.f_back


class AnnotatingCursorWrapper(DelegatingCursorWrapper):
    """Wrapper to track where in code queries originate"""

    ignored_path_prefixes = config.conn_conf.get_list(
        'AnnotatingCursorWrapper.ignored_path_prefixes',
        default=(),
        help="List of path prefixes which will be ignored for query annotation.")

    base_path = config.conn_conf.get_string(
        'AnnotatingCursorWrapper.base_path',
        default="",
        help="Base path of the code repo. Used to shorten file names in query "
        "annotation")

    module_path = os.path.dirname(__file__)

    def is_ignored_filepath(self, filename):
        return any(filename.startswith(path) for path in self.ignored_path_prefixes)

    def file_from_active_repo(self, filename):
        if filename.startswith(self.module_path):
            return False
        if self.base_path and filename.startswith(self.base_path.value):
            return True
        return not filename.startswith('/')

    def normalize_filepath(self, filename):
        """Strip the base_path or a local path from the filename."""
        base_path = os.path.normpath(str(self.base_path.value)) + '/'
        if base_path and filename.startswith(base_path):
            return filename.replace(base_path, '', 1)
        if filename.startswith('./'):
            return filename.replace('./', '', 1)
        return filename

    def get_filename_annotation(self):
        for frame in get_frames():
            filename, line_num, code_name = frame

            if not self.file_from_active_repo(filename):
                continue

            filename = self.normalize_filepath(filename)
            if not self.is_ignored_filepath(filename):
                return '%s:%d' % (filename, line_num)

        return '<unknown>'

    def _annotate(self, query):
        filename = self.get_filename_annotation()
        hostname = socket.gethostname().split('.')[0]
        query = cleanup_query(query)
        return query + " /* %s.%d ; %s */" % (hostname, os.getpid(), filename)

    def execute(self, query, args=None):
        return self._delegate.execute(self._annotate(query), args)

    def executemany(self, query, args=None):
        return self._delegate.executemany(self._annotate(query), args)


class AnnotatingConnectionWrapper(DelegatingConnectionWrapper):
    """This connection wrappe adds a comment to every query which includes:

    * the python source file and line number
    * the hostname of the box running the python application
    * the pid of the python application

    Example annotation:

    .. code-block:: sql

        SELECT * FROM table
        /* dev9-devc.546 ; logic/message_board/message_board_mixin.py:1083 */

    It has two configuration parameters which are set using :mod:`staticconf`

    ``AnnotatingCursorWrapper.ignored_path_prefixes``
        is a list of files to ignore while searching through the stack for the
        file to include in annotations.
    ``AnnotatingCursorWrapper.base_path``
        the base path of your codebase used to determine the fileanme

    """
    CURSOR_CLASS = AnnotatingCursorWrapper
