# -*- coding: utf-8 -*-
"""
This module provides a :class:`ConnectionSet` object for working with groups of
connections. :class:`ConnectionSet` s can be registered globally on initialize
and retrieved as attributes on the :class:`ConnectionSet` class.



"""
from functools import partial
import logging
import weakref

import yelp_conn
from yelp_conn import engine
from yelp_conn.conn_creator import ConnectionCreator
from yelp_conn.topology import ConnectionDef
from yelp_conn.wrappers import DelegatingCursorWrapper
from yelp_conn.wrappers import EquivalenceConnectionWrapper


log = logging.getLogger(__name__)


_global_connection_set_configs = {}


_connection_set_aliases = {}


class ConnectionSetError(ValueError):
    """Exception raised when the requested ConnectionSet can not be created."""
    pass


class ConnectionSetRegistry(object):
    """Register all ConnectionSets so that their engine managers can be
    recreated when topologies change.
    """

    def __init__(self):
        self.registry = weakref.WeakKeyDictionary()

    def add(self, conn_set):
        self.registry[conn_set] = True

    def __iter__(self):
        """Return all."""
        return self.registry.iterkeys()


# What this code does:
#
# We want to retain the legacy behavior of being able to run
# yelp_conn.connection_set.ConnectionSet.web_ro (or whatever). However,
# we're now dynamically determining the names of registered connection_sets.
# This happens because yelp_conn.initialize calls the
# `register_connection_set` method with the output from TopologyFile


def register_connection_set_config(connection_set_config):
    with yelp_conn.globals_lock:
        if connection_set_config.name in _global_connection_set_configs:
            msg = "ConnectionDef %s already registered"
            raise KeyError(msg % connection_set_config.name)
        _global_connection_set_configs[connection_set_config.name] = connection_set_config


def register_from_topology(topology):
    """Register connection sets from a TopologyFile object."""
    for connection_set_config in topology.get_connection_set_configs():
        register_connection_set_config(connection_set_config)


def alias_connection_set(aliased_connection_set_name, real_connection_set_name):
    """Alias <aliased_connection_set_name> to actually return
    <real_connection_set_name>. Aliases can be removed by calling
    remove_aliased_connection_set.

    This exists solely for testing.
    """
    _connection_set_aliases[aliased_connection_set_name] = real_connection_set_name


def unalias_connection_set(target_connection_set_name):
    """Remove any aliases defined on <target_connection_set_name>. No-op if none are defined."""
    if target_connection_set_name in _connection_set_aliases:
        del _connection_set_aliases[target_connection_set_name]


def connection_set_factory_factory(cls, connection_set_name):
    def connection_set_factory(bypass=False):
        with yelp_conn.globals_lock:
            conn_set_config = _global_connection_set_configs[connection_set_name]
            conn_set = cls.from_config(conn_set_config, bypass=bypass)
            cls.connection_set_registry.add(conn_set)
            return conn_set
    connection_set_factory.__name__ = connection_set_name
    return connection_set_factory


class ConfigurableConnectionSetMeta(type):

    def __getattr__(cls, name):
        connection_set_factory = get_connection_set_factory(name)
        if connection_set_factory:
            return connection_set_factory
        return getattr(super(ConfigurableConnectionSetMeta, cls), name)


def get_connection_set_factory(name):
    """Create and return a connection set by name (or alias) from the configured
    connection sets.
    """
    with yelp_conn.globals_lock:
        if name in _connection_set_aliases:
            name = _connection_set_aliases[name]
        if name in _global_connection_set_configs:
            return connection_set_factory_factory(ConnectionSet, name)


def get_connection_set(name):
    """Return a ConnectionSet object from the registered connection sets.
    Raises ConnectionSetError if the name has not been registered..
    """
    factory = get_connection_set_factory(name)
    if not factory:
        msg = "ConnectionSet %s has not been configured."
        raise ConnectionSetError(msg % name)
    return factory()


def reset():
    """Forget all registered connection sets configuration. This does not
    close any connections, or clear out registered ConnectionSet objects.
    """
    global _global_connection_set_configs, _connection_set_aliases

    with yelp_conn.globals_lock:
        _global_connection_set_configs = {}
        _connection_set_aliases = {}


def registered_connection_set_names():
    """Getter for the names of registered connection sets

    We don't just expose _known_connection_sets because then we might
    have to deal with somebody keeping a reference to the connection set factory
    itself from outside of this module.
    """
    with yelp_conn.globals_lock:
        return set(_global_connection_set_configs)


class ConnectionSet(object):
    """A container for database connections. It operates as a set of connection
    pools, which are created lazily when necessary.

    .. code-block:: python

        # doesn't do anything, no connections are created yet
        conns = ConnectionSet.web_rw()
        # creates a connection to the master
        conns.primary.cursor().execute('SELECT UNIX_TIMESTAMP()')

        # creates a connection to the replica database
        foo = conns.primary_slave

    It's worth noting that because the lazy loading happens through __getattr__,
    you will create a connection just by looking up an attribute. In the example
    above, aliasing `foo` to conns.primary_slave created a database connection
    because of this.

    :param name: the name of this connection set
    :type  name: string
    :param connection_defs: dict of :class:`yelp_conn.topology.ConnectionDef`
                            to :class:`yelp_conn.topology.ConnectionCluster`
                            used to create connections
    :param bypass: flag to disable re-use of engines
    :type  bypass: bool
    :param read_only: flag to set this as a read-only connection set
    :type  bypass: bool
    """

    __metaclass__ = ConfigurableConnectionSetMeta

    connection_set_registry = ConnectionSetRegistry()

    @classmethod
    def from_config(cls, conn_set_config, bypass=False):
        """Create a :class:`ConnectionSet` from a
        :class:`yelp_conn.topology.ConnectionSetConfig.
        """
        return cls(
            conn_set_config.name,
            conn_set_config.clusters,
            bypass=bypass,
            read_only=conn_set_config.read_only)

    @classmethod
    def rebuild_engine_managers(cls):
        with yelp_conn.globals_lock:
            for conn_set in cls.connection_set_registry:
                new_conn_def = _global_connection_set_configs[conn_set.get_name()]
                conn_set.build_engine_managers(new_conn_def.clusters)

    def __init__(self, name, connection_defs, bypass=False, read_only=False):
        self.name = name
        self.read_only = read_only
        self.bypass = bypass

        self._session_maker = None
        self._connection_defs = connection_defs
        self.build_engine_managers(connection_defs)

    def build_engine_managers(self, connection_defs):
        if self.bypass:
            engine_mngr_builder = engine.EngineManager
        else:
            engine_mngr_builder = engine.get_or_create_engine_manager

        self._engine_managers = dict(
            (name, engine_mngr_builder(conn_def, ConnectionCreator(conn_def, topology)))
            for name, (conn_def, topology) in connection_defs.iteritems())

    def get(self, name):
        engine_mngr = self.get_engine_manager(name)

        # We call connect, the pool handles pretending it's giving us a new connection, but really
        # it's a pool, so it might not be new.
        if engine_mngr._connection_def.database == ConnectionDef.POSTGRES:
                return engine_mngr.connection

        return SetBoundConnectionWrapper(engine_mngr.connection, self)

    def get_name(self):
        return self.name

    def get_engine_manager(self, name):
        if name not in self._engine_managers:
            raise ConnectionSetError("Unknown cluster: %s" % name)
        return self._engine_managers[name]

    def get_engine(self, name):
        return self.get_engine_manager(name).engine

    def set_session_maker(self, session_maker):
        self._session_maker = weakref.ref(session_maker)

    def get_session_maker(self):
        if self._session_maker:
            return self._session_maker()
        return None

    def __getattr__(self, name):
        """Lazily loads connections and sessions"""
        if name in self:
            return self.get(name)
        else:
            raise AttributeError(name)

    def __contains__(self, name):
        return name in self._engine_managers

    def __cmp__(self, other):
        # We'll just compare on name
        if other is None:
            return -1

        return cmp(self.name, other.name)

    @property
    def engine_names(self):
        return self._engine_managers.keys()

    def dispose(self):
        """Drop all our connections
        """
        for engine_mngr in self._engine_managers.itervalues():
            engine_mngr.dispose()

    def close(self):
        return self.dispose()

    def rollback(self):
        for mngr in self._engine_managers.itervalues():
            mngr.rollback()

    def refresh(self):
        for mngr in self._engine_managers.itervalues():
            mngr.refresh()

    def __repr__(self):
        return "<ConnectionSet: {0}>".format(self.name)

    @classmethod
    def bypass(cls, set_name):
        """Generate the connection set <set_name> without caching it

        This is useful for threading, when you can't share connections with
        other parts of the application.
        """
        return partial(connection_set_factory_factory(cls, set_name), bypass=True)

    def with_unique_connections(self):
        """Return a new connection set identical to this one, but with its own
        unique connection pools guaranteed not to be used by any other
        connection set.

        This will obviously eat up more connections.  Use with care.  If you're
        only using the SQLA ORM, this is unnecessary; the ORM session will
        effectively do this itself.

        This is the same functionality you get with ``bypass=True``.
        """
        return type(self)(
            self.name,
            self._connection_defs,
            bypass=True,
            read_only=self.read_only,
        )

    def __dir__(self):
        return self.__dict__.keys() + self._engine_managers.keys()


class SetBoundCursorWrapper(DelegatingCursorWrapper):
    """Cursor wrapper for SetBoundConnectionWrapper"""
    @property
    def connection_set(self):
        return self.connection.connection_set


class SetBoundConnectionWrapper(EquivalenceConnectionWrapper):
    """Wrapper around a connection to make it reference its parent connection set.
    """
    CURSOR_CLASS = SetBoundCursorWrapper
    def __init__(self, conn, connection_set):
        super(SetBoundConnectionWrapper, self).__init__(conn)

        self.__connection_set = weakref.ref(connection_set)

    @property
    def connection_set(self):
        return self.__connection_set()
