"""
A generic decorator to retry on exceptions.
Copied from yelp-main/yelp/util/retry_decorators.py
"""

import time
import traceback
import logging
import functools

# Default information for exception retry function
DEFAULT_RETRY_NUMBER_OF_RETRIES = 3
DEFAULT_RETRY_DELAY_SEC = 1

log = logging.getLogger(__name__)

def maketuple(x):
    """If x is already a list, tuple, or sequence (not including
    strings and dictionary-like objects), return tuple(x). Otherwise,
    return (x,).

    This is useful for method arguments that normally take a single
    item of a non-list type, but occasionally take multiple items.
    """
    if isinstance(x, basestring) or hasattr(x, 'keys'):
        return (x,)
    else:
        try:
            return tuple(x)
        except TypeError:
            return (x,)

def retuple(a_val):
    """Like makelist except None => ()"""
    if a_val is None:
        return ()
    else:
        return maketuple(a_val)

def retry_on_exception(backoff_exceptions,
                       max_number_of_retries=DEFAULT_RETRY_NUMBER_OF_RETRIES,
                       delay=DEFAULT_RETRY_DELAY_SEC,
                       log_function=None,
                       before_retry_function=None):
    """
    Decorator to retry multiple times

    Args:
        backoff_exceptions - a list or a single exception that we catch and retry on
        max_number_of_retries - maximum number of retry attempts
        delay - retry delay
        log_function - where to log
        before_retry_function - a custom function to call before each retry attempt
    """
    if isinstance(backoff_exceptions, list) or isinstance(backoff_exceptions, tuple):
        backoff_exceptions = tuple(backoff_exceptions)
    else:
        backoff_exceptions = (backoff_exceptions,)

    log_function = log_function or log.info

    def decorator(func):
        """
        The decorator that gets return by retry
        """
        @functools.wraps(func)
        def function(*args, **kwargs):
            """
            The function returned by decorator
            """
            retries = 0

            while True:

                # Try to get return value
                try:
                    return func(*args, **kwargs)

                # If we catch one of the backoff exceptions, retry if we have enough retries left
                except backoff_exceptions as e:
                    if retries >= max_number_of_retries:
                        log_function('Max number of retries reached (%s). Raising last exception.' % retries)
                        raise

                    retries += 1

                    # Use log function to log the exception and the traceback
                    log_function('Going to do retry #%s after receiving exception: %s, %s' % (retries, e, traceback.extract_stack()))

                    if before_retry_function is not None:
                        before_retry_function()

                    # Sleep
                    time.sleep(delay)

        return function

    return decorator

