# -*- coding: utf-8 -*-
"""
This module contains a parser for a topology configuration file.  It can be run
as a module to validate the contents as a file.

Example:

.. code-block:: bash

    python -m yelp_conn.topology topology.yaml


A topology file has two sections, a connection_set mapping and a topology
mapping. The connection_set mapping is used to establish names for a
cluster and replica pair. The topology mapping is used to group database
connection details into a logical structure, see
`CEP 129 <https://docs.google.com/a/yelp.com/document/d/1nsEurfaV-E5b2uYUrZ0pSlqBNYkeNd8c_uLPs2XICh8/view>`_
for the original spec.

Example topology.yaml

.. code-block:: yaml

    connection_sets:
        feeds_rw:
            feeds_primary: master
            feeds_stats: master
        feeds_ro:
            feeds_primary: slave

    topology:
        - cluster: feeds_primary
          replica: master
          entries:
            - host: 1.1.1.1
              user: "username"
              passwd: "password"
              db: "feeds"
        - cluster: feeds_primary
          replica: slave
          entries:
            - host: 1.1.1.2
              user: "username"
              passwd: "password"
              db: "feeds"
            - host: 1.1.1.3
              user: "username"
              passwd: "password"
              db: "feeds"
              weight: 2.0


Normally topology is loaded during the func:`yelp_conn.initialize`. You can
also use :class:`yelp_conn.topology.TopologyFile` to load a file directly.
"""

import operator

from collections import namedtuple

import yaml


class TopologyConfigurationException(ValueError):
    """Exception raised when the topology configuration is invalid."""
    pass


class ConnectionDef(namedtuple(
        '_ConnectionDef',
        ['conn_type', 'repl_type', 'auto_commit', 'database'])):
    """Defines a connection class that we can create a SQLAlchemy pool/engine
    for.

    By default a MySQL connection is assumed.

    This is a namedtuple, so equality and hash are defined such that two
    ConnectionDefs are == iff connections created from them can mix in the same
    pool.
    """

    MYSQL = 'mysql'
    POSTGRES = 'postgres'

    def __new__(cls, conn_type, repl_type, auto_commit=False, database=None):
        return super(ConnectionDef, cls).__new__(
            cls, conn_type, repl_type, auto_commit, database or cls.MYSQL)

    def __str__(self):
        descriptions = [self.conn_type, self.repl_type]
        if self.auto_commit:
            descriptions.append('auto')
        return '_'.join(descriptions)

    @property
    def slave(self):
        return self.repl_type != 'master'


class ConnectionEntry(object):
    required_parameter_keys = [
        'charset',
        'db',
        'passwd',
        'use_unicode',
        'user',
    ]
    optional_parameter_keys = [
        'host',
        'unix_socket',
        'port',
        'ssl',
    ]
    comparison_keys = [
        'db',
        'host',
        'port',
        'user',
        'unix_socket',
    ]
    def __init__(self, entry_number, connection_key, entry_dictionary):
        """Connection definition. These objects should be Immutable.

        Arguments:
            entry_number: The index of this entry in the topology section of the topology.yaml file; used only for error reporting
            topology: The complete cluster topology (for generating error context)
            entry_dictionary: The dictionary for this entry itself

        """
        # use 1-based indexing; it makes error reporting easier.
        self.entry_number = entry_number + 1
        self.connection_params = self._parse_dictionary(entry_dictionary, connection_key)
        msg = "Missing keys %%s for host %d in cluster '%s' replica level '%s'" % (
                self.entry_number, connection_key.cluster, connection_key.replica)
        verify_expected(
            set(self.required_parameter_keys),
            set(self.connection_params.keys()),
            msg,
            exc_class=KeyError)

    @property
    def params(self):
        """A dictionary of parameters suitable for returning to MySQL"""
        params = dict((k, self.connection_params[k]) for k in self.required_parameter_keys)
        params.update(dict((k, self.connection_params[k]) for k in self.optional_parameter_keys if k in self.connection_params))
        return params

    @property
    def weight(self):
        return self.connection_params.get('weight', 1.0)

    @property
    def physical_key(self):
        """A hashable key that represents this physical database instance"""
        return (self.connection_params.get('host', None),
                self.connection_params.get('port', None),
                self.connection_params.get('unix_socket', None))

    def _parse_dictionary(self, d, topology):
        """Actually parse the dictionary from the topology file. Might be extended
        by, e.g., CEP131 to look in other places"""
        raise NotImplementedError()

    def __str__(self):
        return "ConnectionEntry to host:%s, port:%d, db:%s" % (self.connection_params.get('host', ''), self.connection_params.get('port', 0), self.connection_params.get('db', ''))

    def __repr__(self):
        return "<ConnectionParam host:%s, port:%d, db:%s>" % (self.connection_params.get('host', ''), self.connection_params.get('port', 0), self.connection_params.get('db', ''))

    def __eq__(self, other):
        return all(self.connection_params.get(k, None) == other.connection_params.get(k, None) for k in self.comparison_keys)

    def __ne__(self, other):
        return not (self == other)

    def __hash__(self):
        return hash(tuple(self.connection_params.get(k, None) for k in self.comparison_keys))


class CEP129ConnectionEntry(ConnectionEntry):
    """CEP129-compliant connection definition"""

    default_connection_parameters = {
        'charset': 'utf8',
        'use_unicode': True,
        'weight': 1.0,
        'port': 3306,
    }

    mutex_connection_params = [
        ('unix_socket', 'host'),
    ]

    required_connection_parameters = [
        'db',
        'user',
        'passwd',
    ]

    def _parse_dictionary(self, d, connection_key):
        result_entry = {}
        for tkey, tvalue in self.default_connection_parameters.iteritems():
            if tkey in d:
                if type(d[tkey]) != type(tvalue):
                    raise TypeError("Expected type %s for key '%s' for host %d in cluster '%s' replica level '%s', got %s" % (type(tvalue), tkey, self.entry_number, connection_key.cluster, connection_key.replica, type(d[tkey])))
                result_entry[tkey] = d[tkey]
            else:
                result_entry[tkey] = tvalue
        for tkey in self.required_connection_parameters:
            if tkey not in d:
                raise KeyError("Expected key '%s' for host %d in cluster '%s' replica level '%s'" % (tkey, self.entry_number, connection_key.cluster, connection_key.replica))
            # For now, just pass through the dictionary we get. In the
            # future, we might want to do something else (like validate
            # the database name, or something)
            result_entry[tkey] = d[tkey]
        for tkey in self.optional_parameter_keys:
            if tkey in d:
                result_entry[tkey] = d[tkey]
        for lhs, rhs in self.mutex_connection_params:
            if lhs in d and rhs in d:
                raise KeyError("cannot provide both [%s] and [%s]" % (",".join(lhs), ",".join(rhs)))
            if not (lhs in d or rhs in d):
                raise KeyError("must provide either [%s] or [%s]" % (",".join(lhs), ",".join(rhs)))
            if lhs in d:
                result_entry[lhs] = d[lhs]
            elif rhs in d:
                result_entry[rhs] = d[rhs]
        if 'unix_socket' in result_entry:
            for k in ('host', 'port'):
                if k in result_entry:
                    del result_entry[k]
        return result_entry



ConnectionSetConfig = namedtuple('ConnectionSetConfig', 'name clusters read_only')


class TopologyFile(object):
    """Parser for a modern (CEP129-style) topology file, which includes
    both the database structure and the connection sets to expose to the
    application.

    Parse a dictionary:

    .. code-block:: python

        topology = TopologyFile(topology_dict)

    Parse a file:

    .. code-block:: python

        topology = TopologyFile.new_from_file(filename)

    """

    def __init__(self, dictionary=None):
        """Construct from a dictionary, which must meet the CEP129 standard.
        If no argument passed, creates an empty TopologyFile."""
        self.connection_sets = {}
        self.topologies = ClusterGroup()
        if dictionary is not None:
            self.append(dictionary)

    @classmethod
    def new_from_file(cls, fname):
        """Helper method to construct from a file instead of a dictionary"""
        with open(fname, "r") as f:
            return cls(yaml.load(f.read()))

    def get_connection_set_configs(self):
        """Iterable of ConnectionSetDef objects, which can be used to
        construct connection_set.ConnectionSet objects.
        """
        for connection_set_name, connections in self.connection_sets.iteritems():
            cdefs = {}
            config = connections.pop('connection_configuration', {})
            for cluster_name, replica_level in connections.iteritems():
                connection_cluster = self.topologies[ClusterKey(cluster_name, replica_level)]
                cdef = ConnectionDef(
                    cluster_name,
                    replica_level,
                    config.get('auto_commit', False),
                    database=connection_cluster.database
                )
                cdefs[cluster_name] = (cdef, connection_cluster)
            read_only = config.get('read_only', False)
            yield ConnectionSetConfig(connection_set_name, cdefs, read_only)

    def append_file(self, fname):
        """Helper method to append from a file instead of a dictionary"""
        with open(fname, "r") as f:
            return self.append(yaml.load(f.read()))

    def append(self, dictionary):
        """Append the contents of the dictionary (itself derived from a
        topology file) to the existing topology. Some caveats:

         * No connection set definition may be repeated
         * topology entries with the same (cluster, replica level) pair
           will have their entries concatenated, unless one of the other
           settings does not match
        """
        verify_configuration(dictionary)
        connection_sets = {}
        clusters = ClusterGroup()
        if 'connection_sets' in dictionary:
            connection_sets = self._parse_connection_sets(dictionary['connection_sets'])
        if 'topology' in dictionary:
            clusters = self.parse_topologies(dictionary['topology'])

        self.merge_topology(connection_sets, clusters)

    def merge_topology(self, new_connection_sets, new_topology):
        """Verify the new topology and connection sets can be merged with
        the current topology and connection sets, and then perform the merge.
        """
        msg = "The following connection sets were duplicated: [%s]"
        verify_uniqueness(self.connection_sets.keys(), new_connection_sets.keys(), msg)

        # only actually set the properties on self if everything succeeded
        topologies = merge_cluster_groups(self.topologies, new_topology)
        self._verify_connection_set_mappings(new_connection_sets, topologies)
        self.topologies = topologies
        self.connection_sets.update(new_connection_sets)

    def get_connection_params(self, cluster, replica):
        """Grabs the list of db parameters for a specific (cluster, replica) pair
        in a topology file.

        Args:
        cluster - something like "spam", "primary", etc...
        replica - something like "slave", "master", "reporting", etc...

        Returns:
        List of dictionaries of the parameters for the topology file entries.
        """
        cluster_group = self.topologies[cluster, replica]
        return map(operator.attrgetter("connection_params"),
                    cluster_group.entries)

    def get_first_connection_param(self, cluster, replica):
        """Returns the first element in the connection params for the given
        cluster replica pair. Throws exception if the given cluster, replica
        pair is not part of this toplogy file
        """

        connection_params = self.get_connection_params(cluster, replica)

        if len(connection_params) > 0:
                return connection_params[0]

        raise Exception('No connection params for %s:%s' % (cluster, replica))

    @staticmethod
    def _verify_connection_set_mappings(connection_sets, topologies):
        # verify that all connection-sets are well-populated
        expected_connection_set_keys = set()
        for connection_set_name, connection_set_def in connection_sets.iteritems():
            for k, v in connection_set_def.iteritems():
                if k == "connection_configuration":
                    continue
                expected_connection_set_keys.add((k, v))
        msg = "Missing cluster, replica level pair(s): %s"
        verify_expected(expected_connection_set_keys, set(topologies.keys()), msg)

    @staticmethod
    def _parse_connection_sets(connection_sets):
        if not connection_sets:
            raise TopologyConfigurationException("must define at least one connection set")
        if not isinstance(connection_sets, dict):
            raise TypeError("connection_sets should be a mapping; got %s" % type(connection_sets))
        return connection_sets

    @staticmethod
    def parse_topologies(topologies):
        if not topologies:
            raise TopologyConfigurationException("must define at least one topological entry")

        def build_cluster(topology):
            key = ClusterKey(topology["cluster"], topology["replica"])
            entries = [
                CEP129ConnectionEntry(number, key, entry)
                for number, entry in enumerate(topology["entries"])]
            return ConnectionCluster.create(key, entries, topology.get('rdr_cluster'), database=topology.get('database'))

        return ClusterGroup(build_cluster(topology) for topology in topologies)

    def get(self, cluster_key):
        return self.topologies.get(cluster_key)


def format_seq(seq):
    return ",".join(str(item) for item in seq)


def verify_uniqueness(lhs, rhs, message, exc_class=None):
    exc_class = exc_class or TopologyConfigurationException
    duplicated_sets = set(lhs) & set(rhs)
    if duplicated_sets:
        raise exc_class(message % format_seq(duplicated_sets))


def verify_expected(expected, actual, message, exc_class=None):
    exc_class = exc_class or TopologyConfigurationException
    missing = expected - actual
    if missing:
        raise exc_class(message % format_seq(missing))


def merge_cluster_groups(old_clusters, new_clusters):
    """Merge cluster groups, verify uniqueness of clusters and their entries
     and return the new cluster group.
     """
    clusters_to_add = ClusterGroup()
    for cluster in new_clusters:
        if cluster.key not in old_clusters:
            clusters_to_add.add(cluster)
            continue

        old_cluster = old_clusters[cluster.key]
        if old_cluster != cluster:
            msg = "Cluster names do not match: %s, %s"
            raise TopologyConfigurationException(msg % (old_cluster, new_clusters))

        msg = "Duplicate connection entry: %s"
        verify_uniqueness(old_cluster.entries, cluster.entries, msg)
        old_cluster.entries.extend(cluster.entries)

    # Add remaining old entries
    for cluster in old_clusters:
        if cluster not in clusters_to_add:
            clusters_to_add.add(cluster)
    return clusters_to_add


def verify_configuration(configuration):
    """Verify that the configuration dictionary contains at least one of
    the expected keys, and no un-expected keys.
    """
    expected_keys = set(['topology', 'connection_sets'])
    keys = set(configuration.keys())
    unexpected = keys - expected_keys
    if unexpected:
        msg = "Unexpected keys in topology configurations: %s"
        raise TopologyConfigurationException(msg % unexpected)

    if not keys & expected_keys:
        msg = "Missing one of the expected keys: %s"
        raise TopologyConfigurationException(msg % expected_keys)


ClusterKey = namedtuple('ConnectionKey', 'cluster replica')


class ConnectionCluster(object):
    """A data object which contains the configuration for a database
    cluster parsed from a topology file. A cluster consists of a key
    (identifying the cluster_name and replica), and a list of
    ConnectionEntry objects.
    """

    def __init__(self, key, entries, cluster_name=None, database=None):
        """
        key - ClusterKey object
        entries - list of ConnectionEntry objects
        cluster_name - name of this cluster, defaults to key.cluster
        """
        self.key = key
        self.cluster_name = cluster_name or key.cluster
        self.entries = entries
        self.database = database

    @classmethod
    def create(cls, key, entries, cluster_name, database=None):
        if key.replica == "master" and len(entries) > 1:
            msg = "Cannot have more than one master in cluster %s"
            raise TopologyConfigurationException(msg % key.cluster)
        return cls(key, entries, cluster_name, database=database)

    @property
    def num_entries(self):
        return len(self.entries)

    @property
    def total_weight(self):
        return sum(entry.weight for entry in self.entries)

    def __eq__(self, other):
        return self.key == other.key and self.cluster_name == other.cluster_name

    def __ne__(self, other):
        return not self == other

    def __str__(self):
        return "ConnectionCluster(%s, %s)" % (self.cluster_name, self.key)


class ClusterGroup(object):
    """A data object which contains the configuration for a group of
    clusters parsed from a topology file.
    """

    def __init__(self, clusters=()):
        """
        clusters - list of ConnectionCluster objects
        """
        self.clusters = dict()
        for cluster in clusters:
            self.add(cluster)

    def add(self, cluster):
        if cluster.key in self:
            msg = "Cluster %s replica level %s defined more than once"
            raise TopologyConfigurationException(msg % cluster.key)
        self.clusters[cluster.key] = cluster

    def __getitem__(self, cluster_key):
        return self.clusters[cluster_key]

    def get(self, cluster_key):
        return self.clusters.get(cluster_key)

    def __contains__(self, cluster_key):
        return cluster_key in self.clusters

    def __iter__(self):
        return self.clusters.itervalues()

    def keys(self):
        return self.clusters.keys()

    def __str__(self):
        return "ClusterGroup[%s]" % self.clusters


if __name__ == "__main__":
    import sys
    file_name = sys.argv[1]
    print "Verifying topology syntax of %s" % file_name
    with open(file_name, "r") as f:
        d = yaml.load(f)
        TopologyFile(d)
    print "%s passed validation" % file_name
