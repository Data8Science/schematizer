# -*- coding: utf-8 -*-
"""Reload global topology when the topology file changes, and the definition
for a cluster was modifieid.


.. code-block:: python

    from yelp_conn import load

    min_interval = 2  # seconds
    clusters = [('mycluster', 'master'), ('mycluster', 'slave')]
    watcher = load.build_config_watcher(min_interval, clusters)
    ...

    watcher.reload_if_changed()


"""
import logging

import staticconf.loader
import staticconf.config

import yelp_conn
from yelp_conn import (
    config,
    connection_set,
    engine,
    topology,
)


log = logging.getLogger(__name__)


def reinit():
    """Used to re-initialize the global ConnectionSets (and underlying objects).
    This should be called after a change to configuration.
    """
    log.warn("Re-initializing yelp_conn")
    with yelp_conn.globals_lock:
        connection_set.reset()
        engine.reset_and_uncache()
        yelp_conn.initialize()
        connection_set.ConnectionSet.rebuild_engine_managers()


def cluster_entries_eq(lhs, rhs):
    """Compare two :class:`yelp_conn.topology.ConnectionCluster` by their
    entries. This is a different comparison from the `__eq__` method they
    implement.
    """
    if not lhs or not rhs:
        return False
    return lhs.entries == rhs.entries


def clusters_eq(new_topology, clusters):
    """Compare a :class:`yelp_conn.topology.TopologyFile` to the global
    :class:`TopologyFile` by comparing the cluster entries for `clusters`.

    :param new_topology: a :class:`yelp_conn.topology.TopologyFile`
    :param clusters: a list of :class:`yelp_conn.topology.ClusterKey`
    :returns: True if all clusters have the same entries, False otherwise
    """
    global_topology = yelp_conn._global_topology
    return all(
        cluster_entries_eq(new_topology.get(cluster), global_topology.get(cluster))
        for cluster in clusters)


def build_config_loader(topology_filename, clusters, callbacks):
    reloader = staticconf.config.ReloadCallbackChain(
        namespace=config.namespace,
        callbacks=[('reinit', reinit)] + list(enumerate(callbacks or ())))

    def loader():
        log.info("yelp_conn.topology file %s modified", topology_filename)
        topology_file = topology.TopologyFile.new_from_file(topology_filename)
        if not clusters_eq(topology_file, clusters):
            reloader()

    return loader


def noop_reloader():
    """To support extra conditional logic the reload is happening in the
    config_loader function, so use a no-op reloader.
    """
    pass


def validate_clusters(clusters):
    if not clusters:
        raise ValueError("clusters should not be empty.")

    for item in clusters:
        if len(item) != 2:
            raise ValueError("each cluster should be a (cluster, replica) ",
                             "pair, invalid cluster: %r" % (item,))


def build_config_watcher(interval, clusters, callbacks=None):
    """Build a :class:`staticconf.config.ConfigurationWatcher` that watches
    `yelp_conn.config.topology` for modification. When it is modified, and one
    of the `clusters` changes, the watcher will reload the `global_topology`
    and call :func:`reinit`.

    :param interval: a minimum interval (in seconds) to wait before checking
                     for file modifications.
    :type  interval: int
    :param clusters: a list of clusters to monitor for changes
    :type  clusters: list of `(cluster, replica)` pairs
    :param callbacks: a list of callables to run after a reload
    :returns: a :class:`staticconf.config.ConfigurationWatcher`
    """
    validate_clusters(clusters)
    filename = config.topology.value
    return staticconf.config.ConfigurationWatcher(
        build_config_loader(filename, clusters, callbacks),
        filename,
        min_interval=interval,
        reloader=noop_reloader,
        comparators=[staticconf.config.MD5Comparator])
