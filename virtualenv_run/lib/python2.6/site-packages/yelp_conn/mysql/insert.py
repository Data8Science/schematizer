# -*- coding: utf-8 -*-
from sqlalchemy import Column
from sqlalchemy.ext.compiler import compiles
from sqlalchemy.sql.expression import Insert


class InsertOnDuplicateUpdate(Insert):
    pass

try:
    InsertOnDuplicateUpdate.argument_for("mysql", "update_columns", None)

except (AttributeError, KeyError):
    # argument_for not supported in this version of sqlalchemy
    # see https://bitbucket.org/zzzeek/sqlalchemy/issue/3024
    pass

else:
    def insert_on_duplicate_update(table, update_columns, **kwargs):
        """Return a INSERT...ON DUPLICATE UPDATE clase element.

        This adds support for MySQL's INSERT statement addition which inserts
        new rows into a table, but on inserts which would cause a duplicate
        value in a UNIQUE index or PRIMARY KEY, update the existing rows with
        the values as described.  This function supports a subset of the
        original mysql behavior: it will always update the row with the value
        specified in the insert attempt.

        For example, on a table containing [(a, 1, 10)] with the first element
        as primary key, attempting to insert [(a, 5, 20), (b, 5, 50)] with
        mysql_update_columns as the second column would result in the table
        containing [(a, 5, 10), (b, 5, 50)].

        Please note the side effects in the MySQL documentation:
        - INSERTS will increment auto-increment counters
        - This statement will update *one* row, even in the presence of
        multiple unique indexes.

        table : SQLAlchemy table
                The DB table on which to perform the operation
        mysql_update_columns : list of SQLAlchemy columns of the table to
                update. On a duplicate key error, these columns will be updated
                with the new value, while all other columns will remain the
                same.
        kwargs : additional keyword arguments to standard Insert statement
        """
        if update_columns and all(isinstance(c, Column) for c in
                                  update_columns):
            return InsertOnDuplicateUpdate(
                table,
                mysql_update_columns=update_columns,
                **kwargs)
        else:
            raise ValueError("update_columns must have non-zero number of "
                             "Columns. Was passed %r" %
                             update_columns)

    @compiles(InsertOnDuplicateUpdate)
    def compile_insert_on_duplicate_update(element, compiler, **kwargs):
        raise NotImplementedError(
            'insert_on_duplicate_update is only implemented for mysql')

    @compiles(InsertOnDuplicateUpdate, 'mysql')
    def compile_insert_on_duplicate_update_mysql(insert, compiler, **kw):
        s = compiler.visit_insert(insert, **kw)
        return (s +
                " ON DUPLICATE KEY UPDATE " +
                ",".join(
                    "%s=VALUES(%s)" % (k, k)
                    for k in insert.kwargs['mysql_update_columns'])
                )
