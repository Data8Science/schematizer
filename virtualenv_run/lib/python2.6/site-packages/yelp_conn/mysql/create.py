# -*- coding: utf-8 -*-
"""Utilities to create tables."""
from MySQLdb import string_literal

from yelp_conn.mysql.common import generic_index_sql
from yelp_conn.mysql.common import restrict_kwargs


def create_table(cursor, tbl_name, *create_defs, **kwargs):
    """Simple (not fully-featured) interface to CREATE TABLE. (If you want
    more features, feel free to add them. :)

    For example:
    create_table('foo',
                 column('name', 'VARCHAR(255)', null=False),
                 column('parent_id', 'INT'),
                 index('parent_id'),
                 engine='MyISAM')

    Args:
    cursor -- DB cursor
    tbl_name -- name for the new table
    create_defs -- SQL clauses to create columns and indexes

    Keyword Args (all optional):
    charset -- default charset to use for text fields, e.g. 'utf8'
    collate -- default collation to use for text fields, e.g. 'utf8_unicode_ci'
    engine -- DB engine to use, e.g. 'MyISAM', 'InnoDB'
    if_not_exists -- if table already exists, don't raise an error (default False)
    pack_keys -- enable PACK_KEYS (MyISAM only). Should be '0', '1', or 'DEFAULT'.
        See alter.pack_keys_option() for details
    row_format -- how to store rows, one of 'DEFAULT', 'DYNAMIC', 'FIXED', 'COMPRESSED', 'REDUNDANT', 'COMPACT'
    like -- an existing table to use as a template.  Overrides any create_defs.
    """
    restrict_kwargs(kwargs, ('charset', 'collate', 'engine', 'if_not_exists', 'pack_keys', 'row_format', 'like'))

    # build table options
    table_options = []
    # these all take the form NAME=value
    for option in 'charset', 'collate', 'engine', 'pack_keys', 'row_format':
        option_value = kwargs.get(option)
        if option_value is not None:
            table_options.append('%s=%s' % (option.upper(), option_value))

    if 'like' in kwargs:
        create_defs = ['LIKE `%s`' % kwargs['like']]

    sql = 'CREATE TABLE %s `%s` (%s) %s' % (
        'IF NOT EXISTS' if kwargs.get('if_not_exists') else '',
        tbl_name,
        ', '.join(create_defs),
        ', '.join(table_options))
    cursor.execute(sql)

def column(name, col_type, null=True, default=None, unsigned=False, zerofill=False, charset=None, collate=None, auto_increment=False, key=False, unique=False, primary_key=False, comment=None, references=None):
    """Create a clause for a CREATE TABLE statement to create a column.

    The main value of this method over raw SQL is that you don't have to remember
    the ordering.

    Args:
    name -- name of the column
    col_type -- type of the column, e.g. 'INT', 'VARCHAR(255)'.
    null -- does this column accept null values?
    default -- default value for this column
    unsigned -- (numeric fields only) does this hold unsigned integers?
    zerofill -- (numeric fields only) fill with zeros when displaying?
    charset -- (text fields only) character set for this field, if different
        from the table's charset
    collate -- (text fields only) collation for this field, if different from
        the table's collation
    auto_increment -- is this an auto-increment field?
    key -- create a (non-unique) index on this one column. You can also use
        index() to define indexes
    unique -- create a unique index on this one column. You can also use
        unique_index() to define unique indexes
    primary_key -- make this column the primary key for the table. You can
        also use primary_key() to define the primary key
    comment -- comment describing this column
    references -- SQL for foreign key constraints, e.g. 'business(id) FULL_MATCH'
    """
    sql = '%s %s' % (name, col_type)
    if unsigned:
        sql += ' UNSIGNED'
    if zerofill:
        sql += ' ZEROFILL'
    if charset:
        sql += ' CHARSET %s' % (charset,)
    if collate:
        sql += ' COLLATE %s' % (collate,)
    if not null: # NULL is the default
        sql += ' NOT NULL'
    if default is not None:
        sql += ' DEFAULT %s' % string_literal(default)
    if auto_increment:
        sql += ' AUTO_INCREMENT'
    if primary_key:
        sql += ' PRIMARY KEY'
    elif unique:
        sql += ' UNIQUE'
    elif key:
        sql += ' KEY'
    if comment is not None:
        sql += ' COMMENT %s' % string_literal(comment)
    if references:
        sql += ' REFERENCES %s' % (references,)

    return sql

def _index_generic(index_type, col_names, **kwargs):
    """Helper for index() and related methods, below."""

def index(*col_names, **kwargs):
    """Create an INDEX clause for an CREATE TABLE statement.

    Args:
    col_names -- sequence of names of columns to add an index on

    Keyword Args (all optional):
    index_name -- name for your new index (optional)
    using -- kind of index to use (e.g. 'BTREE', 'RTREE', 'HASH'). If unspecified,
        we just use the default

    Returns:
    a string like 'INDEX foo_idx USING BTREE (`foo`)'
    """
    restrict_kwargs(kwargs, ('index_name', 'using'))
    return generic_index_sql('INDEX', *col_names, **kwargs)

def unique_index(*col_names, **kwargs):
    """Create a UNIQUE INDEX clause for an CREATE TABLE statement.

    Args:
    col_names -- sequence of names of columns to add an index on

    Keyword Args (all optional):
    index_name -- name for your new index (optional)
    using -- kind of index to use (e.g. 'BTREE', 'RTREE', 'HASH'). If unspecified,
        we just use the default

    Returns:
    a string like 'UNIQUE INDEX bar_foo_idx USING BTREE (`bar`, `foo`)'
    """
    restrict_kwargs(kwargs, ('index_name', 'using'))
    return generic_index_sql('UNIQUE INDEX', *col_names, **kwargs)

def primary_key(*col_names, **kwargs):
    """Create a PRIMARY KEY clause for an CREATE TABLE statement.

    Args:
    col_names -- sequence of names of columns to add an index on

    Keyword Args (all optional):
    using -- kind of index to use (e.g. 'BTREE', 'RTREE', 'HASH'). If unspecified,
        we just use the default

    Returns:
    a string like 'PRIMARY KEY USING BTREE (`baz`, `quz`)'
    """
    restrict_kwargs(kwargs, ('using',))
    return generic_index_sql('PRIMARY KEY', *col_names, **kwargs)

def create_database(cursor, db_name, if_not_exists=False, charset=None, collate=None):
    """Create a logical database with the given name.

    Args:
    cursor -- the DB cursor
    db_name -- name for the db
    if_not_exists -- if the database already exists, silently do nothing
    charset -- default character set for newly created tables in this db
        (e.g. 'utf8')
    collate -- default collation for newly create tables in this db
        (e.g. 'utf8_unicode_ci')
    """
    if not isinstance(if_not_exists, bool):
        raise ValueError('if_not_exists must be True or False. Did you mean to call create_table()?')

    sql = 'CREATE DATABASE %s `%s` %s %s' % (
        'IF NOT EXISTS' if if_not_exists else '',
        db_name,
        'CHARSET=%s' % (charset,) if charset else '',
        'COLLATE=%s' % (collate,) if collate else '')
    cursor.execute(sql)

