# -*- coding: utf-8 -*-
"""Miscellaneous statements that don't fit in elsewhere"""

import sqlalchemy.sql.expression


def use(cursor, db_name):
    """Make the given database our default."""
    sql = 'USE `%s`' % (db_name)
    cursor.execute(sql)

def insert_many(cursor, table_name, rows, column_names=None, ignore=False):
    """
        Inserts all rows stored in `rows` into `table_name` at once.

        Intended for performance-intensive tasks.

        Params:
            table_name -- name of the table
            column_names -- names of columns to insert, preferably in primary key order; can
                            be None if you just want this inferred
            rows -- an iterator of {col_name : value} dict
            ignore -- ignore duplicate primary key entries

        Returns:
            number of rows affected
    """
    if not rows:
        return 0

    # Guess the column names
    rows = list(rows)
    if not column_names:
        column_names = rows[0].keys()

    # Insert in primary key order for minimum seeks
    row_tuples = sorted(tuple(row_dict[col_name] for col_name in column_names) for row_dict in rows)

    # We need to construct two things:
    # -- a properly formatted string with a unique parameter for each value we're inserting
    # -- a dictionary mapping each parameter to the right value
    values_dict = {}
    row_str_list = []
    i = 0
    for row in row_tuples:
        row_list = []
        for value in row:
            # We don't want to parameterize unix_timestamp(), special case -mtai
            if isinstance(value, sqlalchemy.sql.expression.FunctionElement):
                row_list.append(str(value))
                continue

            key = "v%d" % i
            values_dict[key] = value
            row_list.append("%%(%s)s" % key)
            i += 1
        row_str_list.append(", ".join(row_list))

    rows_str = "), (".join(row_str_list)

    # Format the rest of the query
    cmd = "INSERT"
    if ignore:
        cmd += " IGNORE"
    column_names = ['`%s`' % col for col in column_names]
    col_names = ", ".join(column_names)
    query = "%s INTO `%s` (%s) VALUES (%s)" % (cmd, table_name, col_names, rows_str)
    cursor.execute(query, values_dict)
    return cursor.rowcount
