"""A SQLAlchemy extension for doing replication safe deletes."""

import sqlalchemy
from sqlalchemy.ext import compiler
try:
    from sqlalchemy.sql.base import _generative
    _generative  # pyflakes
except ImportError:
    # 0.7 and prior
    from sqlalchemy.sql.expression import _generative
from sqlalchemy.sql import expression


# SQLAlchemy doesn't support a limit clause on delete queries because it is MySQL
# specific, so let's add our own that only works on MySQL.

def delete_with_limit(table, whereclause=None, **kwargs):
    """Return a DeleteWithLimit clause element.

    This works just like sqlalchemy.sql.expression.delete() except that the resulting
    object supports limit(), offset(), and order_by() methods just like SELECT
    queries. Note that this is only implemented for MySQL - trying to run the
    resulting queries on other databases will raise an exception. order_by is required
    to ensure that replication is safe.
    """
    return DeleteWithLimit(table, whereclause, **kwargs)


class DeleteWithLimit(expression.Delete):

    _limit = None
    _offset = None
    _order_by_clause = None

    @_generative
    def limit(self, limit):
        """return a new selectable with the given LIMIT criterion applied."""
        self._limit = sqlalchemy.util.asint(limit)

    @_generative
    def offset(self, offset):
        """return a new selectable with the given OFFSET criterion applied."""
        self._offset = sqlalchemy.util.asint(offset)

    @_generative
    def order_by(self, *clauses):
        """return a new selectable with the given list of ORDER BY
        criterion applied.

        The criterion will be appended to any pre-existing ORDER BY
        criterion.
        """
        self.append_order_by(*clauses)

    def append_order_by(self, *clauses):
        """Append the given ORDER BY criterion applied to this selectable.

        The criterion will be appended to any pre-existing ORDER BY criterion.
        """
        if len(clauses) == 1 and clauses[0] is None:
            self._order_by_clause = expression.ClauseList()
        else:
            if getattr(self, '_order_by_clause', None) is not None:
                clauses = list(self._order_by_clause) + list(clauses)
            self._order_by_clause = expression.ClauseList(*clauses)


@compiler.compiles(DeleteWithLimit)
def compile_delete_with_limit(element, compiler, **kwargs):
    raise NotImplementedError('delete_with_limit is only implemented for mysql')


@compiler.compiles(DeleteWithLimit, 'mysql')
def compile_delete_with_limit_for_mysql(element, compiler, **kwargs):
    assert element._order_by_clause is not None and len(element._order_by_clause) > 0, 'delete_with_limit requires the use of order_by to ensure that replication is safe'

    clauses = [
        compiler.visit_delete(element),
        compiler.order_by_clause(element),
        compiler.limit_clause(element),
    ]

    # The compiler puts newlines and/or extra spaces around some clauses which
    # complicates query parsing, so normalize things a bit. See #37583.
    clauses = (each_clause.strip() for each_clause in clauses)

    return ' '.join(clauses)
