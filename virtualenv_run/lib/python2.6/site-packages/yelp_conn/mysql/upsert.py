# -*- coding: utf-8 -*-
"""Utils for upserting."""
import sqlalchemy

from yelp_conn.column_utils import get_column_name

def upsert_many(model_cls, session, keys, rows):
    """ A convenient and possibly efficient way to upsert lots of rows.

    For each row, if the table contains an existing row with the same value
    for each of the keys, the db row will be updated to match the input row;
    if no such row exists in the database, one will be created and inserted.

    We can't use sqlalchemy's session.merge generally because it only dedupes
    on primary key, and we have a lot of surrogate id primary keys.

    :param model_cls: the sqlalchemy model to upsert into
    :param session: a sqlalchemy session
    :param keys: the sqlalchemy columns to compare against when picking update \
or insert
    :param rows: a list of rows to upsert, in dict format (ie \
{'column1': 'value1', ...}); the keys should be the names of the \
model columns
    """
    table = model_cls.__table__

    old_expressions = []
    for row in rows:
        # key.key is the ORM model name for the column, instead of the database
        # name; since this is an ORM function we should use ORM names in the dict
        filters = [key == row[key.key] for key in keys]
        old_expressions.append(sqlalchemy.and_(*filters))

    old_rows = session.query(*keys).filter(
        sqlalchemy.or_(*old_expressions),
    ).with_lockmode('update').all()
    old_rows = set(old_rows)

    # SQLAlchemy reserves the names of columns for the bindparams it uses
    # for the part of the query that sets values.  We want to bind params
    # to the keys in the Where clause, so we can't use the column names,
    # and instead prefix the conditionals with a 'not_a_column_', which is
    # very unlikely to collide with any actual column names.
    bind_param_prefix = 'not_a_column_'
    to_insert = []
    to_update = []

    for row in rows:
        row_key = tuple([row[key.key] for key in keys])

        # This is just to fix the case where the model Column has a different name than the table column
        db_name_row = {}
        for column in table.columns:
            if column.key in row:
                db_name_row[get_column_name(column)] = row[column.key]

        if row_key not in old_rows:
            to_insert.append(db_name_row)
        else:
            for key in keys:
                db_name_row[bind_param_prefix + key.key] = db_name_row.pop(get_column_name(key))
            to_update.append(db_name_row)

    if to_update:
        match_expressions = []
        for key in keys:
            match_expressions.append(key == sqlalchemy.bindparam(bind_param_prefix + key.key))

        update_statement = table.update().where(sqlalchemy.and_(*match_expressions))
        session.execute(update_statement, to_update)

    if to_insert:
        session.execute(table.insert(), to_insert)
