# -*- coding: utf-8 -*-
import logging

from MySQLdb import constants

import yelp_conn.mysqldb
from yelp_conn import config
from yelp_conn.sqlchecker import CheckExplainConnectionWrapper
from yelp_conn.wrappers import AutocommitGuardConnectionWrapper
from yelp_conn.wrappers import EquivalenceConnectionWrapper
from yelp_conn.wrappers import IsInstanceEncoderConnectionWrapper
from yelp_conn.wrappers import ToDBConnectionWrapper


log = logging.getLogger(__name__)


def _base_connection(conn_params, name, cluster):
    """Used by MySQLTestCase to get a 'bare' connection without all the wrapper cruft"""
    base_conn = yelp_conn.mysqldb.connect(**conn_params)
    base_conn.name = name
    base_conn.description = ('%s/tid=%s (%s:%r)' % (name,
                                                    base_conn.thread_id(),
                                                    conn_params.get('host'),
                                                    conn_params.get('port')))
    base_conn.cluster = cluster
    # To get around the horrible situation of cursor.connection not being
    # equal to the actual connection due to weakref.proxy being really janky,
    # we have to do comparisons based on something else. See
    # EquivalenceConnectionWrapper for more details
    base_conn.me = base_conn

    return base_conn


# Facilitate testing with mock.patch
importer = __import__

def _apply_injected_wrappers(conn, name, conn_params):
    """Wrap conn in config.connection_wrappers and return the wrapped connection.
    """
    wrapper_kwargs = {
        'role': name,
        'db': conn_params.get('db')
    }
    for wrapper_path in config.connection_wrappers:
        module_name, wrapper_name = wrapper_path.rsplit('.', 1)
        module = importer(module_name, globals(), locals(), [wrapper_name])
        wrapper = getattr(module, wrapper_name)
        conn = wrapper(conn, **wrapper_kwargs)
    return conn


def _wrap_connection(base_conn, name, conn_params, auto_commit):
    conn = EquivalenceConnectionWrapper(base_conn)
    conn = IsInstanceEncoderConnectionWrapper(conn)

    if config.enable_gross_query_checking:
        conn = CheckExplainConnectionWrapper(conn)

    conn = _apply_injected_wrappers(conn, name, conn_params)

    if auto_commit:
        conn = AutocommitGuardConnectionWrapper(conn)

    return ToDBConnectionWrapper(conn)


disable_query_cache = config.conn_conf.get_bool(
        'db.disable_query_cache',
        default=False,
        help="Disable mysql query cache by setting query_cache_type = 0")


def _init_connection(base_conn, auto_commit):
    """Initialize the connection by setting `AUTOCOMMIT` and `SQL_MODE`
    settings.
    """
    with base_conn as cursor:
        if auto_commit:
            cursor.execute("SET AUTOCOMMIT = 1")
        else:
            cursor.execute("SET AUTOCOMMIT = 0")

        cursor.execute("SET SQL_MODE = 'STRICT_TRANS_TABLES'")

        if disable_query_cache:
            cursor.execute("SET SESSION query_cache_type = 0")


def setup_mysql_connection(name,
                           conn_params,
                           auto_commit=False,
                           cluster='replication'):
    """Build a mysql connection and wrap it in connection wrappers.

    :param name: A name for the connection
    :type  name: string
    :param conn_params: conection parameters passed to :func:`MySQLdb.connect`
    :type  conn_params: dict
    :param auto_commit: Flag to enable auto comit
    :type  auto_commit: bool
    :param cluster: name of the cluster, defaults to `replication`
    :type  cluster: string
    :returns: a mysql connection
    """
    if config.interactive_db_connections:
        conn_params['client_flag'] = (
            conn_params.get('client_flag', 0) |
            constants.CLIENT.INTERACTIVE)

    base_conn = _base_connection(conn_params, name, cluster)

    log.debug('connect mysql %s@%s:%s/%s as %s/tid=%s',
        conn_params.get('user'),
        conn_params.get('host'),
        conn_params.get('port'),
        conn_params.get('db'),
        name,
        base_conn.thread_id())

    _init_connection(base_conn, auto_commit)
    return _wrap_connection(base_conn, name, conn_params, auto_commit)
