from __future__ import with_statement
"""Transaction stuff"""
import contextlib
import weakref

from yelp_conn import signals


# Transaction signals. Each of these signals is sent AFTER the described operation.
# So, if you signal threw an exception on the COMMIT transaction, the transaction is already
# committed.
# Args: sender is the db connection
TXN_START    = 'yelp_conn.txn.trans_start'
TXN_END      = 'yelp_conn.txn.trans_end'
TXN_COMMIT   = 'yelp_conn.txn.trans_commit'
TXN_ROLLBACK = 'yelp_conn.txn.trans_rollback'

# Constants for transaction isolation level
LEVEL_READ_COMMITTED   = "READ COMMITTED"
LEVEL_READ_UNCOMMITTED = "READ UNCOMMITTED"
LEVEL_SERIALIZABLE     = "SERIALIZABLE"
LEVEL_REPEATABLE       = "REPEATABLE READ"

REQUEST_AUX_COMMIT = 'request_aux_commit'

def start_transaction(db_conn, level=LEVEL_REPEATABLE):
    """Setup a db connection with the given isolation level and start a transaction"""
    cursor = db_conn.cursor()
    if level not in (None, LEVEL_REPEATABLE):
        cursor.execute("SET SESSION TRANSACTION ISOLATION LEVEL %s" % level or LEVEL_REPEATABLE)

    cursor.execute("START TRANSACTION")
    cursor.close()

def set_session_isolation_level(db_conn, level=LEVEL_REPEATABLE):
    """Setup a db connection with the given session isolation level"""
    cursor = db_conn.cursor()
    cursor.execute("SET SESSION TRANSACTION ISOLATION LEVEL %s" % level)
    cursor.close()

@contextlib.contextmanager
def begin(db_conn, ro=False, level=LEVEL_REPEATABLE):
    """Run a transaction block with a DBI connection

    Arguments
    db_conn -- the connection to perform the transaction
    ro -- bool, readonly: should we rollback after doing the
    level -- str, one of LEVEL_*
    """
    cursor = None

    try:
        start_transaction(db_conn, level=level)
        signals.send(TXN_START, db_conn)

        cursor = db_conn.cursor()
        yield cursor

        if ro:
            db_conn.rollback()
            signals.send(TXN_ROLLBACK, db_conn)
        else:
            db_conn.commit()
            signals.send(TXN_COMMIT, db_conn)

    except:
        db_conn.rollback()
        signals.send(TXN_ROLLBACK, db_conn)
        raise

    finally:
        if cursor:
            cursor.close()

        # Decrease transaction isolation level, since we set it it for the
        # whole SESSION, not just the next transaction. Under 5.0, this
        # is required even for a regular SET TRANSACTION ISOLATION LEVEL,
        # due to MySQL bug http://bugs.mysql.com/bug.php?id=7955 .
        cursor = db_conn.cursor()
        if level not in (LEVEL_REPEATABLE, None):
            cursor.execute('SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ')
        cursor.close()

        signals.send(TXN_END, db_conn)

def signal_on_commit(db_conn, signal_name, sender, **arguments):
    """Helper function for sending a signal when a given db connection is committed."""
    # Hack to get around weakproxy
    if type(db_conn) == weakref.ProxyType and hasattr(db_conn, "me"):
        db_conn = db_conn.me

    # In theory we should be able to replace this with
    #     db_conn.defer(lambda: signals.send(signal_name, sender, **arguments))
    # but somehow it changes the ordering that signals are sent in, which causes
    # complex signals users to break. Maybe someone smarter than me (evan) can
    # figure it out.

    signals.send_after((TXN_COMMIT, db_conn), signal_name, sender, **arguments)

