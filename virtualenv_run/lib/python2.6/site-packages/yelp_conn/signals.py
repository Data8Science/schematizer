"""Module for signal dispatch. Copied from yelp_lib.

You have A, B and C.  If whenever A does certain behavior, B and C need to get
notified and you don't want A to depend on B or C, then this module is for
you!

Example:

from yelp_conn import signals


Setup a new signal:

In yelp/logic/lemonade.py:

NEW_LEMONADE = "yelp.logic.lemonade.new"

class Lemonade:
    def new_lemonade(self):
        ... make lemonade ...
        signals.send(NEW_LEMONADE, self, cost=5.0)

In yelp/logic/lemonade_report.py
from yelp.logic import lemonade

def lemonade_watch(name, sender, info):
    emailer.send_email("bran@yelp.com", subject="Lemonade Watcher", body="Someone bought $%(cost)3.02f of lemonade" % info)

In yelp/logic/_logic:
   signal_connections = [(lemonade.NEW_LEMONADE, [('yelp.logic.lemonade_report', 'lemonade_watch')])]

---

SignalCenters (same API, just avoid using a global signal center):

myfile.py:
center = signals.SignalCenter()

def my_callback(signal, sender, args):
    print args.ruffage

center.connect(MY_SIGNAL, my_callback)

center.send(MY_SIGNAL, ruffage="roses")

"""
import re
import weakref
from logging import getLogger

log = getLogger('yelp_conn.signals')

# Signal names should be like 'a', or 'a.b' or 'a.b.c...'
_signal_name_pattern = re.compile(r'^[a-z0-9_\-]+(?:[.][a-z0-9_\-]+)*$')

class CircularSignalError(Exception): pass

class ListenerSpec(object):
    """Object encapsulating the listening callable and all the information we need about matching signals
        up to it.
    """
    def __init__(self, listener, sender, custom_listener_id, weak=True, is_one_time=False):
        """build a listener spec

            Args -
                listener - callable that should receive signals
                sender - (optional) filter matches based on the sender. None matches all senders
                custom_listener_id - id used to store the listener
                weak - (optional) keep a weak reference to the listener.
                is_one_time - flag indicating to the SignalCenter that we'll be dropping this afterward
        """
        if weak and listener is not None:
            self._listener = weakref.ref(listener)
        else:
            self._listener = listener

        self.is_weak = weak
        self.is_one_time = is_one_time
        self.sender = sender
        self.listener_id = custom_listener_id

    @property
    def listener(self):
        if self._listener is None:
            return None
        elif self.is_weak:
            func = self._listener()
            if func is None:
                raise Exception("Listener went away")
        else:
            func = self._listener

        return func

    def __call__(self, *args, **kwargs):
        return self.listener(*args, **kwargs)

    def match(self, sender=None):
        """Test if this listener spec is an appropriate match for the provided signal data.

        Right now we only optionally filter on who the sender is. But this could be extended to do whatever.
        """
        if self.sender is None:
            return True

        # We have to be careful here, my first instince was to use 'is' to ensure it's the same sender object,
        # but that makes our mysql connections very difficult to deal with. So instead we'll use equivalence and
        # assume that these sender objects compare themselves sanely.
        return bool(self.sender == sender)

    @property
    def id(self):
        if self.listener_id is not None:
            return (self.listener_id, None)
        else:
            return (id(self.listener), self.sender)

    def __repr__(self):
        return "<ListenerSpec for %r %r>" % (self.listener, self.sender)

    def __str__(self):
        return str(self.listener)

#
# TODO
#   This is a workaround for truly bizarre behavior when calling
#   SetBoundConnectionWrapper.__repr__. I can't say that it makes
#   sense, but buildbot runs out of MySQL connections
#   ('Too many connections' error) when a reference to a
#   SetBoundConnectionWrapper is printed via logger.debug(..).
#   The simplest workaround is to print the type instead of
#   the instance.  May have something to do with weakrefs..
#
#   The other types of listeners that don't seem to cause
#   any problems include:
#
#   - ListenerSpec
#   - sqlalchemy.orm.session.Session
#   - _Logic
#   - arbitrary functions
#
#   To reproduce the error locally:
#       python -m yelp.testing.sandbox.run --timeout 300 --without apache -v testify yelp.tests --json-results-logging --json-results results.json --extra-json-info '{"branch":"12-09-fix-refs-to-signals-take2", "revision":"e525c16c53f22ad476d589aacedcf4719b479b28", "buildbot_id":"3", "buildername":"sandbox_11", "buildnumber":"3993", "slavename":"buildbotbb11sv"}' --label 12-09-fix-refs-to-signals-take2_e525c16c53f22ad476d589aacedcf4719b479b28 --exclude-suite disabled --exclude-suite buildbot-disabled --verbose --summary --bucket 11 --bucket-count 30 --bucket-salt 12-09-fix-refs-to-signals-take2 --exclude-suite sandbox-disabled --exclude-suite external-deps
#
#   https://trac.yelpcorp.com/ticket/27414
#
def safe_for_printing(listener):
    if 'SetBoundConnectionWrapper' in type(listener).__name__:
        return type(listener)
    else:
        return listener


class Signalet(object):
    """A signal

    Usually this is constructed by a SignalCenter()

    Arguments:
    name -- a signal name like 'a.signal.name'
    listeners -- a dictionary of object id -> listener
    strict -- bool, validate signal names and signal argumnets

    """
    def __init__(self, name=None, listeners=None, weak_listeners=None, strict=True):
        if strict:
            _validate_signal_name(name)

        self.name = name
        self.strict = bool(strict)
        self.listeners = listeners if listeners is not None else {}

        # We keep track of what this signal is handling so we can track
        # down any circular signal relationships. This makes it MUCH easier to debug
        self.currently_handling = set()

    def connect(self, listener, weak=True, listener_id=None, sender=None, one_time=False):
        """Listen for signals

        By default all signal connections are weak to avoid garbage collection
        issues.  You can turn this off by passing weak=False and calling
        .disconnect() to disconnect signals manually.  Note that instance
        methods and class methods will probably get immediately gc'ed with
        weak=True

        Arguments:
        listener -- the callable object listening for signals
        weak -- bool, keep tracking of listener using a weak reference
        listener_id -- obj, keep track of listener using this identifier instead of creating one
        sender - optional additional filter. Only connect to this signal if it originates from this sender
        """
        log.debug("Connecting signal %s to %r", self.name, safe_for_printing(listener))

        listener_spec = ListenerSpec(listener, sender, listener_id, weak=weak, is_one_time=one_time)

        assert listener_spec.id not in self.listeners
        self.listeners[listener_spec.id] = listener_spec

    def disconnect(self, listener, listener_id=None, sender=None, listener_spec=None):
        """Disconnect a listener from this signal
        """
        if listener_spec is not None:
            if any((listener_id, sender, listener)):
                raise ValueError("Providing a listener_spec is everything you need.")
            log.debug("Disconnecting signal %s by spec %r", self.name, safe_for_printing(listener_spec))
        else:
            log.debug("Disconnecting signal %s from %r", self.name, safe_for_printing(listener))
            listener_spec = ListenerSpec(listener, sender, listener_id)

        if listener_spec.id in self.listeners:
            del self.listeners[listener_spec.id]
        else:
            log.warning("Failed to remove listener %r (%r)", listener_spec, listener_spec.id)

    def send(self, sender, safe=False, **arguments):
        """Send a signal to all listeners

        Arguments:
        sender -- the sender invoking the signal
        arguments -- keyword arguments that should match the list of arguments
        in .arguments.  This will be passed to each listener as a dictionary.
        """
        log.debug("Sending signal %s from %r", self.name, safe_for_printing(sender))

        matches = []
        disconnects = []

        arguments = AttrDict(arguments)

        for listener_spec in self.listeners.itervalues():
            if not listener_spec.match(sender=sender):
                log.debug("Sender %r didn't match %r", sender, safe_for_printing(listener_spec.sender))
                continue

            if listener_spec.is_one_time:
                disconnects.append(listener_spec)

            matches.append(listener_spec)

        # We have to do this outside the loop because the listener list can't change during iteration.
        for listener_spec in disconnects:
            self.disconnect(None, listener_spec=listener_spec)

        for listener_spec in matches:
            log.debug("Delivering signal %s to %r", self.name, safe_for_printing(listener_spec))

            if listener_spec in self.currently_handling:
                raise CircularSignalError("Already handling %r" % listener_spec)

            self.currently_handling.add(listener_spec)

            try:
                listener_spec(self.name, sender, arguments)
            except Exception:
                if safe:
                    log.exception("Failure processing signal %s for %r", self.name, sender)
                else:
                    raise
            finally:
                self.currently_handling.remove(listener_spec)

def _validate_signal_name(name):
    """Pedantry to enforce that signal names are lower case letters separated
    by dots"""
    if not _signal_name_pattern.match(name):
        raise ValueError("unexpected signal name")


class SignalCenter(object):
    """A center from which signals are sent/subscribed to

    Example usage:

    signal_center = SignalCenter()

    # Setup a handler
    @signal_center.receive('firedrill')
    def handle_fire_drill(signal_name, sender, data):
        print "got a fire drill with this data", data, "from", sender


    class Alarm(object):
        def drill(self):
            signal_center.send("firedrill", self,)


    Alarm().drill() # prints "got a fire drill..."
    """

    def __init__(self, signals=None, strict=True, signal_class=Signalet):
        self.strict = bool(strict)
        self.signals = signals if signals is not None else {}
        self.signal_class = signal_class
        self.after_calls = dict()

    def send(self, signal_name, sender, **arguments):
        """Send a signal named signal_name from sender with arguments"""
        self._get_signal(signal_name).send(sender, safe=False, **arguments)

    def send_safe(self, signal_name, sender, **arguments):
        """Send a signal named signal_name from sender with arguments"""
        self._get_signal(signal_name).send(sender, safe=True, **arguments)

    def send_after(self, on_signal, signal_name, sender, **arguments):
        """Send a signal (signal_name) after waiting for another signal (on_signal)

        Args -
            on_signal - Either a signal name or a tuple of (signal name, sender) to be more specific
            signal_name - the signal that should be sent
            sender - who sent the signal
            **arguments - optional keyword arguments to pass to the listeners

        For example, suppose you want to send a signal after the current transaction has been committed.
        Since transaction generate signals, this is easy:

        signals.send_after((TXN_COMMIT_SIGNAL, cursor.connection), MY_SIGNAL, self)
        """
        if isinstance(on_signal, tuple):
            on_signal_name, on_signal_sender = on_signal
        else:
            on_signal_name = on_signal
            on_signal_sender = None

        def on_signal_func(signal_, sender_, args_):
            # Unregister ourselves
            if on_signal_func in self.after_calls:
                del self.after_calls[on_signal_func]
            else:
                # This can happen because after calls was cleaned up from a test case after we detected a problem.
                log.warning("Signal function missing from after call db")
            self.send(signal_name, sender, **arguments)

        # We're going to register this callback function so instrumentation can catch when signals have been lost
        on_sig_sender_ref = weakref.ref(on_signal_sender) if on_signal_sender else None
        sender_ref = weakref.ref(sender) if sender else None
        self.after_calls[on_signal_func] = (on_signal_name, on_sig_sender_ref, signal_name, sender_ref)

        self.connect(on_signal_name, on_signal_func, weak=False, sender=on_signal_sender, one_time=True)

    def reset_after_calls(self):
        self.after_calls.clear()

    def connect(self, name, listener, weak=True, listener_id=None, sender=None, one_time=False):
        """Listen for signals

        Arguments:
        name -- signal name
        listener -- the callable object listening for signals
        weak -- bool, keep tracking of listener using a weak reference
        listener_id -- obj, keep track of listener using this identifier instead of creating one
        one_time -- bool, only handle one signal. Disconnect afterwards.
        """
        self._get_signal(name).connect(listener, weak=weak, listener_id=listener_id, sender=sender, one_time=one_time)

    def disconnect(self, name, listener, listener_id=None):
        """Disconnect a listener from signal_name"""
        self._get_signal(name).disconnect(listener, listener_id=listener_id)

    def _get_signal(self, name):
        """Get a signal named name.

        If .strict is True this will raise a ValueError if the signal name
        doesn't validate.

        Arguments:
        name, str, the signal name like 'yelp.biz.some_signal'

        Returns:
        Signal
        """
        signal = self.signals.get(name)
        if signal is not None:
            return signal
        else:
            signal = Signalet(name=name, strict=self.strict)
            self.signals[name] = signal
            return signal

    def function(self, signal_name):
        """Produce a function that generates signals

        Example:
        biz_changed = signals.function('yelp.logic.biz_changed')

        biz_changed(businesses=[...]) # emits yelp.logic.biz_changed signal
        """
        def _function(**kwargs):
            self.send(signal_name, _function, **kwargs)
        return _function

    def method(self, signal_name):
        """Produce a method that generates signals

        Example:
        class Business:
            changed = signals.method('yelp.logic.biz_changed')

        Business.changed(businesses=[...]) # emits yelp.logic.biz_changed signal
        """
        def _method(self, **kwargs):
            self.send(signal_name, self, **kwargs)
        return _method

    def watch(self, signal_name, argument=None):
        """Produce a decorator which will send signal_name whenever the
        decorated function is called.  If "argument" is provided, send()
        will be called with it.
        """
        def decorator(method):
            signal = self._get_signal(signal_name)
            def new_method(*args, **kwargs):
                result = method(*args, **kwargs)
                if argument is not None:
                    signal.send(**{argument: result})
                else:
                    signal.send(signal_name)
                return result

            new_method.__name__ = method.__name__
            new_method.__doc__ = method.__doc__
            return new_method
        return decorator

    def receive(self, signal):
        """Decorate a method to receive signals

        e.g. if you have code like
        @signals.receive('icecream')
        def handle_ice_cream(signal, sender, data):
            ...

        handle_ice_cream() will get called whenever the 'icecream' signal is
        sent.

        NB. This presents a thorny issue in Python and will not work like you
        might want for methods on classes/instances.

        e.g.

        class Foo(object):
            @signals.receive('icecream')
            @classmethod
            def handle_ice_cream(cls, signal, sender, data):
                pass

        This code will crash because handle_ice_cream() will not be called
        with cls as the first argument

        Do this instead:

        class Foo(object):
            @classmethod
            def handle_ice_cream(cls, signal, sender, data):
                pass

        signals.connect('icecream', Foo.handle_ice_cream, weak=False)
        # (not weak otherwise the bound classmethod will be collected
        # immediately)

        Or this:

        class Foo(object):
            @staticmethod
            @signals.receive('icecream')
            def handle_ice_cream(signal, sender, data):
                ...
        """
        def decorator(method):
            self.connect(signal, method)
            return method
        return decorator


class AttrDict(dict):
    """A dictionary with (readonly) attribute access to its keys.
    """
    def __getattr__(self, name):
        try:
            return self[name]
        except KeyError:
            raise AttributeError(name)

_default_center = SignalCenter()
connect = _default_center.connect
disconnect = _default_center.disconnect
watch = _default_center.watch
receive = _default_center.receive
method = _default_center.method
function = _default_center.function
send = _default_center.send
send_safe = _default_center.send_safe
send_after = _default_center.send_after
after_calls = _default_center.after_calls
reset_after_calls = _default_center.reset_after_calls
