# -*- coding: utf-8 -*-
import contextlib
import warnings

import sqlalchemy.exc as sa_exc
from sqlalchemy.ext.declarative import DeclarativeMeta
from sqlalchemy.ext.declarative import declarative_base as declarative_base_sa
from sqlalchemy.orm import Session
from sqlalchemy.orm import sessionmaker as sessionmaker_sa
from sqlalchemy.orm.scoping import ScopedSession
from sqlalchemy.orm.scoping import instrument
from sqlalchemy.orm.scoping import makeprop
from sqlalchemy.orm.util import _class_to_mapper
import sqlalchemy.sql.util as sql_util

# TODO: Make this a lazy import and break the connection more.
import yelp_conn.connection_set


class YelpConnDeclarativeMeta(DeclarativeMeta):
    """Extension of SQLAlchemy's declarative system"""
    def __init__(cls, name, bases, attrs):
        """Attaches __cluster__ to the table's info['cluster_name']"""
        cluster_name = getattr(cls, '__cluster__', None)

        super(YelpConnDeclarativeMeta, cls).__init__(name, bases, attrs)

        if cluster_name:
            cls.__table__.info['cluster_name'] = cluster_name


def declarative_base(**kw):
    """Generate a custom configured declarative base for use with YelpConnSession"""
    assert 'metaclass' not in kw, (
        "You do not want to call yelp_conn.session.declarative_base with "
        "the metaclass argument, use "
        "sqlalchemy.ext.declarative.declarative_base instead"
    )
    kw['metaclass'] = YelpConnDeclarativeMeta
    return declarative_base_sa(**kw)


def get_cluster_name_for_mapper_or_clause(mapper, clause):
    # The code below is almost exactly like what is in the SQLAlchemy code.
    # You can see the latest version of it at:
    # https://bitbucket.org/zzzeek/sqlalchemy/src/HEAD/lib/sqlalchemy/orm/session.py?at=master
    # However, it uses cluster_name on the table to find the database to use.
    if mapper is clause is None:
        raise sa_exc.UnboundExecutionError("No context was provided to locate a "
        "binding.")

    c_mapper = mapper is not None and _class_to_mapper(mapper) or None

    cluster_name = None

    if c_mapper is not None:
        table = c_mapper.mapped_table
        cluster_name = table.info.get('cluster_name')
    elif clause is not None:
        for table in sql_util.find_tables(clause, include_crud=True):
            if 'cluster_name' in table.info:
                cluster_name = table.info['cluster_name']
                break

    if cluster_name:
        return cluster_name

    context = []
    if mapper is not None:
        context.append('mapper %s' % c_mapper)
    if clause is not None:
        context.append('SQL expression')

    raise sa_exc.UnboundExecutionError("Could not locate a cluster "
        "configured on %s or this Session" % ( ', '.join(context)))


class YelpConnSession(Session):
    """This custom session uses ``yelp_conn`` to aquire database connections."""

    # These methods will be proxied by the ScopedSession.
    yelp_conn_public_methods = ('connection_set', 'relinquish')

    yelp_conn_properties = ('master_connection_set',
            'slave_connection_set',
            'reporting_connection_set',
            'connection_set_master_write',
            'connection_set_master_read',
            'connection_set_slave_read',
            'connection_set_reporting_read',
            'enforce_read_only')

    enforce_read_only = True

    def __init__(self, *args, **kwargs):
        """Construct a new YelpConnSession"""
        self.get_connection_set = kwargs.pop('connection_sets', None)
        if self.get_connection_set is None:
            self.get_connection_set = yelp_conn.connection_set.get_connection_set

        self.master_connection_set_name = kwargs.pop('master_connection_set_name', 'primary_rw')
        self.slave_connection_set_name = kwargs.pop('slave_connection_set_name', 'primary_ro')
        self.reporting_connection_set_name = kwargs.pop('reporting_connection_set_name', 'primary_reporting')

        # Currently explicitly bound engine. Will always be returned if set.
        self.bind = None

        # The stack of connections currently in use.
        self.connection_set_stack = []

        # Every connection set used.
        self.connection_sets_used = set()

        # Is this session currently in a relinquished state.
        # We start not relinquished as without a connection on the stack
        # binding won't work anyways.
        self.is_relinquished = False

        super(YelpConnSession, self).__init__(*args, **kwargs)

    @property
    def outer_connection_set(self):
        """Return the outer most SessionConnection."""
        if not self.connection_set_stack:
            return None
        return self.connection_set_stack[0]

    @property
    def current_connection_set(self):
        """Return the current SessionConnection."""
        if not self.connection_set_stack:
            return None
        return self.connection_set_stack[-1]

    def get_bind(self, mapper=None, clause=None):
        """Fetch the right engine to use.

        Model classes can have a ``__cluster__`` attribute which is put on the
        table's info which is used to find which connection set to use.

        This function is used by SQLAlchemy internally to find the engine to
        use.
        """
        if self._flushing and self.enforce_read_only:
            # TODO: Do we need this still?
            raise RuntimeError("Writes while read only is enforced is not "
                "allowed. Check that the session's enforce_read_only property "
                "is set to False.")

        if not self.transaction:
            raise RuntimeError("Must be inside of a transaction context when "
                "getting a bind.")

        # If bind is set directly, return it here.
        if self.bind:
            return self.bind

        if self.is_relinquished:
            raise sa_exc.UnboundExecutionError("This session has relinquished "
                "database access.")

        if not self.current_connection_set:
            raise sa_exc.UnboundExecutionError("This session does not have a "
                "connection set. Use .connection_set.")

        if self._flushing and self.current_connection_set.read_only:
            raise sa_exc.UnboundExecutionError("Cannot write to a read only "
                "connection set.")

        cluster_name = get_cluster_name_for_mapper_or_clause(mapper, clause)
        return self.current_connection_set.get_engine(cluster_name)

    def relinquish(self):
        """Relinquish database access.

        After this function is called, no further database access can be done.
        The current transaction will be committed.

        .. warning::

            Using relinquish as a context manager has hard to understand
            interactions with transactions. Read the source code comment and
            talk to someone else before using this.

        If used as a context manager, database access will be restored
        afterwards. Check the source code for more details.
        """
        if len(self.connection_set_stack) != 1:
            raise RuntimeError("Cannot relinquish unless in only exactly "
                "one connection set context.")

        self.flush()

        # Saving all the objects in the identity map so that they can be put
        # back in the session on the other side of a relinquish block.
        objects = list(self.identity_map.values())
        connection_stack = self.connection_set_stack

        self.expunge_all()

        # Must commit before relinquishing
        self.commit()

        # Reliniqush access to the database and clear out the connection stack.
        self.is_relinquished = True
        self.connection_set_stack = []

        # This is a context manager which can be used to unrelinquish the
        # database connection. Using this context manager means that you can
        # create multiple transactions in a single logical block.
        #
        # Since this block commits, you will lose consistency. The next code
        # written after the context manager closes will be in a new isolation
        # environment. This is probably not what you intend in the common case
        # as you usually either want to send some data to the database to log
        # that you sent a message to another server rather than try and do
        # work after you have sent a message in case of failures.
        @contextlib.contextmanager
        def unrelinqish():
            try:
                yield
                self.add_all(objects)
                self.connection_set_stack = connection_stack
            finally:
                self._unrelinquish()
        return unrelinqish()

    def _unrelinquish(self):
        """Unrelinquish database access.

        This function should never appear in application code.
        """
        if self.is_relinquished:
            self.is_relinquished = False

    @contextlib.contextmanager
    def connection_set(self, connection_set_name, read_only=None):
        """Context manager for using a connection set.

        This context manager is the basis for the other ``connection_set_``
        context managers.

        These context managers can be nested to access different connection
        sets. However, a read write connection cannot be nested inside of a
        read only connection.

        :param connection_set_name:
            The name of the connection set to connect to.

        """
        if read_only is not None:
            warnings.warn("Setting read_only in connection set is deprecated", DeprecationWarning)

        connection_set = self.get_connection_set(connection_set_name)

        read_only = connection_set.read_only or self.enforce_read_only

        if self.outer_connection_set:
            if not self.outer_connection_set.read_only and not read_only:
                raise RuntimeError("Cannot nest read write connection sets.")

        try:
            self.connection_set_stack.append(connection_set)
            self.connection_sets_used.add(connection_set)
            yield
        finally:
            if self.connection_set_stack:
                self.connection_set_stack.pop()

    def close(self):
        if self.new or self.deleted or self.dirty:
            warnings.warn("Closing a session with writes still in progress. Did you forgot to .commit()?")

        # Session.close() releases all known connections back to the pool, which
        # normally performs a rollback as well.  But we have that disabled (via
        # reset_on_return on the pool itself) for yelp-main reasons.  So do the
        # rollback here, explicitly.
        self.rollback()

        return super(YelpConnSession, self).close()

    @property
    def master_connection_set(self):
        """Context manager for a connection on the master database.

        This is typically the only database you can write to.
        """
        return self.connection_set(self.master_connection_set_name)

    @property
    def slave_connection_set(self):
        """Context manager for a connection on the slave database.

        This is the most commonly used connection. Reading from a slave
        immediately after writing to the master could have replication
        delay.
        """
        return self.connection_set(self.slave_connection_set_name)

    @property
    def reporting_connection_set(self):
        """Context manager for a connection on the reporting database.

        This is used when you want to run long running transactions on a
        database. This is further behind replication than the slave as well.
        """
        return self.connection_set(self.reporting_connection_set_name)

    @property
    def connection_set_master_write(self):
        warnings.warn("Using connection_set_master_write is deprecated. Use master_connection_set instead.", DeprecationWarning)
        return self.master_connection_set

    @property
    def connection_set_master_read(self):
        warnings.warn("Using connection_set_master_read is deprecated. Use master_connection_set instead.", DeprecationWarning)
        return self.master_connection_set

    @property
    def connection_set_slave_read(self):
        warnings.warn("Using connection_set_slave_read is deprecated. Use slave_connection_set instead.", DeprecationWarning)
        return self.slave_connection_set

    @property
    def connection_set_reporting_read(self):
        warnings.warn("Using connection_set_reporting_read is deprecated. Use reporting_connection_set instead.", DeprecationWarning)
        return self.reporting_connection_set

class YelpConnScopedSession(ScopedSession):
    """This is a custom subclass of ``sqlalchemy.orm.scoping.ScopedSession``
    that is returned from ``scoped_session``. Use ``scoped_session`` rather
    than this.

    This passes through most functions through to the underlying session.
    """
    @contextlib.contextmanager
    def connect_begin(self, ro=None):
        """Session tranasaction context manager.

        Implement something similar in your service if you need more functionality
        than what this provides.

        Inspired by the context manager given in the `sqlalchemy documentation`_

        .. _sqlalchemy documentation: http://docs.sqlalchemy.org/en/rel_0_8/orm/session.html#when-do-i-construct-a-session-when-do-i-commit-it-and-when-do-i-close-it
        """
        if ro is None:
            raise ValueError("ro must be set.")

        session = self()
        try:
            if ro:
                with session.slave_connection_set:
                    yield session
            else:
                self.enforce_read_only = False
                with session.master_connection_set:
                    yield session
                    session.commit()
        except:
            session.rollback()
            raise
        finally:
            session.enforce_read_only = True
            session.close()
            self.remove()

for meth in YelpConnSession.yelp_conn_public_methods:
    setattr(YelpConnScopedSession, meth, instrument(meth))

for prop in YelpConnSession.yelp_conn_properties:
    setattr(YelpConnScopedSession, prop, makeprop(prop))

def sessionmaker(**kw):
    """Generate a custom configured Session class with the YelpConnSession"""
    if 'class_' in kw:
        raise RuntimeError("You do not want to call "
        "yelp_conn.session.sessionmaker with the class_ argument, use "
        "sqlalchemy.orm.sessionmaker instead")
    if 'bind' in kw:
        raise RuntimeError("yelp_conn will handle binding your session. Use "
        "sqlalchemy.orm.sessionmaker instead")
    kw['class_'] = YelpConnSession
    return sessionmaker_sa(**kw)

scoped_session = YelpConnScopedSession

# Below here is an older version trying to accomplish similar things.
# If you need to update yelp_conn without updating the database pattern
# these classes can be used. They will be removed eventually.

class YelpConnWithUseSession(Session):
    """This is a deprecated custom session using ``yelp_conn`` to aquire
    database connections.

    The ``.use`` context manager fetches a specfic connection set for
    use. ``.writable`` must be used before a read write connection can
    be grabbed.
    """

    yelp_conn_public_methods = ('use', 'writable', 'writeable')

    yelp_conn_properties = ('read_only',)

    def __init__(self, *args, **kwargs):
        """Construct a new YelpConnWithUseSession

        :param default_engine_name:
            The default engine your session connects to.
        """
        self.default_engine_name = kwargs.pop('default_engine_name', None)
        self.read_only = True


        self.get_connection_set = kwargs.pop('connection_sets', None)
        if self.get_connection_set is None:
            self.get_connection_set = yelp_conn.connection_set.get_connection_set

        super(YelpConnWithUseSession, self).__init__(*args, **kwargs)

    @contextlib.contextmanager
    def use(self, connection_set_name, engine_name=None):
        """Begin a transaction on a specific connection set and engine

        This changes the session to point at a specific connection set and
        engine for the duration of the context. A transaction is also started
        for the duration of the context, if the context does not throw any
        exceptions, the transaction is committed, otherwise it is rolled back.

        If the session has ``read_only`` set to True, if the connection set is not
        marked read only as well, this will throw an exception.

        :param connection_set_name:
            The name of the connection set to use

        :param engine_name:
            If engine name is set, uses that one.
            Otherwise, use whatever default_engine_name the session was constructed with
        """
        connection_set = self.get_connection_set(connection_set_name)

        if self.read_only and not connection_set.read_only:
            raise RuntimeError("Tried to get a read write connection with a read only session")

        engine_name = engine_name or self.default_engine_name
        engine = connection_set.get_engine(engine_name)

        old_bind = self.bind
        self.bind = engine
        try:
            yield
            self.commit()
        except:
            self.rollback()
            raise
        finally:
            self.bind = old_bind

    @contextlib.contextmanager
    def writable(self):
        """Allow using read write database connections.

        During this context manager, you can use read-write databases.
        At the end, you are returned to only being able to use read-only
        databases.
        """
        try:
            self.read_only = False
            yield
        finally:
            self.read_only = True

    # Alias for misspelling.
    writeable = writable

def sessionmaker_with_use(**kw):
    """Generate a custom configured Session class with the YelpConnSession"""
    if 'class_' in kw:
        raise RuntimeError("You do not want to call "
        "yelp_conn.session.sessionmaker with the class_ argument, use "
        "sqlalchemy.orm.sessionmaker instead")
    if 'bind' in kw:
        raise RuntimeError("yelp_conn will handle binding your session. Use "
        "sqlalchemy.orm.sessionmaker instead")
    kw['class_'] = YelpConnWithUseSession
    return sessionmaker_sa(**kw)

class YelpConnWithUseScopedSession(ScopedSession):
    """This is a custom subclass of ``sqlalchemy.orm.scoping.ScopedSession``
    that is returned from ``scoped_session``. Use ``scoped_session`` rather
    than this.

    This passes through most functions through to the underlying session.
    """
    def remove(self):
        # Need to call this to have yelp_conn release the handles.
        yelp_conn.engine.reset()
        return super(YelpConnWithUseScopedSession, self).remove()

for meth in YelpConnWithUseSession.yelp_conn_public_methods:
    setattr(YelpConnWithUseScopedSession, meth, instrument(meth))

for prop in YelpConnWithUseSession.yelp_conn_properties:
    setattr(YelpConnWithUseScopedSession, prop, makeprop(prop))
